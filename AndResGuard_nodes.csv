"Node_Id:ID(Node)",":LABEL","name","tokens","documentation","Project"
"0","Project","AndResGuard","AndResGuard","None"
"1","Package","com.tencent.mm.resourceproguard.cli","com.tencent.mm.resourceproguard.cli","None"
"2","Class","CliMain","CliMain","Created by simsun on 1 9 16"
"3","Field","ARG_HELP","None","None"
"4","Field","ARG_OUT","None","None"
"5","Field","ARG_FINAL_APK_PATH","None","None"
"6","Field","ARG_CONFIG","None","None"
"7","Field","ARG_7ZIP","None","None"
"8","Field","ARG_ZIPALIGN","None","None"
"9","Field","ARG_SIGNATURE","None","None"
"10","Field","ARG_KEEPMAPPING","None","None"
"11","Field","ARG_REPACKAGE","None","None"
"12","Field","ARG_SIGNATURE_TYPE","None","None"
"13","Field","VALUE_SIGNATURE_TYPE_V1","None","None"
"14","Field","VALUE_SIGNATURE_TYPE_V2","None","None"
"15","Field","args","None","None"
"16","Field","m","None","None"
"17","Field","m","None","None"
"18","Field","f","None","None"
"19","Field","out","None","None"
"20","Field","command","None","None"
"21","Field","out","None","None"
"22","Field","args","None","None"
"23","Field","argWidth","None","None"
"24","Field","arg","None","None"
"25","Field","sb","None","None"
"26","Field","indent","None","None"
"27","Field","formatString","None","None"
"28","Field","arg","None","None"
"29","Field","description","None","None"
"30","Field","explanation","None","None"
"31","Field","lineWidth","None","None"
"32","Field","hangingIndent","None","None"
"33","Field","explanationLength","None","None"
"34","Field","sb","None","None"
"35","Field","index","None","None"
"36","Field","lineEnd","None","None"
"37","Field","next","None","None"
"38","Field","lastSpace","None","None"
"39","Field","args","None","None"
"40","Field","readArgs","None","None"
"41","Field","configFile","None","None"
"42","Field","signatureFile","None","None"
"43","Field","mappingFile","None","None"
"44","Field","keypass","None","None"
"45","Field","storealias","None","None"
"46","Field","storepass","None","None"
"47","Field","signedFile","None","None"
"48","Field","outputFile","None","None"
"49","Field","finalApkFile","None","None"
"50","Field","apkFileName","None","None"
"51","Field","signatureType","None","None"
"52","Field","repackage","None","None"
"53","Field","configFile","None","None"
"54","Field","signatureFile","None","None"
"55","Field","mappingFile","None","None"
"56","Field","keypass","None","None"
"57","Field","storealias","None","None"
"58","Field","storepass","None","None"
"59","Field","end","None","None"
"60","Field","args","None","None"
"61","Field","configFile","None","None"
"62","Field","outputFile","None","None"
"63","Field","finalApkFile","None","None"
"64","Field","apkFileName","None","None"
"65","Field","signatureFile","None","None"
"66","Field","mappingFile","None","None"
"67","Field","keypass","None","None"
"68","Field","storealias","None","None"
"69","Field","storepass","None","None"
"70","Field","signatureType","None","None"
"71","Field","signedFile","None","None"
"72","Field","args","None","None"
"73","Field","arg","None","None"
"74","Field","parent","None","None"
"75","Field","parent","None","None"
"76","Method","main","public static void main(String[] args) {
    mBeginTime = System.currentTimeMillis();
    CliMain m = new CliMain();
    setRunningLocation(m);
    m.run(args);
  }","None"
"77","Field","args","None","None"
"78","Field","m","None","None"
"79","Method","setRunningLocation","private static void setRunningLocation(CliMain m) {
    mRunningLocation = m.getClass().getProtectionDomain().getCodeSource().getLocation().getPath();
    try {
      mRunningLocation = URLDecoder.decode(mRunningLocation, ""utf-8"");
    } catch (UnsupportedEncodingException e) {
      e.printStackTrace();
    }
    if (mRunningLocation.endsWith("".jar"")) {
      mRunningLocation = mRunningLocation.substring(0, mRunningLocation.lastIndexOf(File.separator) + 1);
    }
    File f = new File(mRunningLocation);
    mRunningLocation = f.getAbsolutePath();
  }","None"
"80","Field","m","None","None"
"81","Field","f","None","None"
"82","Method","printUsage","private static void printUsage(PrintStream out) {
    // TODO: Look up launcher script name!
    String command = ""resousceproguard.jar""; //$NON-NLS-1$
    out.println();
    out.println();
    out.println(""Usage: java -jar "" + command + "" input.apk"");
    out.println(""if you want to special the output path or config file path, you can input:"");
    out.println(""Such as: java -jar ""
                + command
                + "" ""
                + ""input.apk ""
                + ARG_CONFIG
                + "" yourconfig.xml ""
                + ARG_OUT
                + "" output_directory"");
    out.println(""if you want to special the sign or mapping data, you can input:"");
    out.println(""Such as: java -jar ""
                + command
                + "" ""
                + ""input.apk ""
                + ARG_CONFIG
                + "" yourconfig.xml ""
                + ARG_OUT
                + "" output_directory ""
                + ARG_SIGNATURE
                + "" signature_file_path storepass keypass storealias ""
                + ARG_KEEPMAPPING
                + "" mapping_file_path"");
    out.println(""if you want to special the signature type, you can input:"");
    out.printf(""Such as: java -jar %s input.apk %s %s/%s\n"",
        command,
        ARG_SIGNATURE_TYPE,
        VALUE_SIGNATURE_TYPE_V1,
        VALUE_SIGNATURE_TYPE_V2
    );

    out.println(""if you want to special 7za or zipalign path, you can input:"");
    out.println(""Such as: java -jar ""
                + command
                + "" ""
                + ""input.apk ""
                + ARG_7ZIP
                + "" /home/shwenzhang/tools/7za ""
                + ARG_ZIPALIGN
                + "" /home/shwenzhang/sdk/tools/zipalign"");

    out.println(""if you just want to repackage an apk compress with 7z:"");
    out.println(""Such as: java -jar "" + command + "" "" + ARG_REPACKAGE + "" input.apk"");
    out.println(""if you want to special the output path, 7za or zipalign path, you can input:"");
    out.println(""Such as: java -jar ""
                + command
                + "" ""
                + ARG_REPACKAGE
                + "" input.apk""
                + ARG_OUT
                + "" output_directory ""
                + ARG_7ZIP
                + "" /home/shwenzhang/tools/7za ""
                + ARG_ZIPALIGN
                + ""/home/shwenzhang/sdk/tools/zipalign"");
    out.println(""if you want to special the final apk path, you can input:"");
    out.printf(""Such as: java -jar %s input.apk %s final_apk_path\n"", command, ARG_FINAL_APK_PATH);
    out.println();
    out.println(""Flags:\n"");

    printUsage(out, new String[] {
        ARG_HELP, ""This message."", ""-h"", ""short for -help"", ARG_OUT,
        ""set the output directory yourself, if not, the default directory is the running location with name of the input file"",
        ARG_CONFIG,
        ""set the config file yourself, if not, the default path is the running location with name config.xml"",
        ARG_SIGNATURE, ""set sign property, following by parameters: signature_file_path storepass keypass storealias"",
        ""  "", ""if you set these, the sign data in the config file will be overlayed"", ARG_KEEPMAPPING,
        ""set keep mapping property, following by parameters: mapping_file_path"", ""  "",
        ""if you set these, the mapping data in the config file will be overlayed"", ARG_7ZIP,
        ""set the 7zip path, such as /home/shwenzhang/tools/7za, window will be end of 7za.exe"", ARG_ZIPALIGN,
        ""set the zipalign, such as /home/shwenzhang/sdk/tools/zipalign, window will be end of zipalign.exe"",
        ARG_REPACKAGE, ""usually, when we build the channeles apk, it may destroy the 7zip."", ""  "",
        ""so you may need to use 7zip to repackage the apk"",
    });
    out.println();
    out.println(""if you donot know how to write the config file, look at the comment in the default config.xml"");
    out.println(""if you want to use 7z, you must install the 7z command line version in window;"");
    out.println(""sudo apt-get install p7zip-full in linux"");
  }","None"
"83","Field","out","None","None"
"84","Field","command","None","None"
"85","Method","printUsage","private static void printUsage(PrintStream out, String[] args) {
    int argWidth = 0;
    for (int i = 0; i < args.length; i += 2) {
      String arg = args[i];
      argWidth = Math.max(argWidth, arg.length());
    }
    argWidth += 2;
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < argWidth; i++) {
      sb.append(' ');
    }
    String indent = sb.toString();
    String formatString = ""%1$-"" + argWidth + ""s%2$s""; //$NON-NLS-1$

    for (int i = 0; i < args.length; i += 2) {
      String arg = args[i];
      String description = args[i + 1];
      if (arg.length() == 0) {
        out.println(description);
      } else {
        out.print(wrap(String.format(formatString, arg, description), 300, indent));
      }
    }
  }","None"
"86","Field","out","None","None"
"87","Field","args","None","None"
"88","Field","argWidth","None","None"
"89","Field","arg","None","None"
"90","Field","sb","None","None"
"91","Field","indent","None","None"
"92","Field","formatString","None","None"
"93","Field","arg","None","None"
"94","Field","description","None","None"
"95","Method","wrap","private static String wrap(String explanation, int lineWidth, String hangingIndent) {
    int explanationLength = explanation.length();
    StringBuilder sb = new StringBuilder(explanationLength * 2);
    int index = 0;

    while (index < explanationLength) {
      int lineEnd = explanation.indexOf('\n', index);
      int next;

      if (lineEnd != -1 && (lineEnd - index) < lineWidth) {
        next = lineEnd + 1;
      } else {
        // Line is longer than available width; grab as much as we can
        lineEnd = Math.min(index + lineWidth, explanationLength);
        if (lineEnd - index < lineWidth) {
          next = explanationLength;
        } else {
          // then back up to the last space
          int lastSpace = explanation.lastIndexOf(' ', lineEnd);
          if (lastSpace > index) {
            lineEnd = lastSpace;
            next = lastSpace + 1;
          } else {
            // No space anywhere on the line: it contains something wider than
            // can fit (like a long URL) so just hard break it
            next = lineEnd + 1;
          }
        }
      }
      if (sb.length() > 0) {
        sb.append(hangingIndent);
      } else {
        lineWidth -= hangingIndent.length();
      }
      sb.append(explanation.substring(index, lineEnd));
      sb.append('\n');
      index = next;
    }

    return sb.toString();
  }","None"
"96","Field","explanation","None","None"
"97","Field","lineWidth","None","None"
"98","Field","hangingIndent","None","None"
"99","Field","explanationLength","None","None"
"100","Field","sb","None","None"
"101","Field","index","None","None"
"102","Field","lineEnd","None","None"
"103","Field","next","None","None"
"104","Field","lastSpace","None","None"
"105","Method","run","private void run(String[] args) {
    synchronized (CliMain.class) {
      if (args.length < 1) {
        goToError();
      }
      final ReadArgs readArgs = new ReadArgs(args).invoke();
      final File configFile = readArgs.getConfigFile();
      final File signatureFile = readArgs.getSignatureFile();
      final File mappingFile = readArgs.getMappingFile();
      final String keypass = readArgs.getKeypass();
      final String storealias = readArgs.getStorealias();
      final String storepass = readArgs.getStorepass();
      final String signedFile = readArgs.getSignedFile();
      final File outputFile = readArgs.getOutputFile();
      final File finalApkFile = readArgs.getFinalApkFile();
      final String apkFileName = readArgs.getApkFileName();
      final InputParam.SignatureType signatureType = readArgs.getSignatureType();
      loadConfigFromXml(configFile, signatureFile, mappingFile, keypass, storealias, storepass);

      //对于repackage模式，不管之前的东东，直接return
      if (signedFile != null) {
        ResourceRepackage repackage = new ResourceRepackage(config.mZipalignPath,
            config.m7zipPath,
            new File(signedFile)
        );
        try {
          if (outputFile != null) {
            repackage.setOutDir(outputFile);
          }
          repackage.repackageApk();
        } catch (IOException | InterruptedException e) {
          e.printStackTrace();
        }
        return;
      }
      System.out.printf(""[AndResGuard] begin: %s, %s, %s\n"", outputFile, finalApkFile, apkFileName);
      resourceProguard(outputFile, finalApkFile, apkFileName, signatureType);
      System.out.printf(""[AndResGuard] done, total time cost: %fs\n"", diffTimeFromBegin());
      System.out.printf(""[AndResGuard] done, you can go to file to find the output %s\n"", mOutDir.getAbsolutePath());
      clean();
    }
  }","None"
"106","Field","args","None","None"
"107","Field","readArgs","None","None"
"108","Field","configFile","None","None"
"109","Field","signatureFile","None","None"
"110","Field","mappingFile","None","None"
"111","Field","keypass","None","None"
"112","Field","storealias","None","None"
"113","Field","storepass","None","None"
"114","Field","signedFile","None","None"
"115","Field","outputFile","None","None"
"116","Field","finalApkFile","None","None"
"117","Field","apkFileName","None","None"
"118","Field","signatureType","None","None"
"119","Field","repackage","None","None"
"120","Method","loadConfigFromXml","private void loadConfigFromXml(
      File configFile, File signatureFile, File mappingFile, String keypass, String storealias, String storepass) {
    if (configFile == null) {
      configFile = new File(mRunningLocation + File.separator + TypedValue.CONFIG_FILE);
      if (!configFile.exists()) {
        System.err.printf(""the config file %s does not exit"", configFile.getAbsolutePath());
        printUsage(System.err);
        System.exit(ERRNO_USAGE);
      }
    }
    try {
      //不需要检查命令行的设置
      if (!mSetSignThroughCmd) {
        signatureFile = null;
      }
      if (!mSetMappingThroughCmd) {
        mappingFile = null;
      }
      config = new Configuration(configFile,
          m7zipPath,
          mZipalignPath,
          mappingFile,
          signatureFile,
          keypass,
          storealias,
          storepass
      );
    } catch (IOException | ParserConfigurationException | SAXException e) {
      e.printStackTrace();
      goToError();
    }
  }","None"
"121","Field","configFile","None","None"
"122","Field","signatureFile","None","None"
"123","Field","mappingFile","None","None"
"124","Field","keypass","None","None"
"125","Field","storealias","None","None"
"126","Field","storepass","None","None"
"127","Method","diffTimeFromBegin","public double diffTimeFromBegin() {
    long end = System.currentTimeMillis();
    return (end - mBeginTime) / 1000.0;
  }","None"
"128","Field","end","None","None"
"129","Method","goToError","protected void goToError() {
    printUsage(System.err);
    System.exit(ERRNO_USAGE);
  }","None"
"130","Class","ReadArgs","ReadArgs","None"
"131","Field","args","None","None"
"132","Field","configFile","None","None"
"133","Field","outputFile","None","None"
"134","Field","finalApkFile","None","None"
"135","Field","apkFileName","None","None"
"136","Field","signatureFile","None","None"
"137","Field","mappingFile","None","None"
"138","Field","keypass","None","None"
"139","Field","storealias","None","None"
"140","Field","storepass","None","None"
"141","Field","signatureType","None","None"
"142","Field","signedFile","None","None"
"143","Field","args","None","None"
"144","Field","arg","None","None"
"145","Field","parent","None","None"
"146","Field","parent","None","None"
"147","Method","getConfigFile","public File getConfigFile() {
      return configFile;
    }","None"
"148","Method","getOutputFile","public File getOutputFile() {
      return outputFile;
    }","None"
"149","Method","getFinalApkFile","public File getFinalApkFile() {
      return finalApkFile;
    }","None"
"150","Method","getApkFileName","public String getApkFileName() {
      return apkFileName;
    }","None"
"151","Method","getSignatureFile","public File getSignatureFile() {
      return signatureFile;
    }","None"
"152","Method","getMappingFile","public File getMappingFile() {
      return mappingFile;
    }","None"
"153","Method","getKeypass","public String getKeypass() {
      return keypass;
    }","None"
"154","Method","getStorealias","public String getStorealias() {
      return storealias;
    }","None"
"155","Method","getStorepass","public String getStorepass() {
      return storepass;
    }","None"
"156","Method","getSignatureType","public InputParam.SignatureType getSignatureType() {
      return signatureType;
    }","None"
"157","Method","getSignedFile","public String getSignedFile() {
      return signedFile;
    }","None"
"158","Method","invoke","public ReadArgs invoke() {
      for (int index = 0; index < args.length; index++) {
        String arg = args[index];
        if (arg.equals(ARG_HELP) || arg.equals(""-h"")) {
          goToError();
        } else if (arg.equals(ARG_CONFIG)) {
          if (index == args.length - 1 || !args[index + 1].endsWith(TypedValue.XML_FILE)) {
            System.err.println(""Missing XML configuration file argument"");
            goToError();
          }
          configFile = new File(args[++index]);
          if (!configFile.exists()) {
            System.err.println(configFile.getAbsolutePath() + "" does not exist"");
            goToError();
          }
          System.out.printf(""special configFile file path: %s\n"", configFile.getAbsolutePath());
        } else if (arg.equals(ARG_OUT)) {
          if (index == args.length - 1) {
            System.err.println(""Missing output file argument"");
            goToError();
          }
          outputFile = new File(args[++index]);
          File parent = outputFile.getParentFile();
          if (parent != null && (!parent.exists())) {
            parent.mkdirs();
          }
          System.out.printf(""special output directory path: %s\n"", outputFile.getAbsolutePath());
        } else if (arg.equals(ARG_FINAL_APK_PATH)) {
          if (index == args.length - 1) {
            System.err.println(""Missing output file argument"");
            goToError();
          }
          finalApkFile = new File(args[++index]);
          File parent = finalApkFile.getParentFile();
          if (parent != null && (!parent.exists())) {
            parent.mkdirs();
          }
          System.out.printf(""special final apk file path: %s\n"", finalApkFile.getAbsolutePath());
        } else if (arg.equals(ARG_SIGNATURE)) {
          //需要检查是否有四个参数
          if (index == args.length - 1) {
            System.err.println(""Missing signature data argument, should be ""
                               + ARG_SIGNATURE
                               + "" signature_file_path storepass keypass storealias"");
            goToError();
          }

          //在后面设置的时候会检查文件是否存在
          signatureFile = new File(args[++index]);

          if (index == args.length - 1) {
            System.err.println(""Missing signature data argument, should be ""
                               + ARG_SIGNATURE
                               + "" signature_file_path storepass keypass storealias"");
            goToError();
          }

          storepass = args[++index];

          if (index == args.length - 1) {
            System.err.println(""Missing signature data argument, should be ""
                               + ARG_SIGNATURE
                               + "" signature_file_path storepass keypass storealias"");
            goToError();
          }

          keypass = args[++index];

          if (index == args.length - 1) {
            System.err.println(""Missing signature data argument, should be ""
                               + ARG_SIGNATURE
                               + "" signature_file_path storepass keypass storealias"");
            goToError();
          }
          storealias = args[++index];
          mSetSignThroughCmd = true;
        } else if (arg.equals(ARG_SIGNATURE_TYPE)) {
          if (index == args.length - 1) {
            System.err.println(""Missing signature type argument"");
            goToError();
          }

          if (VALUE_SIGNATURE_TYPE_V2.equalsIgnoreCase(args[++index])) {
            signatureType = InputParam.SignatureType.SchemaV2;
          } else {
            signatureType = InputParam.SignatureType.SchemaV1;
          }
        } else if (arg.equals(ARG_KEEPMAPPING)) {
          if (index == args.length - 1) {
            System.err.println(""Missing mapping file argument"");
            goToError();
          }
          //在后面设置的时候会检查文件是否存在
          mappingFile = new File(args[++index]);
          mSetMappingThroughCmd = true;
        } else if (arg.equals(ARG_7ZIP)) {
          if (index == args.length - 1) {
            System.err.println(""Missing 7zip path argument"");
            goToError();
          }
          m7zipPath = args[++index];
        } else if (arg.equals(ARG_ZIPALIGN)) {
          if (index == args.length - 1) {
            System.err.println(""Missing zipalign path argument"");
            goToError();
          }

          mZipalignPath = args[++index];
        } else if (arg.equals(ARG_REPACKAGE)) {
          //这个模式的话就直接干活了，不会再理其他命令！
          if (index == args.length - 1) {
            System.err.println(""Missing the signed apk file argument"");
            goToError();
          }
          signedFile = args[++index];
        } else {
          apkFileName = arg;
        }
      }
      return this;
    }","None"
"159","Field","arg","None","None"
"160","Field","parent","None","None"
"161","Field","parent","None","None"
"162","Package","apksigner","apksigner","None"
"163","Class","HexEncoding","HexEncoding","Hexadecimal encoding where each byte is represented by two hexadecimal digits"
"164","Field","HEX_DIGITS","None","None"
"165","Field","data","None","None"
"166","Field","offset","None","None"
"167","Field","length","None","None"
"168","Field","result","None","None"
"169","Field","b","None","None"
"170","Field","data","None","None"
"171","Field","data","None","None"
"172","Method","encode","public static String encode(byte[] data, int offset, int length) {
    StringBuilder result = new StringBuilder(length * 2);
    for (int i = 0; i < length; i++) {
      byte b = data[offset + i];
      result.append(HEX_DIGITS[(b >>> 4) & 0x0f]);
      result.append(HEX_DIGITS[b & 0x0f]);
    }
    return result.toString();
  }","Encodes the provided data as a hexadecimal string"
"173","Field","data","None","None"
"174","Field","offset","None","None"
"175","Field","length","None","None"
"176","Field","result","None","None"
"177","Field","b","None","None"
"178","Method","encode","public static String encode(byte[] data) {
    return encode(data, 0, data.length);
  }","Encodes the provided data as a hexadecimal string"
"179","Field","data","None","None"
"180","Method","encodeRemaining","public static String encodeRemaining(ByteBuffer data) {
    return encode(data.array(), data.arrayOffset() + data.position(), data.remaining());
  }","Encodes the remaining bytes of the provided {@link ByteBuffer} as a hexadecimal string"
"181","Field","data","None","None"
"182","Class","ApkSignerTool","ApkSignerTool","Command-line tool for signing APKs and for checking whether an APK's signature are expected to verify on Android devices"
"183","Field","VERSION","None","None"
"184","Field","HELP_PAGE_GENERAL","None","None"
"185","Field","HELP_PAGE_SIGN","None","None"
"186","Field","HELP_PAGE_VERIFY","None","None"
"187","Field","params","None","None"
"188","Field","cmd","None","None"
"189","Field","params","None","None"
"190","Field","outputApk","None","None"
"191","Field","inputApk","None","None"
"192","Field","verbose","None","None"
"193","Field","v1SigningEnabled","None","None"
"194","Field","v2SigningEnabled","None","None"
"195","Field","v3SigningEnabled","None","None"
"196","Field","minSdkVersion","None","None"
"197","Field","minSdkVersionSpecified","None","None"
"198","Field","maxSdkVersion","None","None"
"199","Field","signers","None","None"
"200","Field","signerParams","None","None"
"201","Field","optionsParser","None","None"
"202","Field","optionName","None","None"
"203","Field","optionOriginalForm","None","None"
"204","Field","signerConfigs","None","None"
"205","Field","signerNumber","None","None"
"206","Field","v1SigBasename","None","None"
"207","Field","keyFileName","None","None"
"208","Field","delimiterIndex","None","None"
"209","Field","signerConfig","None","None"
"210","Field","tmpOutputApk","None","None"
"211","Field","apkSignerBuilder","None","None"
"212","Field","apkSigner","None","None"
"213","Field","msg","None","None"
"214","Field","params","None","None"
"215","Field","inputApk","None","None"
"216","Field","minSdkVersion","None","None"
"217","Field","minSdkVersionSpecified","None","None"
"218","Field","maxSdkVersion","None","None"
"219","Field","maxSdkVersionSpecified","None","None"
"220","Field","printCerts","None","None"
"221","Field","verbose","None","None"
"222","Field","warningsTreatedAsErrors","None","None"
"223","Field","optionsParser","None","None"
"224","Field","optionName","None","None"
"225","Field","optionOriginalForm","None","None"
"226","Field","apkVerifierBuilder","None","None"
"227","Field","apkVerifier","None","None"
"228","Field","result","None","None"
"229","Field","msg","None","None"
"230","Field","verified","None","None"
"231","Field","warningsEncountered","None","None"
"232","Field","signerCerts","None","None"
"233","Field","signerNumber","None","None"
"234","Field","sha256","None","None"
"235","Field","sha1","None","None"
"236","Field","md5","None","None"
"237","Field","encodedCert","None","None"
"238","Field","publicKey","None","None"
"239","Field","keySize","None","None"
"240","Field","dsaParams","None","None"
"241","Field","encodedKey","None","None"
"242","Field","warningsOut","None","None"
"243","Field","signerName","None","None"
"244","Field","signerName","None","None"
"245","Field","page","None","None"
"246","Field","line","None","None"
"247","Field","file","None","None"
"248","Field","result","None","None"
"249","Field","in","None","None"
"250","Field","out","None","None"
"251","Field","buf","None","None"
"252","Field","chunkSize","None","None"
"253","Field","name","None","None"
"254","Field","keystoreFile","None","None"
"255","Field","keystoreKeyAlias","None","None"
"256","Field","keystorePasswordSpec","None","None"
"257","Field","keyPasswordSpec","None","None"
"258","Field","keystoreType","None","None"
"259","Field","keystoreProviderName","None","None"
"260","Field","keystoreProviderClass","None","None"
"261","Field","keystoreProviderArg","None","None"
"262","Field","keyFile","None","None"
"263","Field","certFile","None","None"
"264","Field","v1SigFileBasename","None","None"
"265","Field","privateKey","None","None"
"266","Field","certs","None","None"
"267","Field","ks","None","None"
"268","Field","file","None","None"
"269","Field","passwords","None","None"
"270","Field","lastFailure","None","None"
"271","Field","ks","None","None"
"272","Field","keyAlias","None","None"
"273","Field","passwords","None","None"
"274","Field","lastFailure","None","None"
"275","Field","encryptedPrivateKeyInfo","None","None"
"276","Field","passwords","None","None"
"277","Field","keyFactory","None","None"
"278","Field","lastKeySpecException","None","None"
"279","Field","lastKeyException","None","None"
"280","Field","decryptionKeySpec","None","None"
"281","Field","decryptionKey","None","None"
"282","Field","spec","None","None"
"283","Field","passwordRetriever","None","None"
"284","Field","passwordRetriever","None","None"
"285","Field","ksType","None","None"
"286","Field","ks","None","None"
"287","Field","ksProviderClass","None","None"
"288","Field","ksProvider","None","None"
"289","Field","keystorePasswords","None","None"
"290","Field","keystorePasswordSpec","None","None"
"291","Field","keyAlias","None","None"
"292","Field","key","None","None"
"293","Field","aliases","None","None"
"294","Field","entryAlias","None","None"
"295","Field","entryKey","None","None"
"296","Field","keyPasswords","None","None"
"297","Field","keyPasswords","None","None"
"298","Field","certChain","None","None"
"299","Field","passwordRetriver","None","None"
"300","Field","privateKeyBlob","None","None"
"301","Field","keySpec","None","None"
"302","Field","encryptedPrivateKeyInfo","None","None"
"303","Field","passwordSpec","None","None"
"304","Field","keyPasswords","None","None"
"305","Field","certs","None","None"
"306","Field","certList","None","None"
"307","Field","serialVersionUID","None","None"
"308","Field","message","None","None"
"309","Method","main","public static void main(String[] params) throws Exception {
    if ((params.length == 0) || (""--help"".equals(params[0])) || (""-h"".equals(params[0]))) {
      printUsage(HELP_PAGE_GENERAL);
      return;
    } else if (""--version"".equals(params[0])) {
      System.out.println(VERSION);
      return;
    }

    String cmd = params[0];
    try {
      if (""sign"".equals(cmd)) {
        sign(Arrays.copyOfRange(params, 1, params.length));
        return;
      } else if (""verify"".equals(cmd)) {
        verify(Arrays.copyOfRange(params, 1, params.length));
        return;
      } else if (""help"".equals(cmd)) {
        printUsage(HELP_PAGE_GENERAL);
        return;
      } else if (""version"".equals(cmd)) {
        System.out.println(VERSION);
        return;
      } else {
        throw new ParameterException(""Unsupported command: "" + cmd + "". See --help for supported commands"");
      }
    } catch (ParameterException | OptionsParser.OptionsException e) {
      System.err.println(e.getMessage());
      System.exit(1);
      return;
    }
  }","None"
"310","Field","params","None","None"
"311","Field","cmd","None","None"
"312","Method","sign","private static void sign(String[] params) throws Exception {
    if (params.length == 0) {
      printUsage(HELP_PAGE_SIGN);
      return;
    }

    File outputApk = null;
    File inputApk = null;
    boolean verbose = false;
    boolean v1SigningEnabled = true;
    boolean v2SigningEnabled = true;
    boolean v3SigningEnabled = false;
    int minSdkVersion = 1;
    boolean minSdkVersionSpecified = false;
    int maxSdkVersion = Integer.MAX_VALUE;
    List<SignerParams> signers = new ArrayList<>(1);
    SignerParams signerParams = new SignerParams();
    OptionsParser optionsParser = new OptionsParser(params);
    String optionName;
    String optionOriginalForm = null;
    while ((optionName = optionsParser.nextOption()) != null) {
      optionOriginalForm = optionsParser.getOptionOriginalForm();
      if ((""help"".equals(optionName)) || (""h"".equals(optionName))) {
        printUsage(HELP_PAGE_SIGN);
        return;
      } else if (""out"".equals(optionName)) {
        outputApk = new File(optionsParser.getRequiredValue(""Output file name""));
      } else if (""in"".equals(optionName)) {
        inputApk = new File(optionsParser.getRequiredValue(""Input file name""));
      } else if (""min-sdk-version"".equals(optionName)) {
        minSdkVersion = optionsParser.getRequiredIntValue(""Mininimum API Level"");
        minSdkVersionSpecified = true;
      } else if (""max-sdk-version"".equals(optionName)) {
        maxSdkVersion = optionsParser.getRequiredIntValue(""Maximum API Level"");
      } else if (""v1-signing-enabled"".equals(optionName)) {
        v1SigningEnabled = optionsParser.getOptionalBooleanValue(true);
      } else if (""v2-signing-enabled"".equals(optionName)) {
        v2SigningEnabled = optionsParser.getOptionalBooleanValue(true);
      }  else if (""v3-signing-enabled"".equals(optionName)) {
        v3SigningEnabled = optionsParser.getOptionalBooleanValue(false);
      } else if (""next-signer"".equals(optionName)) {
        if (!signerParams.isEmpty()) {
          signers.add(signerParams);
          signerParams = new SignerParams();
        }
      } else if (""ks"".equals(optionName)) {
        signerParams.keystoreFile = optionsParser.getRequiredValue(""KeyStore file"");
      } else if (""ks-key-alias"".equals(optionName)) {
        signerParams.keystoreKeyAlias = optionsParser.getRequiredValue(""KeyStore key alias"");
      } else if (""ks-pass"".equals(optionName)) {
        signerParams.keystorePasswordSpec = optionsParser.getRequiredValue(""KeyStore password"");
      } else if (""key-pass"".equals(optionName)) {
        signerParams.keyPasswordSpec = optionsParser.getRequiredValue(""Key password"");
      } else if (""v1-signer-name"".equals(optionName)) {
        signerParams.v1SigFileBasename = optionsParser.getRequiredValue(""JAR signature file basename"");
      } else if (""ks-type"".equals(optionName)) {
        signerParams.keystoreType = optionsParser.getRequiredValue(""KeyStore type"");
      } else if (""ks-provider-name"".equals(optionName)) {
        signerParams.keystoreProviderName = optionsParser.getRequiredValue(""JCA KeyStore Provider name"");
      } else if (""ks-provider-class"".equals(optionName)) {
        signerParams.keystoreProviderClass = optionsParser.getRequiredValue(""JCA KeyStore Provider class name"");
      } else if (""ks-provider-arg"".equals(optionName)) {
        signerParams.keystoreProviderArg = optionsParser.getRequiredValue(""JCA KeyStore Provider constructor argument"");
      } else if (""key"".equals(optionName)) {
        signerParams.keyFile = optionsParser.getRequiredValue(""Private key file"");
      } else if (""cert"".equals(optionName)) {
        signerParams.certFile = optionsParser.getRequiredValue(""Certificate file"");
      } else if ((""v"".equals(optionName)) || (""verbose"".equals(optionName))) {
        verbose = optionsParser.getOptionalBooleanValue(true);
      } else {
        throw new ParameterException(""Unsupported option: ""
                                     + optionOriginalForm
                                     + "". See --help for supported""
                                     + "" options."");
      }
    }
    if (!signerParams.isEmpty()) {
      signers.add(signerParams);
    }
    signerParams = null;

    if (signers.isEmpty()) {
      throw new ParameterException(""At least one signer must be specified"");
    }

    params = optionsParser.getRemainingParams();
    if (inputApk != null) {
      // Input APK has been specified via preceding parameters. We don't expect any more
      // parameters.
      if (params.length > 0) {
        throw new ParameterException(""Unexpected parameter(s) after "" + optionOriginalForm + "": "" + params[0]);
      }
    } else {
      // Input APK has not been specified via preceding parameters. The next parameter is
      // supposed to be the path to input APK.
      if (params.length < 1) {
        throw new ParameterException(""Missing input APK"");
      } else if (params.length > 1) {
        throw new ParameterException(""Unexpected parameter(s) after input APK ("" + params[1] + "")"");
      }
      inputApk = new File(params[0]);
    }
    if ((minSdkVersionSpecified) && (minSdkVersion > maxSdkVersion)) {
      throw new ParameterException(""Min API Level ("" + minSdkVersion + "") > max API Level ("" + maxSdkVersion + "")"");
    }

    List<ApkSigner.SignerConfig> signerConfigs = new ArrayList<>(signers.size());
    int signerNumber = 0;
    try (PasswordRetriever passwordRetriever = new PasswordRetriever()) {
      for (SignerParams signer : signers) {
        signerNumber++;
        signer.name = ""signer #"" + signerNumber;
        try {
          signer.loadPrivateKeyAndCerts(passwordRetriever);
        } catch (ParameterException e) {
          System.err.println(""Failed to load signer \"""" + signer.name + ""\"": "" + e.getMessage());
          System.exit(2);
          return;
        } catch (Exception e) {
          System.err.println(""Failed to load signer \"""" + signer.name + ""\"""");
          e.printStackTrace();
          System.exit(2);
          return;
        }
        String v1SigBasename;
        if (signer.v1SigFileBasename != null) {
          v1SigBasename = signer.v1SigFileBasename;
        } else if (signer.keystoreKeyAlias != null) {
          v1SigBasename = signer.keystoreKeyAlias;
        } else if (signer.keyFile != null) {
          String keyFileName = new File(signer.keyFile).getName();
          int delimiterIndex = keyFileName.indexOf('.');
          if (delimiterIndex == -1) {
            v1SigBasename = keyFileName;
          } else {
            v1SigBasename = keyFileName.substring(0, delimiterIndex);
          }
        } else {
          throw new RuntimeException(""Neither KeyStore key alias nor private key file available"");
        }
        ApkSigner.SignerConfig signerConfig = new ApkSigner.SignerConfig.Builder(v1SigBasename,
            signer.privateKey,
            signer.certs
        ).build();
        signerConfigs.add(signerConfig);
      }
    }

    if (outputApk == null) {
      outputApk = inputApk;
    }
    File tmpOutputApk;
    if (inputApk.getCanonicalPath().equals(outputApk.getCanonicalPath())) {
      tmpOutputApk = File.createTempFile(""apksigner"", "".apk"");
      tmpOutputApk.deleteOnExit();
    } else {
      tmpOutputApk = outputApk;
    }
    ApkSigner.Builder apkSignerBuilder = new ApkSigner.Builder(signerConfigs).setInputApk(inputApk)
        .setOutputApk(tmpOutputApk)
        .setOtherSignersSignaturesPreserved(false)
        .setV1SigningEnabled(v1SigningEnabled)
        .setV2SigningEnabled(v2SigningEnabled)
        .setV3SigningEnabled(v3SigningEnabled);
    if (minSdkVersionSpecified) {
      apkSignerBuilder.setMinSdkVersion(minSdkVersion);
    }
    ApkSigner apkSigner = apkSignerBuilder.build();
    try {
      apkSigner.sign();
    } catch (MinSdkVersionException e) {
      String msg = e.getMessage();
      if (!msg.endsWith(""."")) {
        msg += '.';
      }
      throw new MinSdkVersionException(""Failed to determine APK's minimum supported platform version""
                                       + "". Use --min-sdk-version to override"", e);
    }
    if (!tmpOutputApk.getCanonicalPath().equals(outputApk.getCanonicalPath())) {
      Files.move(tmpOutputApk.toPath(), outputApk.toPath(), StandardCopyOption.REPLACE_EXISTING);
    }

    if (verbose) {
      System.out.println(""Signed"");
    }
  }","None"
"313","Field","params","None","None"
"314","Field","outputApk","None","None"
"315","Field","inputApk","None","None"
"316","Field","verbose","None","None"
"317","Field","v1SigningEnabled","None","None"
"318","Field","v2SigningEnabled","None","None"
"319","Field","v3SigningEnabled","None","None"
"320","Field","minSdkVersion","None","None"
"321","Field","minSdkVersionSpecified","None","None"
"322","Field","maxSdkVersion","None","None"
"323","Field","signers","None","None"
"324","Field","signerParams","None","None"
"325","Field","optionsParser","None","None"
"326","Field","optionName","None","None"
"327","Field","optionOriginalForm","None","None"
"328","Field","signerConfigs","None","None"
"329","Field","signerNumber","None","None"
"330","Field","v1SigBasename","None","None"
"331","Field","keyFileName","None","None"
"332","Field","delimiterIndex","None","None"
"333","Field","signerConfig","None","None"
"334","Field","tmpOutputApk","None","None"
"335","Field","apkSignerBuilder","None","None"
"336","Field","apkSigner","None","None"
"337","Field","msg","None","None"
"338","Method","verify","private static void verify(String[] params) throws Exception {
    if (params.length == 0) {
      printUsage(HELP_PAGE_VERIFY);
      return;
    }

    File inputApk = null;
    int minSdkVersion = 1;
    boolean minSdkVersionSpecified = false;
    int maxSdkVersion = Integer.MAX_VALUE;
    boolean maxSdkVersionSpecified = false;
    boolean printCerts = false;
    boolean verbose = false;
    boolean warningsTreatedAsErrors = false;
    OptionsParser optionsParser = new OptionsParser(params);
    String optionName;
    String optionOriginalForm = null;
    while ((optionName = optionsParser.nextOption()) != null) {
      optionOriginalForm = optionsParser.getOptionOriginalForm();
      if (""min-sdk-version"".equals(optionName)) {
        minSdkVersion = optionsParser.getRequiredIntValue(""Mininimum API Level"");
        minSdkVersionSpecified = true;
      } else if (""max-sdk-version"".equals(optionName)) {
        maxSdkVersion = optionsParser.getRequiredIntValue(""Maximum API Level"");
        maxSdkVersionSpecified = true;
      } else if (""print-certs"".equals(optionName)) {
        printCerts = optionsParser.getOptionalBooleanValue(true);
      } else if ((""v"".equals(optionName)) || (""verbose"".equals(optionName))) {
        verbose = optionsParser.getOptionalBooleanValue(true);
      } else if (""Werr"".equals(optionName)) {
        warningsTreatedAsErrors = optionsParser.getOptionalBooleanValue(true);
      } else if ((""help"".equals(optionName)) || (""h"".equals(optionName))) {
        printUsage(HELP_PAGE_VERIFY);
        return;
      } else if (""in"".equals(optionName)) {
        inputApk = new File(optionsParser.getRequiredValue(""Input APK file""));
      } else {
        throw new ParameterException(""Unsupported option: ""
                                     + optionOriginalForm
                                     + "". See --help for supported""
                                     + "" options."");
      }
    }
    params = optionsParser.getRemainingParams();

    if (inputApk != null) {
      // Input APK has been specified in preceding parameters. We don't expect any more
      // parameters.
      if (params.length > 0) {
        throw new ParameterException(""Unexpected parameter(s) after "" + optionOriginalForm + "": "" + params[0]);
      }
    } else {
      // Input APK has not been specified in preceding parameters. The next parameter is
      // supposed to be the input APK.
      if (params.length < 1) {
        throw new ParameterException(""Missing APK"");
      } else if (params.length > 1) {
        throw new ParameterException(""Unexpected parameter(s) after APK ("" + params[1] + "")"");
      }
      inputApk = new File(params[0]);
    }

    if ((minSdkVersionSpecified) && (maxSdkVersionSpecified) && (minSdkVersion > maxSdkVersion)) {
      throw new ParameterException(""Min API Level ("" + minSdkVersion + "") > max API Level ("" + maxSdkVersion + "")"");
    }

    ApkVerifier.Builder apkVerifierBuilder = new ApkVerifier.Builder(inputApk);
    if (minSdkVersionSpecified) {
      apkVerifierBuilder.setMinCheckedPlatformVersion(minSdkVersion);
    }
    if (maxSdkVersionSpecified) {
      apkVerifierBuilder.setMaxCheckedPlatformVersion(maxSdkVersion);
    }
    ApkVerifier apkVerifier = apkVerifierBuilder.build();
    ApkVerifier.Result result;
    try {
      result = apkVerifier.verify();
    } catch (MinSdkVersionException e) {
      String msg = e.getMessage();
      if (!msg.endsWith(""."")) {
        msg += '.';
      }
      throw new MinSdkVersionException(""Failed to determine APK's minimum supported platform version""
                                       + "". Use --min-sdk-version to override"", e);
    }
    boolean verified = result.isVerified();

    boolean warningsEncountered = false;
    if (verified) {
      List<X509Certificate> signerCerts = result.getSignerCertificates();
      if (verbose) {
        System.out.println(""Verifies"");
        System.out.println(""Verified using v1 scheme (JAR signing): "" + result.isVerifiedUsingV1Scheme());
        System.out.println(""Verified using v2 scheme (APK Signature Scheme v2): "" + result.isVerifiedUsingV2Scheme());
        System.out.println(""Number of signers: "" + signerCerts.size());
      }
      if (printCerts) {
        int signerNumber = 0;
        MessageDigest sha256 = MessageDigest.getInstance(""SHA-256"");
        MessageDigest sha1 = MessageDigest.getInstance(""SHA-1"");
        MessageDigest md5 = MessageDigest.getInstance(""MD5"");
        for (X509Certificate signerCert : signerCerts) {
          signerNumber++;
          System.out.println(""Signer #"" + signerNumber + "" certificate DN"" + "": "" + signerCert.getSubjectDN());
          byte[] encodedCert = signerCert.getEncoded();
          System.out.println(""Signer #""
                             + signerNumber
                             + "" certificate SHA-256 digest: ""
                             + HexEncoding.encode(sha256.digest(encodedCert)));
          System.out.println(""Signer #"" + signerNumber + "" certificate SHA-1 digest: "" + HexEncoding.encode(sha1.digest(
              encodedCert)));
          System.out.println(""Signer #"" + signerNumber + "" certificate MD5 digest: "" + HexEncoding.encode(md5.digest(
              encodedCert)));
          if (verbose) {
            PublicKey publicKey = signerCert.getPublicKey();
            System.out.println(""Signer #"" + signerNumber + "" key algorithm: "" + publicKey.getAlgorithm());
            int keySize = -1;
            if (publicKey instanceof RSAKey) {
              keySize = ((RSAKey) publicKey).getModulus().bitLength();
            } else if (publicKey instanceof ECKey) {
              keySize = ((ECKey) publicKey).getParams().getOrder().bitLength();
            } else if (publicKey instanceof DSAKey) {
              // DSA parameters may be inherited from the certificate. We
              // don't handle this case at the moment.
              DSAParams dsaParams = ((DSAKey) publicKey).getParams();
              if (dsaParams != null) {
                keySize = dsaParams.getP().bitLength();
              }
            }
            System.out.println(""Signer #"" + signerNumber + "" key size (bits): "" + ((keySize != -1) ? String.valueOf(
                keySize) : ""n/a""));
            byte[] encodedKey = publicKey.getEncoded();
            System.out.println(""Signer #""
                               + signerNumber
                               + "" public key SHA-256 digest: ""
                               + HexEncoding.encode(sha256.digest(encodedKey)));
            System.out.println(""Signer #""
                               + signerNumber
                               + "" public key SHA-1 digest: ""
                               + HexEncoding.encode(sha1.digest(encodedKey)));
            System.out.println(""Signer #"" + signerNumber + "" public key MD5 digest: "" + HexEncoding.encode(md5.digest(
                encodedKey)));
          }
        }
      }
    } else {
      System.err.println(""DOES NOT VERIFY"");
    }

    for (ApkVerifier.IssueWithParams error : result.getErrors()) {
      System.err.println(""ERROR: "" + error);
    }

    @SuppressWarnings(""resource"") // false positive -- this resource is not opened here
        PrintStream warningsOut = (warningsTreatedAsErrors) ? System.err : System.out;
    for (ApkVerifier.IssueWithParams warning : result.getWarnings()) {
      warningsEncountered = true;
      warningsOut.println(""WARNING: "" + warning);
    }
    for (ApkVerifier.Result.V1SchemeSignerInfo signer : result.getV1SchemeSigners()) {
      String signerName = signer.getName();
      for (ApkVerifier.IssueWithParams error : signer.getErrors()) {
        System.err.println(""ERROR: JAR signer "" + signerName + "": "" + error);
      }
      for (ApkVerifier.IssueWithParams warning : signer.getWarnings()) {
        warningsEncountered = true;
        warningsOut.println(""WARNING: JAR signer "" + signerName + "": "" + warning);
      }
    }
    for (ApkVerifier.Result.V2SchemeSignerInfo signer : result.getV2SchemeSigners()) {
      String signerName = ""signer #"" + (signer.getIndex() + 1);
      for (ApkVerifier.IssueWithParams error : signer.getErrors()) {
        System.err.println(""ERROR: APK Signature Scheme v2 "" + signerName + "": "" + error);
      }
      for (ApkVerifier.IssueWithParams warning : signer.getWarnings()) {
        warningsEncountered = true;
        warningsOut.println(""WARNING: APK Signature Scheme v2 "" + signerName + "": "" + warning);
      }
    }

    if (!verified) {
      System.exit(1);
      return;
    }
    if ((warningsTreatedAsErrors) && (warningsEncountered)) {
      System.exit(1);
      return;
    }
  }","None"
"339","Field","params","None","None"
"340","Field","inputApk","None","None"
"341","Field","minSdkVersion","None","None"
"342","Field","minSdkVersionSpecified","None","None"
"343","Field","maxSdkVersion","None","None"
"344","Field","maxSdkVersionSpecified","None","None"
"345","Field","printCerts","None","None"
"346","Field","verbose","None","None"
"347","Field","warningsTreatedAsErrors","None","None"
"348","Field","optionsParser","None","None"
"349","Field","optionName","None","None"
"350","Field","optionOriginalForm","None","None"
"351","Field","apkVerifierBuilder","None","None"
"352","Field","apkVerifier","None","None"
"353","Field","result","None","None"
"354","Field","msg","None","None"
"355","Field","verified","None","None"
"356","Field","warningsEncountered","None","None"
"357","Field","signerCerts","None","None"
"358","Field","signerNumber","None","None"
"359","Field","sha256","None","None"
"360","Field","sha1","None","None"
"361","Field","md5","None","None"
"362","Field","encodedCert","None","None"
"363","Field","publicKey","None","None"
"364","Field","keySize","None","None"
"365","Field","dsaParams","None","None"
"366","Field","encodedKey","None","None"
"367","Field","warningsOut","None","None"
"368","Field","signerName","None","None"
"369","Field","signerName","None","None"
"370","Method","printUsage","private static void printUsage(String page) {
    try (BufferedReader in = new BufferedReader(new InputStreamReader(
        ApkSignerTool.class.getResourceAsStream(page),
        StandardCharsets.UTF_8
    ))) {
      String line;
      while ((line = in.readLine()) != null) {
        System.out.println(line);
      }
    } catch (IOException e) {
      throw new RuntimeException(""Failed to read "" + page + "" resource"");
    }
  }","None"
"371","Field","page","None","None"
"372","Field","line","None","None"
"373","Method","readFully","private static byte[] readFully(File file) throws IOException {
    ByteArrayOutputStream result = new ByteArrayOutputStream();
    try (FileInputStream in = new FileInputStream(file)) {
      drain(in, result);
    }
    return result.toByteArray();
  }","None"
"374","Field","file","None","None"
"375","Field","result","None","None"
"376","Method","drain","private static void drain(InputStream in, OutputStream out) throws IOException {
    byte[] buf = new byte[65536];
    int chunkSize;
    while ((chunkSize = in.read(buf)) != -1) {
      out.write(buf, 0, chunkSize);
    }
  }","None"
"377","Field","in","None","None"
"378","Field","out","None","None"
"379","Field","buf","None","None"
"380","Field","chunkSize","None","None"
"381","Class","SignerParams","SignerParams","None"
"382","Field","name","None","None"
"383","Field","keystoreFile","None","None"
"384","Field","keystoreKeyAlias","None","None"
"385","Field","keystorePasswordSpec","None","None"
"386","Field","keyPasswordSpec","None","None"
"387","Field","keystoreType","None","None"
"388","Field","keystoreProviderName","None","None"
"389","Field","keystoreProviderClass","None","None"
"390","Field","keystoreProviderArg","None","None"
"391","Field","keyFile","None","None"
"392","Field","certFile","None","None"
"393","Field","v1SigFileBasename","None","None"
"394","Field","privateKey","None","None"
"395","Field","certs","None","None"
"396","Field","ks","None","None"
"397","Field","file","None","None"
"398","Field","passwords","None","None"
"399","Field","lastFailure","None","None"
"400","Field","ks","None","None"
"401","Field","keyAlias","None","None"
"402","Field","passwords","None","None"
"403","Field","lastFailure","None","None"
"404","Field","encryptedPrivateKeyInfo","None","None"
"405","Field","passwords","None","None"
"406","Field","keyFactory","None","None"
"407","Field","lastKeySpecException","None","None"
"408","Field","lastKeyException","None","None"
"409","Field","decryptionKeySpec","None","None"
"410","Field","decryptionKey","None","None"
"411","Field","spec","None","None"
"412","Field","passwordRetriever","None","None"
"413","Field","passwordRetriever","None","None"
"414","Field","ksType","None","None"
"415","Field","ks","None","None"
"416","Field","ksProviderClass","None","None"
"417","Field","ksProvider","None","None"
"418","Field","keystorePasswords","None","None"
"419","Field","keystorePasswordSpec","None","None"
"420","Field","keyAlias","None","None"
"421","Field","key","None","None"
"422","Field","aliases","None","None"
"423","Field","entryAlias","None","None"
"424","Field","entryKey","None","None"
"425","Field","keyPasswords","None","None"
"426","Field","keyPasswords","None","None"
"427","Field","certChain","None","None"
"428","Field","passwordRetriver","None","None"
"429","Field","privateKeyBlob","None","None"
"430","Field","keySpec","None","None"
"431","Field","encryptedPrivateKeyInfo","None","None"
"432","Field","passwordSpec","None","None"
"433","Field","keyPasswords","None","None"
"434","Field","certs","None","None"
"435","Field","certList","None","None"
"436","Method","loadKeyStoreFromFile","private static void loadKeyStoreFromFile(KeyStore ks, String file, List<char[]> passwords) throws Exception {
      Exception lastFailure = null;
      for (char[] password : passwords) {
        try {
          try (FileInputStream in = new FileInputStream(file)) {
            ks.load(in, password);
          }
          return;
        } catch (Exception e) {
          lastFailure = e;
        }
      }
      if (lastFailure == null) {
        throw new RuntimeException(""No keystore passwords"");
      } else {
        throw lastFailure;
      }
    }","None"
"437","Field","ks","None","None"
"438","Field","file","None","None"
"439","Field","passwords","None","None"
"440","Field","lastFailure","None","None"
"441","Method","getKeyStoreKey","private static Key getKeyStoreKey(KeyStore ks, String keyAlias, List<char[]> passwords)
        throws UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException {
      UnrecoverableKeyException lastFailure = null;
      for (char[] password : passwords) {
        try {
          return ks.getKey(keyAlias, password);
        } catch (UnrecoverableKeyException e) {
          lastFailure = e;
        }
      }
      if (lastFailure == null) {
        throw new RuntimeException(""No key passwords"");
      } else {
        throw lastFailure;
      }
    }","None"
"442","Field","ks","None","None"
"443","Field","keyAlias","None","None"
"444","Field","passwords","None","None"
"445","Field","lastFailure","None","None"
"446","Method","decryptPkcs8EncodedKey","private static PKCS8EncodedKeySpec decryptPkcs8EncodedKey(
        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo, List<char[]> passwords)
        throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException {
      SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName());
      InvalidKeySpecException lastKeySpecException = null;
      InvalidKeyException lastKeyException = null;
      for (char[] password : passwords) {
        PBEKeySpec decryptionKeySpec = new PBEKeySpec(password);
        try {
          SecretKey decryptionKey = keyFactory.generateSecret(decryptionKeySpec);
          return encryptedPrivateKeyInfo.getKeySpec(decryptionKey);
        } catch (InvalidKeySpecException e) {
          lastKeySpecException = e;
        } catch (InvalidKeyException e) {
          lastKeyException = e;
        }
      }
      if ((lastKeyException == null) && (lastKeySpecException == null)) {
        throw new RuntimeException(""No passwords"");
      } else if (lastKeyException != null) {
        throw lastKeyException;
      } else {
        throw lastKeySpecException;
      }
    }","None"
"447","Field","encryptedPrivateKeyInfo","None","None"
"448","Field","passwords","None","None"
"449","Field","keyFactory","None","None"
"450","Field","lastKeySpecException","None","None"
"451","Field","lastKeyException","None","None"
"452","Field","decryptionKeySpec","None","None"
"453","Field","decryptionKey","None","None"
"454","Method","loadPkcs8EncodedPrivateKey","private static PrivateKey loadPkcs8EncodedPrivateKey(PKCS8EncodedKeySpec spec)
        throws InvalidKeySpecException, NoSuchAlgorithmException {
      try {
        return KeyFactory.getInstance(""RSA"").generatePrivate(spec);
      } catch (InvalidKeySpecException expected) {
      }
      try {
        return KeyFactory.getInstance(""EC"").generatePrivate(spec);
      } catch (InvalidKeySpecException expected) {
      }
      try {
        return KeyFactory.getInstance(""DSA"").generatePrivate(spec);
      } catch (InvalidKeySpecException expected) {
      }
      throw new InvalidKeySpecException(""Not an RSA, EC, or DSA private key"");
    }","None"
"455","Field","spec","None","None"
"456","Method","isEmpty","private boolean isEmpty() {
      return (name == null)
             && (keystoreFile == null)
             && (keystoreKeyAlias == null)
             && (keystorePasswordSpec == null)
             && (keyPasswordSpec == null)
             && (keystoreType == null)
             && (keystoreProviderName == null)
             && (keystoreProviderClass == null)
             && (keystoreProviderArg == null)
             && (keyFile == null)
             && (certFile == null)
             && (v1SigFileBasename == null)
             && (privateKey == null)
             && (certs == null);
    }","None"
"457","Method","loadPrivateKeyAndCerts","private void loadPrivateKeyAndCerts(PasswordRetriever passwordRetriever) throws Exception {
      if (keystoreFile != null) {
        if (keyFile != null) {
          throw new ParameterException(""--ks and --key may not be specified at the same time"");
        } else if (certFile != null) {
          throw new ParameterException(""--ks and --cert may not be specified at the same time"");
        }
        loadPrivateKeyAndCertsFromKeyStore(passwordRetriever);
      } else if (keyFile != null) {
        loadPrivateKeyAndCertsFromFiles(passwordRetriever);
      } else {
        throw new ParameterException(""KeyStore (--ks) or private key file (--key) must be specified"");
      }
    }","None"
"458","Field","passwordRetriever","None","None"
"459","Method","loadPrivateKeyAndCertsFromKeyStore","private void loadPrivateKeyAndCertsFromKeyStore(PasswordRetriever passwordRetriever) throws Exception {
      if (keystoreFile == null) {
        throw new ParameterException(""KeyStore (--ks) must be specified"");
      }

      // 1. Obtain a KeyStore implementation
      String ksType = (keystoreType != null) ? keystoreType : KeyStore.getDefaultType();
      KeyStore ks;
      if (keystoreProviderName != null) {
        // Use a named Provider (assumes the provider is already installed)
        ks = KeyStore.getInstance(ksType, keystoreProviderName);
      } else if (keystoreProviderClass != null) {
        // Use a new Provider instance (does not require the provider to be installed)
        Class<?> ksProviderClass = Class.forName(keystoreProviderClass);
        if (!Provider.class.isAssignableFrom(ksProviderClass)) {
          throw new ParameterException(""Keystore Provider class ""
                                       + keystoreProviderClass
                                       + "" not subclass of ""
                                       + Provider.class.getName());
        }
        Provider ksProvider;
        if (keystoreProviderArg != null) {
          // Single-arg Provider constructor
          ksProvider = (Provider) ksProviderClass.getConstructor(String.class).newInstance(keystoreProviderArg);
        } else {
          // No-arg Provider constructor
          ksProvider = (Provider) ksProviderClass.getConstructor().newInstance();
        }
        ks = KeyStore.getInstance(ksType, ksProvider);
      } else {
        // Use the highest-priority Provider which offers the requested KeyStore type
        ks = KeyStore.getInstance(ksType);
      }

      // 2. Load the KeyStore
      List<char[]> keystorePasswords = null;
      if (""NONE"".equals(keystoreFile)) {
        ks.load(null);
      } else {
        String keystorePasswordSpec =
            (this.keystorePasswordSpec != null) ? this.keystorePasswordSpec : PasswordRetriever.SPEC_STDIN;
        keystorePasswords = passwordRetriever.getPasswords(keystorePasswordSpec, ""Keystore password for "" + name);
        loadKeyStoreFromFile(ks, keystoreFile, keystorePasswords);
      }

      // 3. Load the PrivateKey and cert chain from KeyStore
      String keyAlias = null;
      PrivateKey key = null;
      try {
        if (keystoreKeyAlias == null) {
          // Private key entry alias not specified. Find the key entry contained in this
          // KeyStore. If the KeyStore contains multiple key entries, return an error.
          Enumeration<String> aliases = ks.aliases();
          if (aliases != null) {
            while (aliases.hasMoreElements()) {
              String entryAlias = aliases.nextElement();
              if (ks.isKeyEntry(entryAlias)) {
                keyAlias = entryAlias;
                if (keystoreKeyAlias != null) {
                  throw new ParameterException(keystoreFile
                                               + "" contains multiple key entries""
                                               + "". --ks-key-alias option must be used to specify""
                                               + "" which entry to use."");
                }
                keystoreKeyAlias = keyAlias;
              }
            }
          }
          if (keystoreKeyAlias == null) {
            throw new ParameterException(keystoreFile + "" does not contain key entries"");
          }
        }

        // Private key entry alias known. Load that entry's private key.
        keyAlias = keystoreKeyAlias;
        if (!ks.isKeyEntry(keyAlias)) {
          throw new ParameterException(keystoreFile + "" entry \"""" + keyAlias + ""\"" does not contain a key"");
        }

        Key entryKey;
        if (keyPasswordSpec != null) {
          // Key password spec is explicitly specified. Use this spec to obtain the
          // password and then load the key using that password.
          List<char[]> keyPasswords = passwordRetriever.getPasswords(keyPasswordSpec,
              ""Key \"""" + keyAlias + ""\"" password for "" + name
          );
          entryKey = getKeyStoreKey(ks, keyAlias, keyPasswords);
        } else {
          // Key password spec is not specified. This means we should assume that key
          // password is the same as the keystore password and that, if this assumption is
          // wrong, we should prompt for key password and retry loading the key using that
          // password.
          try {
            entryKey = getKeyStoreKey(ks, keyAlias, keystorePasswords);
          } catch (UnrecoverableKeyException expected) {
            List<char[]> keyPasswords = passwordRetriever.getPasswords(PasswordRetriever.SPEC_STDIN,
                ""Key \"""" + keyAlias + ""\"" password for "" + name
            );
            entryKey = getKeyStoreKey(ks, keyAlias, keyPasswords);
          }
        }

        if (entryKey == null) {
          throw new ParameterException(keystoreFile + "" entry \"""" + keyAlias + ""\"" does not contain a key"");
        } else if (!(entryKey instanceof PrivateKey)) {
          throw new ParameterException(keystoreFile
                                       + "" entry \""""
                                       + keyAlias
                                       + ""\"" does not contain a private""
                                       + "" key. It contains a key of algorithm: ""
                                       + entryKey.getAlgorithm());
        }
        key = (PrivateKey) entryKey;
      } catch (UnrecoverableKeyException e) {
        throw new IOException(""Failed to obtain key with alias \""""
                              + keyAlias
                              + ""\"" from ""
                              + keystoreFile
                              + "". Wrong password?"", e);
      }
      this.privateKey = key;
      Certificate[] certChain = ks.getCertificateChain(keyAlias);
      if ((certChain == null) || (certChain.length == 0)) {
        throw new ParameterException(keystoreFile + "" entry \"""" + keyAlias + ""\"" does not contain certificates"");
      }
      this.certs = new ArrayList<>(certChain.length);
      for (Certificate cert : certChain) {
        this.certs.add((X509Certificate) cert);
      }
    }","None"
"460","Field","passwordRetriever","None","None"
"461","Field","ksType","None","None"
"462","Field","ks","None","None"
"463","Field","ksProviderClass","None","None"
"464","Field","ksProvider","None","None"
"465","Field","keystorePasswords","None","None"
"466","Field","keystorePasswordSpec","None","None"
"467","Field","keyAlias","None","None"
"468","Field","key","None","None"
"469","Field","aliases","None","None"
"470","Field","entryAlias","None","None"
"471","Field","entryKey","None","None"
"472","Field","keyPasswords","None","None"
"473","Field","keyPasswords","None","None"
"474","Field","certChain","None","None"
"475","Method","loadPrivateKeyAndCertsFromFiles","private void loadPrivateKeyAndCertsFromFiles(PasswordRetriever passwordRetriver) throws Exception {
      if (keyFile == null) {
        throw new ParameterException(""Private key file (--key) must be specified"");
      }
      if (certFile == null) {
        throw new ParameterException(""Certificate file (--cert) must be specified"");
      }
      byte[] privateKeyBlob = readFully(new File(keyFile));

      PKCS8EncodedKeySpec keySpec;
      // Potentially encrypted key blob
      try {
        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(privateKeyBlob);

        // The blob is indeed an encrypted private key blob
        String passwordSpec = (keyPasswordSpec != null) ? keyPasswordSpec : PasswordRetriever.SPEC_STDIN;
        List<char[]> keyPasswords = passwordRetriver.getPasswords(passwordSpec, ""Private key password for "" + name);
        keySpec = decryptPkcs8EncodedKey(encryptedPrivateKeyInfo, keyPasswords);
      } catch (IOException e) {
        // The blob is not an encrypted private key blob
        if (keyPasswordSpec == null) {
          // Given that no password was specified, assume the blob is an unencrypted
          // private key blob
          keySpec = new PKCS8EncodedKeySpec(privateKeyBlob);
        } else {
          throw new InvalidKeySpecException(""Failed to parse encrypted private key blob "" + keyFile, e);
        }
      }

      // Load the private key from its PKCS #8 encoded form.
      try {
        privateKey = loadPkcs8EncodedPrivateKey(keySpec);
      } catch (InvalidKeySpecException e) {
        throw new InvalidKeySpecException(""Failed to load PKCS #8 encoded private key from "" + keyFile, e);
      }

      // Load certificates
      Collection<? extends Certificate> certs;
      try (FileInputStream in = new FileInputStream(certFile)) {
        certs = CertificateFactory.getInstance(""X.509"").generateCertificates(in);
      }
      List<X509Certificate> certList = new ArrayList<>(certs.size());
      for (Certificate cert : certs) {
        certList.add((X509Certificate) cert);
      }
      this.certs = certList;
    }","None"
"476","Field","passwordRetriver","None","None"
"477","Field","privateKeyBlob","None","None"
"478","Field","keySpec","None","None"
"479","Field","encryptedPrivateKeyInfo","None","None"
"480","Field","passwordSpec","None","None"
"481","Field","keyPasswords","None","None"
"482","Field","certs","None","None"
"483","Field","certList","None","None"
"484","Class","ParameterException","ParameterException","Indicates that there is an issue with command-line parameters provided to this tool"
"485","Field","serialVersionUID","None","None"
"486","Field","message","None","None"
"487","Class","OptionsParser","OptionsParser","Parser of command-line options switches flags. Supported option formats: {@code --name value} {@code --name=value} {@code -name value} {@code --name} (boolean options only) To use the parser, create an instance, providing it with the command-line parameters, then iterate over options by invoking {@link #nextOption()} until it returns {@code null}"
"488","Field","mParams","None","None"
"489","Field","mIndex","None","None"
"490","Field","mLastOptionValue","None","None"
"491","Field","mLastOptionOriginalForm","None","None"
"492","Field","params","None","None"
"493","Field","param","None","None"
"494","Field","valueDelimiterIndex","None","None"
"495","Field","valueDescription","None","None"
"496","Field","result","None","None"
"497","Field","param","None","None"
"498","Field","valueDescription","None","None"
"499","Field","value","None","None"
"500","Field","defaultValue","None","None"
"501","Field","stringValue","None","None"
"502","Field","stringValue","None","None"
"503","Field","param","None","None"
"504","Field","serialVersionUID","None","None"
"505","Field","message","None","None"
"506","Method","nextOption","public String nextOption() {
    if (mIndex >= mParams.length) {
      // No more parameters left
      return null;
    }
    String param = mParams[mIndex];
    if (!param.startsWith(""-"")) {
      // Not an option
      return null;
    }

    mIndex++;
    mLastOptionOriginalForm = param;
    mLastOptionValue = null;
    if (param.startsWith(""--"")) {
      // FORMAT: --name value OR --name=value
      if (""--"".equals(param)) {
        // End of options marker
        return null;
      }
      int valueDelimiterIndex = param.indexOf('=');
      if (valueDelimiterIndex != -1) {
        mLastOptionValue = param.substring(valueDelimiterIndex + 1);
        mLastOptionOriginalForm = param.substring(0, valueDelimiterIndex);
        return param.substring(""--"".length(), valueDelimiterIndex);
      } else {
        return param.substring(""--"".length());
      }
    } else {
      // FORMAT: -name value
      return param.substring(""-"".length());
    }
  }","Returns the name (without leading dashes) of the next option (starting with the very first option) or {@code null} if there are no options left. The value of this option can be obtained via {@link #getRequiredValue(String)}, {@link #getRequiredIntValue(String)}, and {@link #getOptionalBooleanValue(boolean)}"
"507","Field","param","None","None"
"508","Field","valueDelimiterIndex","None","None"
"509","Method","getOptionOriginalForm","public String getOptionOriginalForm() {
    return mLastOptionOriginalForm;
  }","Returns the original form of the current option. The original form includes the leading dash or dashes. This is intended to be used for referencing the option in error messages"
"510","Method","getRequiredValue","public String getRequiredValue(String valueDescription) throws OptionsException {
    if (mLastOptionValue != null) {
      String result = mLastOptionValue;
      mLastOptionValue = null;
      return result;
    }
    if (mIndex >= mParams.length) {
      // No more parameters left
      throw new OptionsException(valueDescription + "" missing after "" + mLastOptionOriginalForm);
    }
    String param = mParams[mIndex];
    if (""--"".equals(param)) {
      // End of options marker
      throw new OptionsException(valueDescription + "" missing after "" + mLastOptionOriginalForm);
    }
    mIndex++;
    return param;
  }","Returns the value of the current option, throwing an exception if the value is missing"
"511","Field","valueDescription","None","None"
"512","Field","result","None","None"
"513","Field","param","None","None"
"514","Method","getRequiredIntValue","public int getRequiredIntValue(String valueDescription) throws OptionsException {
    String value = getRequiredValue(valueDescription);
    try {
      return Integer.parseInt(value);
    } catch (NumberFormatException e) {
      throw new OptionsException(valueDescription
                                 + "" (""
                                 + mLastOptionOriginalForm
                                 + "") must be a decimal number: ""
                                 + value);
    }
  }","Returns the value of the current numeric option, throwing an exception if the value is missing or is not numeric"
"515","Field","valueDescription","None","None"
"516","Field","value","None","None"
"517","Method","getOptionalBooleanValue","public boolean getOptionalBooleanValue(boolean defaultValue) throws OptionsException {
    if (mLastOptionValue != null) {
      // --option=value form
      String stringValue = mLastOptionValue;
      mLastOptionValue = null;
      if (""true"".equals(stringValue)) {
        return true;
      } else if (""false"".equals(stringValue)) {
        return false;
      }
      throw new OptionsException(""Unsupported value for ""
                                 + mLastOptionOriginalForm
                                 + "": ""
                                 + stringValue
                                 + "". Only true or false supported."");
    }

    // --option (true|false) form OR just --option
    if (mIndex >= mParams.length) {
      return defaultValue;
    }

    String stringValue = mParams[mIndex];
    if (""true"".equals(stringValue)) {
      mIndex++;
      return true;
    } else if (""false"".equals(stringValue)) {
      mIndex++;
      return false;
    } else {
      return defaultValue;
    }
  }","Gets the value of the current boolean option. Boolean options are not required to have explicitly specified values"
"518","Field","defaultValue","None","None"
"519","Field","stringValue","None","None"
"520","Field","stringValue","None","None"
"521","Method","getRemainingParams","public String[] getRemainingParams() {
    if (mIndex >= mParams.length) {
      return new String[0];
    }
    String param = mParams[mIndex];
    if (""--"".equals(param)) {
      // Skip end of options marker
      return Arrays.copyOfRange(mParams, mIndex + 1, mParams.length);
    } else {
      return Arrays.copyOfRange(mParams, mIndex, mParams.length);
    }
  }","Returns the remaining command-line parameters. This is intended to be invoked once {@link #nextOption()} returns {@code null}"
"522","Field","param","None","None"
"523","Class","OptionsException","OptionsException","Indicates that an error was encountered while parsing command-line options"
"524","Field","serialVersionUID","None","None"
"525","Field","message","None","None"
"526","Class","PasswordRetriever","PasswordRetriever","Retriever of passwords based on password specs supported by {@code apksigner} tool. apksigner supports retrieving multiple passwords from the same source (e.g., file, standard input) which adds the need to keep some sources open across password retrievals. This class addresses the need. To use this retriever, construct a new instance, use {@link #getPasswords(String, String)} to retrieve passwords, and then invoke {@link #close()} on the instance when done, enabling the instance to release any held resources"
"527","Field","SPEC_STDIN","None","None"
"528","Field","CONSOLE_CHARSET","None","None"
"529","Field","mFileInputStreams","None","None"
"530","Field","mClosed","None","None"
"531","Field","pwd","None","None"
"532","Field","passwords","None","None"
"533","Field","encodedPwd","None","None"
"534","Field","encodings","None","None"
"535","Field","passwords","None","None"
"536","Field","pwd","None","None"
"537","Field","passwords","None","None"
"538","Field","pwd","None","None"
"539","Field","encodedPwd","None","None"
"540","Field","encodedPwd","None","None"
"541","Field","passwords","None","None"
"542","Field","password","None","None"
"543","Field","pwd","None","None"
"544","Field","cs","None","None"
"545","Field","pwdBytes","None","None"
"546","Field","encoded","None","None"
"547","Field","pwdBytes","None","None"
"548","Field","encoding","None","None"
"549","Field","pwdChars","None","None"
"550","Field","result","None","None"
"551","Field","bytes","None","None"
"552","Field","chars","None","None"
"553","Field","consoleCharsetName","None","None"
"554","Field","encodingMethod","None","None"
"555","Field","defaultCharset","None","None"
"556","Field","defaultCharset","None","None"
"557","Field","in","None","None"
"558","Field","result","None","None"
"559","Field","b","None","None"
"560","Field","next","None","None"
"561","Field","spec","None","None"
"562","Field","description","None","None"
"563","Field","pwd","None","None"
"564","Field","console","None","None"
"565","Field","pwd","None","None"
"566","Field","encodedPwd","None","None"
"567","Field","name","None","None"
"568","Field","file","None","None"
"569","Field","in","None","None"
"570","Field","encodedPwd","None","None"
"571","Field","name","None","None"
"572","Field","value","None","None"
"573","Method","getPasswords","private static List<char[]> getPasswords(char[] pwd) {
    List<char[]> passwords = new ArrayList<>(3);
    addPasswords(passwords, pwd);
    return passwords;
  }","Returns the provided password and all password variants derived from the password. The resulting list is guaranteed to contain at least one element"
"574","Field","pwd","None","None"
"575","Field","passwords","None","None"
"576","Method","getPasswords","private static List<char[]> getPasswords(byte[] encodedPwd, Charset... encodings) {
    List<char[]> passwords = new ArrayList<>(4);

    for (Charset encoding : encodings) {
      // Decode password and add it and its variants to the list
      try {
        char[] pwd = decodePassword(encodedPwd, encoding);
        addPasswords(passwords, pwd);
      } catch (IOException ignored) {
      }
    }

    // Add the original encoded form
    addPassword(passwords, castBytesToChars(encodedPwd));
    return passwords;
  }","Returns the provided password and all password variants derived from the password. The resulting list is guaranteed to contain at least one element"
"577","Field","encodedPwd","None","None"
"578","Field","encodings","None","None"
"579","Field","passwords","None","None"
"580","Field","pwd","None","None"
"581","Method","addPasswords","private static void addPasswords(List<char[]> passwords, char[] pwd) {
    // Verbatim password
    addPassword(passwords, pwd);

    // Password encoded using the JVM default character encoding and upcast into char[]
    try {
      char[] encodedPwd = castBytesToChars(encodePassword(pwd, Charset.defaultCharset()));
      addPassword(passwords, encodedPwd);
    } catch (IOException ignored) {
    }

    // Password encoded using console character encoding and upcast into char[]
    if (!CONSOLE_CHARSET.equals(Charset.defaultCharset())) {
      try {
        char[] encodedPwd = castBytesToChars(encodePassword(pwd, CONSOLE_CHARSET));
        addPassword(passwords, encodedPwd);
      } catch (IOException ignored) {
      }
    }
  }","Adds the provided password and its variants to the provided list of passwords. NOTE: This method adds only the passwords variants which are not yet in the list"
"582","Field","passwords","None","None"
"583","Field","pwd","None","None"
"584","Field","encodedPwd","None","None"
"585","Field","encodedPwd","None","None"
"586","Method","addPassword","private static void addPassword(List<char[]> passwords, char[] password) {
    for (char[] existingPassword : passwords) {
      if (Arrays.equals(password, existingPassword)) {
        return;
      }
    }
    passwords.add(password);
  }","Adds the provided password to the provided list. Does nothing if the password is already in the list"
"587","Field","passwords","None","None"
"588","Field","password","None","None"
"589","Method","encodePassword","private static byte[] encodePassword(char[] pwd, Charset cs) throws IOException {
    ByteBuffer pwdBytes = cs.newEncoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(
        CodingErrorAction.REPLACE).encode(CharBuffer.wrap(pwd));
    byte[] encoded = new byte[pwdBytes.remaining()];
    pwdBytes.get(encoded);
    return encoded;
  }","None"
"590","Field","pwd","None","None"
"591","Field","cs","None","None"
"592","Field","pwdBytes","None","None"
"593","Field","encoded","None","None"
"594","Method","decodePassword","private static char[] decodePassword(byte[] pwdBytes, Charset encoding) throws IOException {
    CharBuffer pwdChars = encoding.newDecoder().onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(
        CodingErrorAction.REPLACE).decode(ByteBuffer.wrap(pwdBytes));
    char[] result = new char[pwdChars.remaining()];
    pwdChars.get(result);
    return result;
  }","None"
"595","Field","pwdBytes","None","None"
"596","Field","encoding","None","None"
"597","Field","pwdChars","None","None"
"598","Field","result","None","None"
"599","Method","castBytesToChars","private static char[] castBytesToChars(byte[] bytes) {
    if (bytes == null) {
      return null;
    }

    char[] chars = new char[bytes.length];
    for (int i = 0; i < bytes.length; i++) {
      chars[i] = (char) (bytes[i] & 0xff);
    }
    return chars;
  }","Upcasts each {@code byte} in the provided array of bytes to a {@code char} and returns the resulting array of characters"
"600","Field","bytes","None","None"
"601","Field","chars","None","None"
"602","Method","getConsoleEncoding","private static Charset getConsoleEncoding() {
    // IMPLEMENTATION NOTE: There is no public API for obtaining the console's character
    // encoding. We thus cheat by using implementation details of the most popular JVMs.
    String consoleCharsetName;
    try {
      Method encodingMethod = Console.class.getDeclaredMethod(""encoding"");
      encodingMethod.setAccessible(true);
      consoleCharsetName = (String) encodingMethod.invoke(null);
      if (consoleCharsetName == null) {
        return Charset.defaultCharset();
      }
    } catch (ReflectiveOperationException e) {
      Charset defaultCharset = Charset.defaultCharset();
      System.err.println(""warning: Failed to obtain console character encoding name. Assuming "" + defaultCharset);
      return defaultCharset;
    }

    try {
      return Charset.forName(consoleCharsetName);
    } catch (IllegalArgumentException e) {
      // On Windows 10, cp65001 is the UTF-8 code page. For some reason, popular JVMs don't
      // have a mapping for cp65001...
      if (""cp65001"".equals(consoleCharsetName)) {
        return StandardCharsets.UTF_8;
      }
      Charset defaultCharset = Charset.defaultCharset();
      System.err.println(""warning: Console uses unknown character encoding: ""
                         + consoleCharsetName
                         + "". Using ""
                         + defaultCharset
                         + "" instead"");
      return defaultCharset;
    }
  }","Returns the character encoding used by the console"
"603","Field","consoleCharsetName","None","None"
"604","Field","encodingMethod","None","None"
"605","Field","defaultCharset","None","None"
"606","Field","defaultCharset","None","None"
"607","Method","readEncodedPassword","private static byte[] readEncodedPassword(InputStream in) throws IOException {
    ByteArrayOutputStream result = new ByteArrayOutputStream();
    int b;
    while ((b = in.read()) != -1) {
      if (b == '\n') {
        break;
      } else if (b == '\r') {
        int next = in.read();
        if ((next == -1) || (next == '\n')) {
          break;
        }

        if (!(in instanceof PushbackInputStream)) {
          in = new PushbackInputStream(in);
        }
        ((PushbackInputStream) in).unread(next);
      }
      result.write(b);
    }
    return result.toByteArray();
  }","None"
"608","Field","in","None","None"
"609","Field","result","None","None"
"610","Field","b","None","None"
"611","Field","next","None","None"
"612","Method","getPasswords","public List<char[]> getPasswords(String spec, String description) throws IOException {
    // IMPLEMENTATION NOTE: Java KeyStore and PBEKeySpec APIs take passwords as arrays of
    // Unicode characters (char[]). Unfortunately, it appears that Sun/Oracle keytool and
    // jarsigner in some cases use passwords which are the encoded form obtained using the
    // console's character encoding. For example, if the encoding is UTF-8, keytool and
    // jarsigner will use the password which is obtained by upcasting each byte of the UTF-8
    // encoded form to char. This occurs only when the password is read from stdin/console, and
    // does not occur when the password is read from a command-line parameter.
    // There are other tools which use the Java KeyStore API correctly.
    // Thus, for each password spec, there may be up to three passwords:
    // * Unicode characters,
    // * characters (upcast bytes) obtained from encoding the password using the console's
    //   character encoding,
    // * characters (upcast bytes) obtained from encoding the password using the JVM's default
    //   character encoding.
    //
    // For a sample password ""\u0061\u0062\u00a1\u00e4\u044e\u0031"":
    // On Windows 10 with English US as the UI language, IBM437 is used as console encoding and
    // windows-1252 is used as the JVM default encoding:
    // * keytool -genkey -v -keystore native.jks -keyalg RSA -keysize 2048 -validity 10000
    //     -alias test
    //   generates a keystore and key which decrypt only with
    //   ""\u0061\u0062\u00ad\u0084\u003f\u0031""
    // * keytool -genkey -v -keystore native.jks -keyalg RSA -keysize 2048 -validity 10000
    //     -alias test -storepass <pass here>
    //   generates a keystore and key which decrypt only with
    //   ""\u0061\u0062\u00a1\u00e4\u003f\u0031""
    // On modern OSX/Linux UTF-8 is used as the console and JVM default encoding:
    // * keytool -genkey -v -keystore native.jks -keyalg RSA -keysize 2048 -validity 10000
    //     -alias test
    //   generates a keystore and key which decrypt only with
    //   ""\u0061\u0062\u00c2\u00a1\u00c3\u00a4\u00d1\u008e\u0031""
    // * keytool -genkey -v -keystore native.jks -keyalg RSA -keysize 2048 -validity 10000
    //     -alias test
    //   generates a keystore and key which decrypt only with
    //   ""\u0061\u0062\u00a1\u00e4\u044e\u0031""

    assertNotClosed();
    if (spec.startsWith(""pass:"")) {
      char[] pwd = spec.substring(""pass:"".length()).toCharArray();
      return getPasswords(pwd);
    } else if (SPEC_STDIN.equals(spec)) {
      Console console = System.console();
      if (console != null) {
        // Reading from console
        char[] pwd = console.readPassword(description + "": "");
        if (pwd == null) {
          throw new IOException(""Failed to read "" + description + "": console closed"");
        }
        return getPasswords(pwd);
      } else {
        // Console not available -- reading from redirected input
        System.out.println(description + "": "");
        byte[] encodedPwd = readEncodedPassword(System.in);
        if (encodedPwd.length == 0) {
          throw new IOException(""Failed to read "" + description + "": standard input closed"");
        }
        // By default, textual input obtained via standard input is supposed to be decoded
        // using the in JVM default character encoding but we also try the console's
        // encoding just in case.
        return getPasswords(encodedPwd, Charset.defaultCharset(), CONSOLE_CHARSET);
      }
    } else if (spec.startsWith(""file:"")) {
      String name = spec.substring(""file:"".length());
      File file = new File(name).getCanonicalFile();
      InputStream in = mFileInputStreams.get(file);
      if (in == null) {
        in = new FileInputStream(file);
        mFileInputStreams.put(file, in);
      }
      byte[] encodedPwd = readEncodedPassword(in);
      if (encodedPwd.length == 0) {
        throw new IOException(""Failed to read "" + description + "" : end of file reached in "" + file);
      }
      // By default, textual input from files is supposed to be treated as encoded using JVM's
      // default character encoding.
      return getPasswords(encodedPwd, Charset.defaultCharset());
    } else if (spec.startsWith(""env:"")) {
      String name = spec.substring(""env:"".length());
      String value = System.getenv(name);
      if (value == null) {
        throw new IOException(""Failed to read "" + description + "": environment variable "" + value + "" not specified"");
      }
      return getPasswords(value.toCharArray());
    } else {
      throw new IOException(""Unsupported password spec for "" + description + "": "" + spec);
    }
  }","Returns the passwords described by the provided spec. The reason there may be more than one password is compatibility with {@code keytool} and {@code jarsigner} which in certain cases use the form of passwords encoded using the console's character encoding. Supported specs: stdin -- read password as a line from console, if available, or standard input if console is not available pass:password -- password specified inside the spec, starting after {@code pass:} file:path -- read password as a line from the specified file env:name -- password is in the specified environment variable When the same file (including standard input) is used for providing multiple passwords, the passwords are read from the file one line at a time"
"613","Field","spec","None","None"
"614","Field","description","None","None"
"615","Field","pwd","None","None"
"616","Field","console","None","None"
"617","Field","pwd","None","None"
"618","Field","encodedPwd","None","None"
"619","Field","name","None","None"
"620","Field","file","None","None"
"621","Field","in","None","None"
"622","Field","encodedPwd","None","None"
"623","Field","name","None","None"
"624","Field","value","None","None"
"625","Method","assertNotClosed","private void assertNotClosed() {
    if (mClosed) {
      throw new IllegalStateException(""Closed"");
    }
  }","None"
"626","Method","close","public void close() {
    for (InputStream in : mFileInputStreams.values()) {
      try {
        in.close();
      } catch (IOException ignored) {
      }
    }
    mFileInputStreams.clear();
    mClosed = true;
  }","None"
"627","Package","com.mindprod.ledatastream","com.mindprod.ledatastream","None"
"628","Class","LEDataInputStream","LEDataInputStream","Little-Endian version of DataInputStream. Very similar to DataInputStream except it reads little-endian instead of big-endian binary data. We can't extend DataInputStream directly since it has only final methods, though DataInputStream itself is not final. This forces us implement LEDataInputStream with a DataInputStream object, and use wrapper methods"
"629","Field","EMBEDDED_COPYRIGHT","None","undisplayed copyright notice"
"630","Field","dis","None","to get at the big-Endian methods of a basic DataInputStream"
"631","Field","is","None","to get at the a basic readBytes method"
"632","Field","work","None","work array for buffering input"
"633","Field","in","None","None"
"634","Field","in","None","None"
"635","Field","ba","None","None"
"636","Field","off","None","None"
"637","Field","len","None","None"
"638","Field","ba","None","None"
"639","Field","ba","None","None"
"640","Field","off","None","None"
"641","Field","len","None","None"
"642","Field","n","None","None"
"643","Method","readUTF","public static String readUTF(DataInput in) throws IOException {
    return DataInputStream.readUTF(in);
  }","Note. This is a STATIC method!"
"644","Field","in","None","None"
"645","Method","close","public final void close() throws IOException {
    dis.close();
  }","close"
"646","Method","read","public final int read(byte ba[], int off, int len) throws IOException {
    // For efficiency, we avoid one layer of wrapper
    return is.read(ba, off, len);
  }","Read bytes. Watch out, read may return fewer bytes than requested"
"647","Field","ba","None","None"
"648","Field","off","None","None"
"649","Field","len","None","None"
"650","Method","readBoolean","public final boolean readBoolean() throws IOException {
    return dis.readBoolean();
  }","read only a one-byte boolean"
"651","Method","readByte","public final byte readByte() throws IOException {
    return dis.readByte();
  }","read byte"
"652","Method","readChar","public final char readChar() throws IOException {
    dis.readFully(work, 0, 2);
    return (char) ((work[1] & 0xff) << 8 | (work[0] & 0xff));
  }","Read on char. like DataInputStream.readChar except little endian"
"653","Method","readDouble","public final double readDouble() throws IOException {
    return Double.longBitsToDouble(readLong());
  }","Read a double. like DataInputStream.readDouble except little endian"
"654","Method","readFloat","public final float readFloat() throws IOException {
    return Float.intBitsToFloat(readInt());
  }","Read one float. Like DataInputStream.readFloat except little endian"
"655","Method","readFully","public final void readFully(byte ba[]) throws IOException {
    dis.readFully(ba, 0, ba.length);
  }","Read bytes until the array is filled"
"656","Field","ba","None","None"
"657","Method","readFully","public final void readFully(byte ba[], int off, int len) throws IOException {
    dis.readFully(ba, off, len);
  }","Read bytes until the count is satisfied"
"658","Field","ba","None","None"
"659","Field","off","None","None"
"660","Field","len","None","None"
"661","Method","readInt","public final int readInt() throws IOException {
    dis.readFully(work, 0, 4);
    return (work[3]) << 24 | (work[2] & 0xff) << 16 | (work[1] & 0xff) << 8 | (work[0] & 0xff);
  }","Read an int, 32-bits. Like DataInputStream.readInt except little endian"
"662","Method","readLine","public final String readLine() throws IOException {
    return dis.readLine();
  }","Read a line"
"663","Method","readLong","public final long readLong() throws IOException {
    dis.readFully(work, 0, 8);
    return (long) (work[7]) << 56
           |
        /* long cast needed or shift done modulo 32 */
           (long) (work[6] & 0xff) << 48
           | (long) (work[5] & 0xff) << 40
           | (long) (work[4] & 0xff) << 32
           | (long) (work[3] & 0xff) << 24
           | (long) (work[2] & 0xff) << 16
           | (long) (work[1] & 0xff) << 8
           | work[0] & 0xff;
  }","read a long, 64-bits. Like DataInputStream.readLong except little endian"
"664","Method","readShort","public final short readShort() throws IOException {
    dis.readFully(work, 0, 2);
    return (short) ((work[1] & 0xff) << 8 | (work[0] & 0xff));
  }","Read short, 16-bits. Like DataInputStream.readShort except little endian"
"665","Method","readUTF","public final String readUTF() throws IOException {
    return dis.readUTF();
  }","Read UTF counted string"
"666","Method","readUnsignedByte","public final int readUnsignedByte() throws IOException {
    return dis.readUnsignedByte();
  }","Read an unsigned byte. Note: returns an int, even though says Byte (non-Javadoc)"
"667","Method","readUnsignedShort","public final int readUnsignedShort() throws IOException {
    dis.readFully(work, 0, 2);
    return ((work[1] & 0xff) << 8 | (work[0] & 0xff));
  }","Read an unsigned short, 16 bits. Like DataInputStream.readUnsignedShort except little endian. Note, returns int even though it reads a short"
"668","Method","skipBytes","public final int skipBytes(int n) throws IOException {
    return dis.skipBytes(n);
  }","Skip over bytes in the stream. See the general contract of the <code>skipBytes< code> method of <code>DataInput< code>. Bytes for this operation are read from the contained input stream"
"669","Field","n","None","None"
"670","Class","LEDataOutputStream","LEDataOutputStream","None"
"671","Field","out","None","None"
"672","Class","LittleEndianDataOutputStream","LittleEndianDataOutputStream","An implementation of {@link DataOutput} that uses little-endian byte ordering for writing {@code char}, {@code short}, {@code int}, {@code float}, {@code double}, and {@code long} values. <b>Note:< b> This class intentionally violates the specification of its supertype {@code DataOutput}, which explicitly requires big-endian byte order"
"673","Field","out","None","None"
"674","Field","value","None","None"
"675","Field","result","None","None"
"676","Field","b","None","None"
"677","Field","off","None","None"
"678","Field","len","None","None"
"679","Field","v","None","None"
"680","Field","v","None","None"
"681","Field","s","None","None"
"682","Field","v","None","None"
"683","Field","s","None","None"
"684","Field","v","None","None"
"685","Field","v","None","None"
"686","Field","v","None","None"
"687","Field","v","None","None"
"688","Field","bytes","None","None"
"689","Field","v","None","None"
"690","Field","str","None","None"
"691","Method","toByteArray","public static byte[] toByteArray(long value) {
    // Note that this code needs to stay compatible with GWT, which has known
    // bugs when narrowing byte casts of long values occur.
    byte[] result = new byte[8];
    for (int i = 7; i >= 0; i--) {
      result[i] = (byte) (value & 0xffL);
      value >>= 8;
    }
    return result;
  }","Returns a big-endian representation of {@code value} in an 8-element byte array; equivalent to {@code ByteBuffer.allocate(8).putLong(value).array()}. For example, the input value {@code 0x1213141516171819L} would yield the byte array {@code {0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19}}"
"692","Field","value","None","None"
"693","Field","result","None","None"
"694","Method","write","public void write(byte[] b, int off, int len) throws IOException {
    // Override slow FilterOutputStream impl
    out.write(b, off, len);
  }","None"
"695","Field","b","None","None"
"696","Field","off","None","None"
"697","Field","len","None","None"
"698","Method","writeBoolean","public void writeBoolean(boolean v) throws IOException {
    ((DataOutputStream) out).writeBoolean(v);
  }","None"
"699","Field","v","None","None"
"700","Method","writeByte","public void writeByte(int v) throws IOException {
    ((DataOutputStream) out).writeByte(v);
  }","None"
"701","Field","v","None","None"
"702","Method","writeBytes","public void writeBytes(String s) throws IOException {
    ((DataOutputStream) out).writeBytes(s);
  }","None"
"703","Field","s","None","None"
"704","Method","writeChar","public void writeChar(int v) throws IOException {
    writeShort(v);
  }","Writes a char as specified by {@link DataOutputStream#writeChar(int)}, except using little-endian byte order"
"705","Field","v","None","None"
"706","Method","writeChars","public void writeChars(String s) throws IOException {
    for (int i = 0; i < s.length(); i++) {
      writeChar(s.charAt(i));
    }
  }","Writes a {@code String} as specified by {@link DataOutputStream#writeChars(String)}, except each character is written using little-endian byte order"
"707","Field","s","None","None"
"708","Method","writeDouble","public void writeDouble(double v) throws IOException {
    writeLong(Double.doubleToLongBits(v));
  }","Writes a {@code double} as specified by {@link DataOutputStream#writeDouble(double)}, except using little-endian byte order"
"709","Field","v","None","None"
"710","Method","writeFloat","public void writeFloat(float v) throws IOException {
    writeInt(Float.floatToIntBits(v));
  }","Writes a {@code float} as specified by {@link DataOutputStream#writeFloat(float)}, except using little-endian byte order"
"711","Field","v","None","None"
"712","Method","writeInt","public void writeInt(int v) throws IOException {
    out.write(0xFF & v);
    out.write(0xFF & (v >> 8));
    out.write(0xFF & (v >> 16));
    out.write(0xFF & (v >> 24));
  }","Writes an {@code int} as specified by {@link DataOutputStream#writeInt(int)}, except using little-endian byte order"
"713","Field","v","None","None"
"714","Method","writeLong","public void writeLong(long v) throws IOException {
    byte[] bytes = toByteArray(Long.reverseBytes(v));
    write(bytes, 0, bytes.length);
  }","Writes a {@code long} as specified by {@link DataOutputStream#writeLong(long)}, except using little-endian byte order"
"715","Field","v","None","None"
"716","Field","bytes","None","None"
"717","Method","writeShort","public void writeShort(int v) throws IOException {
    out.write(0xFF & v);
    out.write(0xFF & (v >> 8));
  }","Writes a {@code short} as specified by {@link DataOutputStream#writeShort(int)}, except using little-endian byte order"
"718","Field","v","None","None"
"719","Method","writeUTF","public void writeUTF(String str) throws IOException {
    ((DataOutputStream) out).writeUTF(str);
  }","None"
"720","Field","str","None","None"
"721","Package","com.tencent.mm.util","com.tencent.mm.util","None"
"722","Class","DataOutputDelegate","DataOutputDelegate","None"
"723","Field","mDelegate","None","None"
"724","Field","delegate","None","None"
"725","Field","b","None","None"
"726","Field","b","None","None"
"727","Field","b","None","None"
"728","Field","off","None","None"
"729","Field","len","None","None"
"730","Field","v","None","None"
"731","Field","v","None","None"
"732","Field","v","None","None"
"733","Field","v","None","None"
"734","Field","v","None","None"
"735","Field","v","None","None"
"736","Field","v","None","None"
"737","Field","v","None","None"
"738","Field","s","None","None"
"739","Field","s","None","None"
"740","Field","s","None","None"
"741","Method","write","public void write(int b) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.write(b);
  }","None"
"742","Field","b","None","None"
"743","Method","write","public void write(byte[] b) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.write(b);
  }","None"
"744","Field","b","None","None"
"745","Method","write","public void write(byte[] b, int off, int len) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.write(b, off, len);
  }","None"
"746","Field","b","None","None"
"747","Field","off","None","None"
"748","Field","len","None","None"
"749","Method","writeBoolean","public void writeBoolean(boolean v) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeBoolean(v);
  }","None"
"750","Field","v","None","None"
"751","Method","writeByte","public void writeByte(int v) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeByte(v);
  }","None"
"752","Field","v","None","None"
"753","Method","writeShort","public void writeShort(int v) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeShort(v);
  }","None"
"754","Field","v","None","None"
"755","Method","writeChar","public void writeChar(int v) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeChar(v);
  }","None"
"756","Field","v","None","None"
"757","Method","writeInt","public void writeInt(int v) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeInt(v);
  }","None"
"758","Field","v","None","None"
"759","Method","writeLong","public void writeLong(long v) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeLong(v);
  }","None"
"760","Field","v","None","None"
"761","Method","writeFloat","public void writeFloat(float v) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeFloat(v);
  }","None"
"762","Field","v","None","None"
"763","Method","writeDouble","public void writeDouble(double v) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeDouble(v);
  }","None"
"764","Field","v","None","None"
"765","Method","writeBytes","public void writeBytes(String s) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeBytes(s);
  }","None"
"766","Field","s","None","None"
"767","Method","writeChars","public void writeChars(String s) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeChars(s);
  }","None"
"768","Field","s","None","None"
"769","Method","writeUTF","public void writeUTF(String s) throws IOException {
    // TODO Auto-generated method stub
    this.mDelegate.writeUTF(s);
  }","None"
"770","Field","s","None","None"
"771","Class","TypedValue","TypedValue","Container for a dynamically typed data value. Primarily used with"
"772","Field","UNZIP_FILE_PATH","None","None"
"773","Field","COMMAND_7ZIP","None","None"
"774","Field","COMMAND_ZIPALIGIN","None","None"
"775","Field","OUT_7ZIP_FILE_PATH","None","None"
"776","Field","STORED_FILE_PATH","None","7zip，"
"777","Field","RES_FILE_PATH","None","None"
"778","Field","RES_MAPPING_FILE","None","None"
"779","Field","MERGE_DUPLICATED_RES_MAPPING_FILE","None","None"
"780","Field","ZIP_STORED","None","None"
"781","Field","ZIP_DEFLATED","None","None"
"782","Field","JDK_6","None","None"
"783","Field","TXT_FILE","None","None"
"784","Field","XML_FILE","None","None"
"785","Field","CONFIG_FILE","None","None"
"786","Field","TYPE_NULL","None","The value contains no data"
"787","Field","TYPE_STRING","None","None"
"788","Class","ExtDataOutput","ExtDataOutput","None"
"789","Field","delegate","None","None"
"790","Field","array","None","None"
"791","Field","length","None","None"
"792","Field","in","None","None"
"793","Field","length","None","None"
"794","Field","data","None","None"
"795","Field","value","None","None"
"796","Field","expected","None","None"
"797","Field","reader","None","None"
"798","Field","expected","None","None"
"799","Field","possible","None","None"
"800","Field","value","None","None"
"801","Field","value","None","None"
"802","Field","expected","None","None"
"803","Field","value","None","None"
"804","Field","expected","None","None"
"805","Method","writeIntArray","public void writeIntArray(int[] array) throws IOException {
    int length = array.length;
    for (int i = 0; i < length; i++) {
      writeInt(array[i]);
    }
  }","None"
"806","Field","array","None","None"
"807","Field","length","None","None"
"808","Method","writeBytes","public void writeBytes(ExtDataInput in, int length) throws IOException {
    byte[] data = new byte[length];
    in.readFully(data);
    write(data);
  }","None"
"809","Field","in","None","None"
"810","Field","length","None","None"
"811","Field","data","None","None"
"812","Method","writeCheckInt","public void writeCheckInt(int value, int expected) throws IOException {
    writeInt(value);
    if (value != expected) {
      throw new IOException(String.format(""Expected: 0x%08x, got: 0x%08x"", expected, value));
    }
  }","None"
"813","Field","value","None","None"
"814","Field","expected","None","None"
"815","Method","writeCheckChunkTypeInt","public void writeCheckChunkTypeInt(ExtDataInput reader, int expected, int possible) throws IOException {
    int value = reader.readInt();
    writeInt(value);
    if (value == possible) {
      writeCheckChunkTypeInt(reader, expected, -1);
    } else if (value != expected) {
      throw new IOException(String.format(""Expected: 0x%08x, got: 0x%08x"", expected, value));
    }
  }","None"
"816","Field","reader","None","None"
"817","Field","expected","None","None"
"818","Field","possible","None","None"
"819","Field","value","None","None"
"820","Method","writeCheckShort","public void writeCheckShort(short value, short expected) throws IOException {
    writeShort(value);
    if (value != expected) {
      throw new IOException(String.format(""Expected: 0x%08x, got: 0x%08x"", expected, value));
    }
  }","None"
"821","Field","value","None","None"
"822","Field","expected","None","None"
"823","Method","writeCheckByte","public void writeCheckByte(byte value, byte expected) throws IOException {
    writeByte(value);
    if (value != expected) {
      throw new IOException(String.format(""Expected: 0x%08x, got: 0x%08x"", expected, value));
    }
  }","None"
"824","Field","value","None","None"
"825","Field","expected","None","None"
"826","Class","FileOperation","FileOperation","None"
"827","Field","BUFFER","None","None"
"828","Field","filePath","None","None"
"829","Field","file","None","None"
"830","Field","filePath","None","None"
"831","Field","file","None","None"
"832","Field","f","None","None"
"833","Field","size","None","None"
"834","Field","flist","None","None"
"835","Field","f","None","None"
"836","Field","size","None","None"
"837","Field","fis","None","None"
"838","Field","file","None","None"
"839","Field","files","None","None"
"840","Field","source","None","None"
"841","Field","dest","None","None"
"842","Field","is","None","None"
"843","Field","os","None","None"
"844","Field","parent","None","None"
"845","Field","buffer","None","None"
"846","Field","length","None","None"
"847","Field","dir","None","None"
"848","Field","dirObj","None","None"
"849","Field","dir","None","None"
"850","Field","file","None","None"
"851","Field","fileName","None","None"
"852","Field","filePath","None","None"
"853","Field","zipFile","None","None"
"854","Field","emu","None","None"
"855","Field","compress","None","None"
"856","Field","entry","None","None"
"857","Field","bis","None","None"
"858","Field","file","None","None"
"859","Field","parent","None","None"
"860","Field","compatibaleresult","None","None"
"861","Field","fos","None","None"
"862","Field","bos","None","None"
"863","Field","buf","None","None"
"864","Field","len","None","None"
"865","Field","resFileList","None","None"
"866","Field","baseFolder","None","None"
"867","Field","zipFile","None","None"
"868","Field","compressData","None","None"
"869","Field","zipOut","None","None"
"870","Field","relativePath","None","None"
"871","Field","resFile","None","None"
"872","Field","zipout","None","None"
"873","Field","rootpath","None","None"
"874","Field","compressData","None","None"
"875","Field","fileList","None","None"
"876","Field","fileContents","None","None"
"877","Field","compressMethod","None","None"
"878","Field","entry","None","None"
"879","Field","checksumCalculator","None","None"
"880","Field","file","None","None"
"881","Field","output","None","None"
"882","Field","bufferSize","None","None"
"883","Field","in","None","None"
"884","Field","bIn","None","None"
"885","Field","length","None","None"
"886","Field","buffer","None","None"
"887","Field","bufferCopy","None","None"
"888","Method","fileExists","public static boolean fileExists(String filePath) {
    if (filePath == null) {
      return false;
    }

    File file = new File(filePath);
    if (file.exists()) return true;
    return false;
  }","None"
"889","Field","filePath","None","None"
"890","Field","file","None","None"
"891","Method","deleteFile","public static boolean deleteFile(String filePath) {
    if (filePath == null) {
      return true;
    }

    File file = new File(filePath);
    if (file.exists()) {
      return file.delete();
    }
    return true;
  }","None"
"892","Field","filePath","None","None"
"893","Field","file","None","None"
"894","Method","getlist","public static long getlist(File f) {
    if (f == null || (!f.exists())) {
      return 0;
    }
    if (!f.isDirectory()) {
      return 1;
    }
    long size;
    File flist[] = f.listFiles();
    size = flist.length;
    for (int i = 0; i < flist.length; i++) {
      if (flist[i].isDirectory()) {
        size = size + getlist(flist[i]);
        size--;
      }
    }
    return size;
  }","None"
"895","Field","f","None","None"
"896","Field","size","None","None"
"897","Field","flist","None","None"
"898","Method","getFileSizes","public static long getFileSizes(File f) {
    long size = 0;
    if (f.exists() && f.isFile()) {
      FileInputStream fis = null;
      try {
        fis = new FileInputStream(f);
        size = fis.available();
      } catch (IOException e) {
        e.printStackTrace();
      } finally {
        try {
          if (fis != null) {
            fis.close();
          }
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
    }
    return size;
  }","None"
"899","Field","f","None","None"
"900","Field","size","None","None"
"901","Field","fis","None","None"
"902","Method","deleteDir","public static boolean deleteDir(File file) {
    if (file == null || (!file.exists())) {
      return false;
    }
    if (file.isFile()) {
      file.delete();
    } else if (file.isDirectory()) {
      File files[] = file.listFiles();
      for (int i = 0; i < files.length; i++) {
        deleteDir(files[i]);
      }
    }
    file.delete();
    return true;
  }","None"
"903","Field","file","None","None"
"904","Field","files","None","None"
"905","Method","copyFileUsingStream","public static void copyFileUsingStream(File source, File dest) throws IOException {
    FileInputStream is = null;
    FileOutputStream os = null;
    File parent = dest.getParentFile();
    if (parent != null && (!parent.exists())) {
      parent.mkdirs();
    }
    try {
      is = new FileInputStream(source);
      os = new FileOutputStream(dest, false);

      byte[] buffer = new byte[BUFFER];
      int length;
      while ((length = is.read(buffer)) > 0) {
        os.write(buffer, 0, length);
      }
    } finally {
      if (is != null) {
        is.close();
      }
      if (os != null) {
        os.close();
      }
    }
  }","None"
"906","Field","source","None","None"
"907","Field","dest","None","None"
"908","Field","is","None","None"
"909","Field","os","None","None"
"910","Field","parent","None","None"
"911","Field","buffer","None","None"
"912","Field","length","None","None"
"913","Method","checkDirectory","public static boolean checkDirectory(String dir) {
    File dirObj = new File(dir);
    deleteDir(dirObj);

    if (!dirObj.exists()) {
      dirObj.mkdirs();
    }
    return true;
  }","None"
"914","Field","dir","None","None"
"915","Field","dirObj","None","None"
"916","Method","checkFile","public static File checkFile(String dir) {
    deleteFile(dir);
    File file = new File(dir);
    try {
      file.createNewFile();
    } catch (IOException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return file;
  }","None"
"917","Field","dir","None","None"
"918","Field","file","None","None"
"919","Method","unZipAPk","public static HashMap<String, Integer> unZipAPk(String fileName, String filePath) throws IOException {
    checkDirectory(filePath);
    ZipFile zipFile = new ZipFile(fileName);
    Enumeration emu = zipFile.entries();
    HashMap<String, Integer> compress = new HashMap<>();
    try {
      while (emu.hasMoreElements()) {
        ZipEntry entry = (ZipEntry) emu.nextElement();
        if (entry.isDirectory()) {
          new File(filePath, entry.getName()).mkdirs();
          continue;
        }
        BufferedInputStream bis = new BufferedInputStream(zipFile.getInputStream(entry));

        File file = new File(filePath + File.separator + entry.getName());

        File parent = file.getParentFile();
        if (parent != null && (!parent.exists())) {
          parent.mkdirs();
        }
        //要用linux的斜杠
        String compatibaleresult = entry.getName();
        if (compatibaleresult.contains(""\\"")) {
          compatibaleresult = compatibaleresult.replace(""\\"", ""/"");
        }
        compress.put(compatibaleresult, entry.getMethod());
        FileOutputStream fos = new FileOutputStream(file);
        BufferedOutputStream bos = new BufferedOutputStream(fos, BUFFER);

        byte[] buf = new byte[BUFFER];
        int len;
        while ((len = bis.read(buf, 0, BUFFER)) != -1) {
          fos.write(buf, 0, len);
        }
        bos.flush();
        bos.close();
        bis.close();
      }
    } finally {
      zipFile.close();
    }
    return compress;
  }","None"
"920","Field","fileName","None","None"
"921","Field","filePath","None","None"
"922","Field","zipFile","None","None"
"923","Field","emu","None","None"
"924","Field","compress","None","None"
"925","Field","entry","None","None"
"926","Field","bis","None","None"
"927","Field","file","None","None"
"928","Field","parent","None","None"
"929","Field","compatibaleresult","None","None"
"930","Field","fos","None","None"
"931","Field","bos","None","None"
"932","Field","buf","None","None"
"933","Field","len","None","None"
"934","Method","zipFiles","public static void zipFiles(
      Collection<File> resFileList, File baseFolder, File zipFile, HashMap<String, Integer> compressData)
      throws IOException {
    ZipOutputStream zipOut = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(zipFile), BUFFER));
    for (File resFile : resFileList) {
      if (resFile.exists()) {
        if (resFile.getAbsolutePath().contains(baseFolder.getAbsolutePath())) {
          String relativePath = baseFolder.toURI().relativize(resFile.getParentFile().toURI()).getPath();
          // remove slash at end of relativePath
          if (relativePath.length() > 1) {
            relativePath = relativePath.substring(0, relativePath.length() - 1);
          } else {
            relativePath = """";
          }
          zipFile(resFile, zipOut, relativePath, compressData);
        } else {
          zipFile(resFile, zipOut, """", compressData);
        }
      }
    }
    zipOut.close();
  }","zip list of file"
"935","Field","resFileList","None","None"
"936","Field","baseFolder","None","None"
"937","Field","zipFile","None","None"
"938","Field","compressData","None","None"
"939","Field","zipOut","None","None"
"940","Field","relativePath","None","None"
"941","Method","zipFile","private static void zipFile(
      File resFile, ZipOutputStream zipout, String rootpath, HashMap<String, Integer> compressData) throws IOException {
    rootpath = rootpath + (rootpath.trim().length() == 0 ? """" : File.separator) + resFile.getName();
    if (resFile.isDirectory()) {
      File[] fileList = resFile.listFiles();
      for (File file : fileList) {
        zipFile(file, zipout, rootpath, compressData);
      }
    } else {
      final byte[] fileContents = readContents(resFile);
      //这里需要强转成linux格式，果然坑！！
      if (rootpath.contains(""\\"")) {
        rootpath = rootpath.replace(""\\"", ""/"");
      }
      if (!compressData.containsKey(rootpath)) {
        System.err.printf(String.format(""do not have the compress data path =%s in resource.asrc\n"", rootpath));
        //throw new IOException(String.format(""do not have the compress data path=%s"", rootpath));
        return;
      }
      int compressMethod = compressData.get(rootpath);
      ZipEntry entry = new ZipEntry(rootpath);

      if (compressMethod == ZipEntry.DEFLATED) {
        entry.setMethod(ZipEntry.DEFLATED);
      } else {
        entry.setMethod(ZipEntry.STORED);
        entry.setSize(fileContents.length);
        final CRC32 checksumCalculator = new CRC32();
        checksumCalculator.update(fileContents);
        entry.setCrc(checksumCalculator.getValue());
      }
      zipout.putNextEntry(entry);
      zipout.write(fileContents);
      zipout.flush();
      zipout.closeEntry();
    }
  }","None"
"942","Field","resFile","None","None"
"943","Field","zipout","None","None"
"944","Field","rootpath","None","None"
"945","Field","compressData","None","None"
"946","Field","fileList","None","None"
"947","Field","fileContents","None","None"
"948","Field","compressMethod","None","None"
"949","Field","entry","None","None"
"950","Field","checksumCalculator","None","None"
"951","Method","readContents","private static byte[] readContents(final File file) throws IOException {
    final ByteArrayOutputStream output = new ByteArrayOutputStream();
    final int bufferSize = 4096;
    try {
      final FileInputStream in = new FileInputStream(file);
      final BufferedInputStream bIn = new BufferedInputStream(in);
      int length;
      byte[] buffer = new byte[bufferSize];
      byte[] bufferCopy;
      while ((length = bIn.read(buffer, 0, bufferSize)) != -1) {
        bufferCopy = new byte[length];
        System.arraycopy(buffer, 0, bufferCopy, 0, length);
        output.write(bufferCopy);
      }
      bIn.close();
    } finally {
      output.close();
    }
    return output.toByteArray();
  }","None"
"952","Field","file","None","None"
"953","Field","output","None","None"
"954","Field","bufferSize","None","None"
"955","Field","in","None","None"
"956","Field","bIn","None","None"
"957","Field","length","None","None"
"958","Field","buffer","None","None"
"959","Field","bufferCopy","None","None"
"960","Class","Utils","Utils","None"
"961","Field","str","None","None"
"962","Field","str","None","None"
"963","Field","iterator","None","None"
"964","Field","iterator","None","None"
"965","Field","input","None","None"
"966","Field","searchList","None","None"
"967","Field","replacementList","None","None"
"968","Field","str","None","None"
"969","Field","patterns","None","None"
"970","Field","isMatch","None","None"
"971","Field","dir","None","None"
"972","Field","cmd","None","None"
"973","Field","output","None","None"
"974","Field","process","None","None"
"975","Field","argv","None","None"
"976","Field","process","None","None"
"977","Field","output","None","None"
"978","Field","process","None","None"
"979","Field","ir","None","None"
"980","Field","input","None","None"
"981","Field","text","None","None"
"982","Field","searchList","None","None"
"983","Field","replacementList","None","None"
"984","Field","tracker","None","None"
"985","Field","buf","None","None"
"986","Field","start","None","None"
"987","Field","matchInfo","None","None"
"988","Field","textIndex","None","None"
"989","Field","pattern","None","None"
"990","Field","replacement","None","None"
"991","Field","text","None","None"
"992","Field","patternToReplacement","None","None"
"993","Field","pendingPatterns","None","None"
"994","Field","matchInfo","None","None"
"995","Field","text","None","None"
"996","Field","searchList","None","None"
"997","Field","replacementList","None","None"
"998","Field","pattern","None","None"
"999","Field","start","None","None"
"1000","Field","textIndex","None","None"
"1001","Field","nextPattern","None","None"
"1002","Field","matchIndex","None","None"
"1003","Field","pattern","None","None"
"1004","Field","replacement","None","None"
"1005","Field","textIndex","None","None"
"1006","Field","pattern","None","None"
"1007","Field","replacement","None","None"
"1008","Field","textIndex","None","None"
"1009","Method","isPresent","public static boolean isPresent(String str) {
    return str != null && str.length() > 0;
  }","None"
"1010","Field","str","None","None"
"1011","Method","isBlank","public static boolean isBlank(String str) {
    return !isPresent(str);
  }","None"
"1012","Field","str","None","None"
"1013","Method","isPresent","public static boolean isPresent(Iterator iterator) {
    return iterator != null && iterator.hasNext();
  }","None"
"1014","Field","iterator","None","None"
"1015","Method","isBlank","public static boolean isBlank(Iterator iterator) {
    return !isPresent(iterator);
  }","None"
"1016","Field","iterator","None","None"
"1017","Method","convertToPatternString","public static String convertToPatternString(String input) {
    // ?	Zero or one character
    // *	Zero or more of character
    // +	One or more of character
    final String[] searchList = new String[] { ""."", ""?"", ""*"", ""+"" };
    final String[] replacementList = new String[] { ""\\."", "".?"", "".*"", "".+"" };
    return replaceEach(input, searchList, replacementList);
  }","None"
"1018","Field","input","None","None"
"1019","Field","searchList","None","None"
"1020","Field","replacementList","None","None"
"1021","Method","match","public static boolean match(String str, HashSet<Pattern> patterns) {
    if (patterns == null) {
      return false;
    }
    for(Pattern p : patterns) {
      Boolean isMatch = p.matcher(str).matches();
      if (isMatch) return true;
    }
    return false;
  }","None"
"1022","Field","str","None","None"
"1023","Field","patterns","None","None"
"1024","Field","isMatch","None","None"
"1025","Method","cleanDir","public static void cleanDir(File dir) {
    if (dir.exists()) {
      FileOperation.deleteDir(dir);
      dir.mkdirs();
    }
  }","None"
"1026","Field","dir","None","None"
"1027","Method","runCmd","public static String runCmd(String... cmd) throws IOException, InterruptedException {
    String output;
    Process process = null;
    try {
      process = new ProcessBuilder(cmd).start();
      output = StringUtil.readInputStream(process.getInputStream());
      process.waitFor();
      if (process.exitValue() != 0) {
        System.err.println(String.format(""%s Failed! Please check your signature file.\n"", cmd[0]));
        throw new RuntimeException(StringUtil.readInputStream(process.getErrorStream()));
      }
    } finally {
      if (process != null) {
        process.destroy();
      }
    }
    return output;
  }","None"
"1028","Field","cmd","None","None"
"1029","Field","output","None","None"
"1030","Field","process","None","None"
"1031","Method","runExec","public static String runExec(String[] argv) throws IOException, InterruptedException {
    Process process = null;
    String output;
    try {
      process = Runtime.getRuntime().exec(argv);
      output = StringUtil.readInputStream(process.getInputStream());
      process.waitFor();
      if (process.exitValue() != 0) {
        System.err.println(String.format(""%s Failed! Please check your signature file.\n"", argv[0]));
        throw new RuntimeException(StringUtil.readInputStream(process.getErrorStream()));
      }
    } finally {
      if (process != null) {
        process.destroy();
      }
    }
    return output;
  }","None"
"1032","Field","argv","None","None"
"1033","Field","process","None","None"
"1034","Field","output","None","None"
"1035","Method","processOutputStreamInThread","private static void processOutputStreamInThread(Process process) throws IOException {
    InputStreamReader ir = new InputStreamReader(process.getInputStream());
    LineNumberReader input = new LineNumberReader(ir);
    //如果不读会有问题，被阻塞
    while (input.readLine() != null) {
    }
  }","None"
"1036","Field","process","None","None"
"1037","Field","ir","None","None"
"1038","Field","input","None","None"
"1039","Method","replaceEach","private static String replaceEach(String text, String[] searchList, String[] replacementList) {
    // TODO: throw new IllegalArgumentException() if any param doesn't make sense
    //validateParams(text, searchList, replacementList);

    SearchTracker tracker = new SearchTracker(text, searchList, replacementList);
    if (!tracker.hasNextMatch(0)) {
      return text;
    }

    StringBuilder buf = new StringBuilder(text.length() * 2);
    int start = 0;

    do {
      SearchTracker.MatchInfo matchInfo = tracker.matchInfo;
      int textIndex = matchInfo.textIndex;
      String pattern = matchInfo.pattern;
      String replacement = matchInfo.replacement;

      buf.append(text.substring(start, textIndex));
      buf.append(replacement);

      start = textIndex + pattern.length();
    } while (tracker.hasNextMatch(start));

    return buf.append(text.substring(start)).toString();
  }","None"
"1040","Field","text","None","None"
"1041","Field","searchList","None","None"
"1042","Field","replacementList","None","None"
"1043","Field","tracker","None","None"
"1044","Field","buf","None","None"
"1045","Field","start","None","None"
"1046","Field","matchInfo","None","None"
"1047","Field","textIndex","None","None"
"1048","Field","pattern","None","None"
"1049","Field","replacement","None","None"
"1050","Class","SearchTracker","SearchTracker","None"
"1051","Field","text","None","None"
"1052","Field","patternToReplacement","None","None"
"1053","Field","pendingPatterns","None","None"
"1054","Field","matchInfo","None","None"
"1055","Field","text","None","None"
"1056","Field","searchList","None","None"
"1057","Field","replacementList","None","None"
"1058","Field","pattern","None","None"
"1059","Field","start","None","None"
"1060","Field","textIndex","None","None"
"1061","Field","nextPattern","None","None"
"1062","Field","matchIndex","None","None"
"1063","Field","pattern","None","None"
"1064","Field","replacement","None","None"
"1065","Field","textIndex","None","None"
"1066","Field","pattern","None","None"
"1067","Field","replacement","None","None"
"1068","Field","textIndex","None","None"
"1069","Method","hasNextMatch","boolean hasNextMatch(int start) {
      int textIndex = -1;
      String nextPattern = null;

      for (String pattern : new ArrayList<>(pendingPatterns)) {
        int matchIndex = text.indexOf(pattern, start);
        if (matchIndex == -1) {
          pendingPatterns.remove(pattern);
        } else {
          if (textIndex == -1 || matchIndex < textIndex) {
            textIndex = matchIndex;
            nextPattern = pattern;
          }
        }
      }

      if (nextPattern != null) {
        matchInfo = new MatchInfo(nextPattern, patternToReplacement.get(nextPattern), textIndex);
        return true;
      }
      return false;
    }","None"
"1070","Field","start","None","None"
"1071","Field","textIndex","None","None"
"1072","Field","nextPattern","None","None"
"1073","Field","matchIndex","None","None"
"1074","Class","MatchInfo","MatchInfo","None"
"1075","Field","pattern","None","None"
"1076","Field","replacement","None","None"
"1077","Field","textIndex","None","None"
"1078","Field","pattern","None","None"
"1079","Field","replacement","None","None"
"1080","Field","textIndex","None","None"
"1081","Class","Md5Util","Md5Util","None"
"1082","Field","str","None","None"
"1083","Field","digest","None","None"
"1084","Field","file","None","None"
"1085","Field","digest","None","None"
"1086","Field","src","None","None"
"1087","Field","stringBuilder","None","None"
"1088","Field","v","None","None"
"1089","Field","hv","None","None"
"1090","Method","getMD5Str","public static String getMD5Str(String str) {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance(""MD5"");
            digest.update(str.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            return """";
        }
        return bytesToHexString(digest.digest());
    }","None"
"1091","Field","str","None","None"
"1092","Field","digest","None","None"
"1093","Method","getMD5Str","public static String getMD5Str(File file) {
        if (!file.isFile()) {
            return """";
        }
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance(""MD5"");
            digest.update(FileUtils.readFileToByteArray(file));
        } catch (Exception e) {
            return """";
        }
        return bytesToHexString(digest.digest());
    }","None"
"1094","Field","file","None","None"
"1095","Field","digest","None","None"
"1096","Method","bytesToHexString","public static String bytesToHexString(byte[] src) {
        if (src.length <= 0) {
            return """";
        }
        StringBuilder stringBuilder = new StringBuilder(src.length);
        for (byte b : src) {
            int v = b & 0xFF;
            String hv = Integer.toHexString(v);
            if (hv.length() < 2) {
                stringBuilder.append(0);
            }
            stringBuilder.append(hv);
        }
        return stringBuilder.toString();
    }","None"
"1097","Field","src","None","None"
"1098","Field","stringBuilder","None","None"
"1099","Field","v","None","None"
"1100","Field","hv","None","None"
"1101","Class","DataInputDelegate","DataInputDelegate","None"
"1102","Field","mDelegate","None","None"
"1103","Field","delegate","None","None"
"1104","Field","n","None","None"
"1105","Field","b","None","None"
"1106","Field","off","None","None"
"1107","Field","len","None","None"
"1108","Field","b","None","None"
"1109","Method","skipBytes","public int skipBytes(int n) throws IOException {
    return mDelegate.skipBytes(n);
  }","None"
"1110","Field","n","None","None"
"1111","Method","readUnsignedShort","public int readUnsignedShort() throws IOException {
    return mDelegate.readUnsignedShort();
  }","None"
"1112","Method","readUnsignedByte","public int readUnsignedByte() throws IOException {
    return mDelegate.readUnsignedByte();
  }","None"
"1113","Method","readUTF","public String readUTF() throws IOException {
    return mDelegate.readUTF();
  }","None"
"1114","Method","readShort","public short readShort() throws IOException {
    return mDelegate.readShort();
  }","None"
"1115","Method","readLong","public long readLong() throws IOException {
    return mDelegate.readLong();
  }","None"
"1116","Method","readLine","public String readLine() throws IOException {
    return mDelegate.readLine();
  }","None"
"1117","Method","readInt","public int readInt() throws IOException {
    return mDelegate.readInt();
  }","None"
"1118","Method","readFully","public void readFully(byte[] b, int off, int len) throws IOException {
    mDelegate.readFully(b, off, len);
  }","None"
"1119","Field","b","None","None"
"1120","Field","off","None","None"
"1121","Field","len","None","None"
"1122","Method","readFully","public void readFully(byte[] b) throws IOException {
    mDelegate.readFully(b);
  }","None"
"1123","Field","b","None","None"
"1124","Method","readFloat","public float readFloat() throws IOException {
    return mDelegate.readFloat();
  }","None"
"1125","Method","readDouble","public double readDouble() throws IOException {
    return mDelegate.readDouble();
  }","None"
"1126","Method","readChar","public char readChar() throws IOException {
    return mDelegate.readChar();
  }","None"
"1127","Method","readByte","public byte readByte() throws IOException {
    return mDelegate.readByte();
  }","None"
"1128","Method","readBoolean","public boolean readBoolean() throws IOException {
    return mDelegate.readBoolean();
  }","None"
"1129","Class","ExtDataInput","ExtDataInput","None"
"1130","Field","in","None","None"
"1131","Field","delegate","None","None"
"1132","Field","length","None","None"
"1133","Field","array","None","None"
"1134","Field","expected","None","None"
"1135","Field","got","None","None"
"1136","Field","expected","None","None"
"1137","Field","possible","None","None"
"1138","Field","got","None","None"
"1139","Field","expected","None","None"
"1140","Field","got","None","None"
"1141","Field","expected","None","None"
"1142","Field","got","None","None"
"1143","Field","length","None","None"
"1144","Field","fixed","None","None"
"1145","Field","string","None","None"
"1146","Field","ch","None","None"
"1147","Method","readIntArray","public int[] readIntArray(int length) throws IOException {
    int[] array = new int[length];
    for (int i = 0; i < length; i++) {
      array[i] = readInt();
    }
    return array;
  }","None"
"1148","Field","length","None","None"
"1149","Field","array","None","None"
"1150","Method","skipInt","public void skipInt() throws IOException {
    skipBytes(4);
  }","None"
"1151","Method","skipCheckInt","public void skipCheckInt(int expected) throws IOException {
    int got = readInt();
    if (got != expected) {
      throw new IOException(String.format(""Expected: 0x%08x, got: 0x%08x"", expected, got));
    }
  }","None"
"1152","Field","expected","None","None"
"1153","Field","got","None","None"
"1154","Method","skipCheckChunkTypeInt","public void skipCheckChunkTypeInt(int expected, int possible) throws IOException {
    int got = readInt();

    if (got == possible) {
      skipCheckChunkTypeInt(expected, -1);
    } else if (got != expected) {
      throw new IOException(String.format(""Expected: 0x%08x, got: 0x%08x"", expected, got));
    }
  }","None"
"1155","Field","expected","None","None"
"1156","Field","possible","None","None"
"1157","Field","got","None","None"
"1158","Method","skipCheckShort","public void skipCheckShort(short expected) throws IOException {
    short got = readShort();
    if (got != expected) {
      throw new IOException(String.format(""Expected: 0x%08x, got: 0x%08x"", expected, got));
    }
  }","None"
"1159","Field","expected","None","None"
"1160","Field","got","None","None"
"1161","Method","skipCheckByte","public void skipCheckByte(byte expected) throws IOException {
    byte got = readByte();
    if (got != expected) {
      throw new IOException(String.format(""Expected: 0x%08x, got: 0x%08x"", expected, got));
    }
  }","None"
"1162","Field","expected","None","None"
"1163","Field","got","None","None"
"1164","Method","readNullEndedString","public String readNullEndedString(int length, boolean fixed) throws IOException {
    StringBuilder string = new StringBuilder(16);
    while (length-- != 0) {
      short ch = readShort();
      if (ch == 0) {
        break;
      }
      string.append((char) ch);
    }
    if (fixed) {
      skipBytes(length * 2);
    }

    return string.toString();
  }","None"
"1165","Field","length","None","None"
"1166","Field","fixed","None","None"
"1167","Field","string","None","None"
"1168","Field","ch","None","None"
"1169","Package","com.tencent.mm.directory","com.tencent.mm.directory","None"
"1170","Class","DirectoryException","DirectoryException","None"
"1171","Field","serialVersionUID","None","None"
"1172","Field","detailMessage","None","None"
"1173","Field","throwable","None","None"
"1174","Field","detailMessage","None","None"
"1175","Field","throwable","None","None"
"1176","Interface","Directory","Directory","None"
"1177","Field","separator","None","None"
"1178","Field","recursive","None","None"
"1179","Field","recursive","None","None"
"1180","Field","path","None","None"
"1181","Field","path","None","None"
"1182","Field","path","None","None"
"1183","Field","path","None","None"
"1184","Field","path","None","None"
"1185","Field","path","None","None"
"1186","Field","path","None","None"
"1187","Method","getFiles","None","None"
"1188","Method","getFiles","None","None"
"1189","Field","recursive","None","None"
"1190","Method","getDirs","None","None"
"1191","Method","getDirs","None","None"
"1192","Field","recursive","None","None"
"1193","Method","containsFile","None","None"
"1194","Field","path","None","None"
"1195","Method","containsDir","None","None"
"1196","Field","path","None","None"
"1197","Method","getFileInput","None","None"
"1198","Field","path","None","None"
"1199","Method","getFileOutput","None","None"
"1200","Field","path","None","None"
"1201","Method","getDir","None","None"
"1202","Field","path","None","None"
"1203","Method","createDir","None","None"
"1204","Field","path","None","None"
"1205","Method","removeFile","public boolean removeFile(String path);","None"
"1206","Field","path","None","None"
"1207","Class","FileDirectory","FileDirectory","None"
"1208","Field","mDir","None","None"
"1209","Field","dir","None","None"
"1210","Field","dir","None","None"
"1211","Field","name","None","None"
"1212","Field","dir","None","None"
"1213","Field","name","None","None"
"1214","Field","name","None","None"
"1215","Field","name","None","None"
"1216","Field","name","None","None"
"1217","Field","files","None","None"
"1218","Field","file","None","None"
"1219","Method","createDirLocal","protected AbstractDirectory createDirLocal(String name) throws DirectoryException {
    File dir = new File(generatePath(name));
    dir.mkdir();
    return new FileDirectory(dir);
  }","None"
"1220","Field","name","None","None"
"1221","Field","dir","None","None"
"1222","Method","getFileInputLocal","protected InputStream getFileInputLocal(String name) throws DirectoryException {
    try {
      return new FileInputStream(generatePath(name));
    } catch (FileNotFoundException e) {
      throw new DirectoryException(e);
    }
  }","None"
"1223","Field","name","None","None"
"1224","Method","getFileOutputLocal","protected OutputStream getFileOutputLocal(String name) throws DirectoryException {
    try {
      return new FileOutputStream(generatePath(name));
    } catch (FileNotFoundException e) {
      throw new DirectoryException(e);
    }
  }","None"
"1225","Field","name","None","None"
"1226","Method","loadDirs","protected void loadDirs() {
    loadAll();
  }","None"
"1227","Method","loadFiles","protected void loadFiles() {
    loadAll();
  }","None"
"1228","Method","removeFileLocal","protected void removeFileLocal(String name) {
    new File(generatePath(name)).delete();
  }","None"
"1229","Field","name","None","None"
"1230","Method","generatePath","private String generatePath(String name) {
    return getDir().getPath() + separator + name;
  }","None"
"1231","Field","name","None","None"
"1232","Method","loadAll","private void loadAll() {
    mFiles = new LinkedHashSet<String>();
    mDirs = new LinkedHashMap<String, AbstractDirectory>();

    File[] files = getDir().listFiles();
    for (int i = 0; i < files.length; i++) {
      File file = files[i];
      if (file.isFile()) {
        mFiles.add(file.getName());
      } else {
        // IMPOSSIBLE_EXCEPTION
        try {
          mDirs.put(file.getName(), new FileDirectory(file));
        } catch (DirectoryException e) {
        }
      }
    }
  }","None"
"1233","Field","files","None","None"
"1234","Field","file","None","None"
"1235","Method","getDir","private File getDir() {
    return mDir;
  }","None"
"1236","Class","PathNotExist","PathNotExist","None"
"1237","Field","serialVersionUID","None","None"
"1238","Field","detailMessage","None","None"
"1239","Field","throwable","None","None"
"1240","Field","detailMessage","None","None"
"1241","Field","throwable","None","None"
"1242","Class","ZipRODirectory","ZipRODirectory","None"
"1243","Field","mZipFile","None","None"
"1244","Field","mPath","None","None"
"1245","Field","zipFileName","None","None"
"1246","Field","zipFile","None","None"
"1247","Field","zipFile","None","None"
"1248","Field","zipFileName","None","None"
"1249","Field","path","None","None"
"1250","Field","zipFile","None","None"
"1251","Field","path","None","None"
"1252","Field","zipFile","None","None"
"1253","Field","path","None","None"
"1254","Field","name","None","None"
"1255","Field","name","None","None"
"1256","Field","name","None","None"
"1257","Field","name","None","None"
"1258","Field","prefixLen","None","None"
"1259","Field","entries","None","None"
"1260","Field","entry","None","None"
"1261","Field","name","None","None"
"1262","Field","subname","None","None"
"1263","Field","pos","None","None"
"1264","Field","dir","None","None"
"1265","Method","createDirLocal","protected AbstractDirectory createDirLocal(String name) throws DirectoryException {
    throw new UnsupportedOperationException();
  }","None"
"1266","Field","name","None","None"
"1267","Method","getFileInputLocal","protected InputStream getFileInputLocal(String name) throws DirectoryException {
    try {
      return getZipFile().getInputStream(new ZipEntry(getPath() + name));
    } catch (IOException e) {
      throw new PathNotExist(name, e);
    }
  }","None"
"1268","Field","name","None","None"
"1269","Method","getFileOutputLocal","protected OutputStream getFileOutputLocal(String name) throws DirectoryException {
    throw new UnsupportedOperationException();
  }","None"
"1270","Field","name","None","None"
"1271","Method","loadDirs","protected void loadDirs() {
    loadAll();
  }","None"
"1272","Method","loadFiles","protected void loadFiles() {
    loadAll();
  }","None"
"1273","Method","removeFileLocal","protected void removeFileLocal(String name) {
    throw new UnsupportedOperationException();
  }","None"
"1274","Field","name","None","None"
"1275","Method","loadAll","private void loadAll() {
    mFiles = new LinkedHashSet<>();
    mDirs = new LinkedHashMap<>();

    int prefixLen = getPath().length();
    Enumeration<? extends ZipEntry> entries = getZipFile().entries();
    while (entries.hasMoreElements()) {
      ZipEntry entry = entries.nextElement();
      String name = entry.getName();

      if (name.equals(getPath()) || !name.startsWith(getPath())) {
        continue;
      }

      String subname = name.substring(prefixLen);
      int pos = subname.indexOf(separator);
      if (pos == -1) {
        if (!entry.isDirectory()) {
          mFiles.add(subname);
          continue;
        }
      } else {
        subname = subname.substring(0, pos);
      }

      if (!mDirs.containsKey(subname)) {
        AbstractDirectory dir = new ZipRODirectory(getZipFile(), getPath() + subname + separator);
        mDirs.put(subname, dir);
      }
    }
  }","None"
"1276","Field","prefixLen","None","None"
"1277","Field","entries","None","None"
"1278","Field","entry","None","None"
"1279","Field","name","None","None"
"1280","Field","subname","None","None"
"1281","Field","pos","None","None"
"1282","Field","dir","None","None"
"1283","Method","getPath","private String getPath() {
    return mPath;
  }","None"
"1284","Method","getZipFile","private ZipFile getZipFile() {
    return mZipFile;
  }","None"
"1285","Class","AbstractDirectory","AbstractDirectory","None"
"1286","Field","mFiles","None","None"
"1287","Field","mDirs","None","None"
"1288","Field","recursive","None","None"
"1289","Field","files","None","None"
"1290","Field","path","None","None"
"1291","Field","subpath","None","None"
"1292","Field","path","None","None"
"1293","Field","subpath","None","None"
"1294","Field","recursive","None","None"
"1295","Field","path","None","None"
"1296","Field","subpath","None","None"
"1297","Field","path","None","None"
"1298","Field","parsed","None","None"
"1299","Field","dir","None","None"
"1300","Field","path","None","None"
"1301","Field","subpath","None","None"
"1302","Field","path","None","None"
"1303","Field","parsed","None","None"
"1304","Field","dir","None","None"
"1305","Field","path","None","None"
"1306","Field","subpath","None","None"
"1307","Field","recursive","None","None"
"1308","Field","dirs","None","None"
"1309","Field","path","None","None"
"1310","Field","parsed","None","None"
"1311","Field","path","None","None"
"1312","Field","pos","None","None"
"1313","Field","name","None","None"
"1314","Field","name","None","None"
"1315","Field","name","None","None"
"1316","Field","name","None","None"
"1317","Field","dir","None","None"
"1318","Field","subpath","None","None"
"1319","Field","dir","None","None"
"1320","Field","subpath","None","None"
"1321","Field","dir","None","None"
"1322","Field","path","None","None"
"1323","Field","dir","None","None"
"1324","Field","path","None","None"
"1325","Method","getFiles","public Set<String> getFiles() {
    return getFiles(false);
  }","None"
"1326","Method","getFiles","public Set<String> getFiles(boolean recursive) {
    if (mFiles == null) {
      loadFiles();
    }
    if (!recursive) {
      return mFiles;
    }

    Set<String> files = new LinkedHashSet<String>(mFiles);
    for (Map.Entry<String, ? extends Directory> dir : getAbstractDirs().entrySet()) {
      for (String path : dir.getValue().getFiles(true)) {
        files.add(dir.getKey() + separator + path);
      }
    }
    return files;
  }","None"
"1327","Field","recursive","None","None"
"1328","Field","files","None","None"
"1329","Method","containsFile","public boolean containsFile(String path) {
    SubPath subpath;
    try {
      subpath = getSubPath(path);
    } catch (PathNotExist e) {
      return false;
    }

    if (subpath.dir != null) {
      return subpath.dir.containsFile(subpath.path);
    }
    return getFiles().contains(subpath.path);
  }","None"
"1330","Field","path","None","None"
"1331","Field","subpath","None","None"
"1332","Method","containsDir","public boolean containsDir(String path) {
    SubPath subpath;
    try {
      subpath = getSubPath(path);
    } catch (PathNotExist e) {
      return false;
    }

    if (subpath.dir != null) {
      return subpath.dir.containsDir(subpath.path);
    }
    return getAbstractDirs().containsKey(subpath.path);
  }","None"
"1333","Field","path","None","None"
"1334","Field","subpath","None","None"
"1335","Method","getDirs","public Map<String, Directory> getDirs() throws UnsupportedOperationException {
    return getDirs(false);
  }","None"
"1336","Method","getDirs","public Map<String, Directory> getDirs(boolean recursive) throws UnsupportedOperationException {
    return new LinkedHashMap<String, Directory>(getAbstractDirs(recursive));
  }","None"
"1337","Field","recursive","None","None"
"1338","Method","getFileInput","public InputStream getFileInput(String path) throws DirectoryException {
    SubPath subpath = getSubPath(path);
    if (subpath.dir != null) {
      return subpath.dir.getFileInput(subpath.path);
    }
    if (!getFiles().contains(subpath.path)) {
      throw new PathNotExist(path);
    }
    return getFileInputLocal(subpath.path);
  }","None"
"1339","Field","path","None","None"
"1340","Field","subpath","None","None"
"1341","Method","getFileOutput","public OutputStream getFileOutput(String path) throws DirectoryException {
    ParsedPath parsed = parsePath(path);
    if (parsed.dir == null) {
      getFiles().add(parsed.subpath);
      return getFileOutputLocal(parsed.subpath);
    }

    Directory dir;
    // IMPOSSIBLE_EXCEPTION
    try {
      dir = createDir(parsed.dir);
    } catch (PathAlreadyExists e) {
      dir = getAbstractDirs().get(parsed.dir);
    }
    return dir.getFileOutput(parsed.subpath);
  }","None"
"1342","Field","path","None","None"
"1343","Field","parsed","None","None"
"1344","Field","dir","None","None"
"1345","Method","getDir","public Directory getDir(String path) throws PathNotExist {
    SubPath subpath = getSubPath(path);
    if (subpath.dir != null) {
      return subpath.dir.getDir(subpath.path);
    }
    if (!getAbstractDirs().containsKey(subpath.path)) {
      throw new PathNotExist(path);
    }
    return getAbstractDirs().get(subpath.path);
  }","None"
"1346","Field","path","None","None"
"1347","Field","subpath","None","None"
"1348","Method","createDir","public Directory createDir(String path) throws DirectoryException {
    ParsedPath parsed = parsePath(path);
    AbstractDirectory dir;
    if (parsed.dir == null) {
      if (getAbstractDirs().containsKey(parsed.subpath)) {
        throw new PathAlreadyExists(path);
      }
      dir = createDirLocal(parsed.subpath);
      getAbstractDirs().put(parsed.subpath, dir);
      return dir;
    }

    if (getAbstractDirs().containsKey(parsed.dir)) {
      dir = getAbstractDirs().get(parsed.dir);
    } else {
      dir = createDirLocal(parsed.dir);
      getAbstractDirs().put(parsed.dir, dir);
    }
    return dir.createDir(parsed.subpath);
  }","None"
"1349","Field","path","None","None"
"1350","Field","parsed","None","None"
"1351","Field","dir","None","None"
"1352","Method","removeFile","public boolean removeFile(String path) {
    SubPath subpath;
    try {
      subpath = getSubPath(path);
    } catch (PathNotExist e) {
      return false;
    }

    if (subpath.dir != null) {
      return subpath.dir.removeFile(subpath.path);
    }
    if (!getFiles().contains(subpath.path)) {
      return false;
    }
    removeFileLocal(subpath.path);
    getFiles().remove(subpath.path);
    return true;
  }","None"
"1353","Field","path","None","None"
"1354","Field","subpath","None","None"
"1355","Method","getAbstractDirs","protected Map<String, AbstractDirectory> getAbstractDirs() {
    return getAbstractDirs(false);
  }","None"
"1356","Method","getAbstractDirs","protected Map<String, AbstractDirectory> getAbstractDirs(boolean recursive) {
    if (mDirs == null) {
      loadDirs();
    }
    if (!recursive) {
      return mDirs;
    }

    Map<String, AbstractDirectory> dirs = new LinkedHashMap<String, AbstractDirectory>(mDirs);
    for (Map.Entry<String, AbstractDirectory> dir : getAbstractDirs().entrySet()) {
      for (Map.Entry<String, AbstractDirectory> subdir : dir.getValue().getAbstractDirs(true).entrySet()) {
        dirs.put(dir.getKey() + separator + subdir.getKey(), subdir.getValue());
      }
    }
    return dirs;
  }","None"
"1357","Field","recursive","None","None"
"1358","Field","dirs","None","None"
"1359","Method","getSubPath","private SubPath getSubPath(String path) throws PathNotExist {
    ParsedPath parsed = parsePath(path);
    if (parsed.dir == null) {
      return new SubPath(null, parsed.subpath);
    }
    if (!getAbstractDirs().containsKey(parsed.dir)) {
      throw new PathNotExist(path);
    }
    return new SubPath(getAbstractDirs().get(parsed.dir), parsed.subpath);
  }","None"
"1360","Field","path","None","None"
"1361","Field","parsed","None","None"
"1362","Method","parsePath","private ParsedPath parsePath(String path) {
    int pos = path.indexOf(separator);
    if (pos == -1) {
      return new ParsedPath(null, path);
    }
    return new ParsedPath(path.substring(0, pos), path.substring(pos + 1));
  }","None"
"1363","Field","path","None","None"
"1364","Field","pos","None","None"
"1365","Method","loadFiles","None","None"
"1366","Method","loadDirs","None","None"
"1367","Method","getFileInputLocal","None","None"
"1368","Field","name","None","None"
"1369","Method","getFileOutputLocal","None","None"
"1370","Field","name","None","None"
"1371","Method","createDirLocal","None","None"
"1372","Field","name","None","None"
"1373","Method","removeFileLocal","None","None"
"1374","Field","name","None","None"
"1375","Class","ParsedPath","ParsedPath","None"
"1376","Field","dir","None","None"
"1377","Field","subpath","None","None"
"1378","Field","dir","None","None"
"1379","Field","subpath","None","None"
"1380","Class","SubPath","SubPath","None"
"1381","Field","dir","None","None"
"1382","Field","path","None","None"
"1383","Field","dir","None","None"
"1384","Field","path","None","None"
"1385","Class","PathAlreadyExists","PathAlreadyExists","None"
"1386","Field","serialVersionUID","None","None"
"1387","Field","throwable","None","None"
"1388","Field","detailMessage","None","None"
"1389","Field","detailMessage","None","None"
"1390","Field","throwable","None","None"
"1391","Package","com.tencent.mm.resourceproguard","com.tencent.mm.resourceproguard","None"
"1392","Class","InputParam","InputParam","None"
"1393","Field","mappingFile","None","None"
"1394","Field","use7zip","None","None"
"1395","Field","keepRoot","None","None"
"1396","Field","mergeDuplicatedRes","None","None"
"1397","Field","useSign","None","None"
"1398","Field","metaName","None","None"
"1399","Field","fixedResName","None","None"
"1400","Field","whiteList","None","None"
"1401","Field","compressFilePattern","None","None"
"1402","Field","apkPath","None","None"
"1403","Field","outFolder","None","None"
"1404","Field","signFile","None","None"
"1405","Field","keypass","None","None"
"1406","Field","storealias","None","None"
"1407","Field","storepass","None","None"
"1408","Field","zipAlignPath","None","None"
"1409","Field","sevenZipPath","None","None"
"1410","Field","signatureType","None","None"
"1411","Field","finalApkBackupPath","None","None"
"1412","Field","digestAlg","None","None"
"1413","Field","minSDKVersion","None","None"
"1414","Field","targetSDKVersion","None","None"
"1415","Field","mappingFile","None","None"
"1416","Field","use7zip","None","None"
"1417","Field","useSign","None","None"
"1418","Field","keepRoot","None","None"
"1419","Field","mergeDuplicatedRes","None","None"
"1420","Field","whiteList","None","None"
"1421","Field","compressFilePattern","None","None"
"1422","Field","apkPath","None","None"
"1423","Field","outFolder","None","None"
"1424","Field","signFile","None","None"
"1425","Field","keypass","None","None"
"1426","Field","storealias","None","None"
"1427","Field","storepass","None","None"
"1428","Field","metaName","None","None"
"1429","Field","fixedResName","None","None"
"1430","Field","zipAlignPath","None","None"
"1431","Field","sevenZipPath","None","None"
"1432","Field","signatureType","None","None"
"1433","Field","finalApkBackupPath","None","None"
"1434","Field","digestAlg","None","None"
"1435","Field","minSDKVersion","None","None"
"1436","Field","targetSDKVersion","None","None"
"1437","Field","mappingFile","None","None"
"1438","Field","use7zip","None","None"
"1439","Field","useSign","None","None"
"1440","Field","keepRoot","None","None"
"1441","Field","mergeDuplicatedRes","None","None"
"1442","Field","whiteList","None","None"
"1443","Field","compressFilePattern","None","None"
"1444","Field","apkPath","None","None"
"1445","Field","outFolder","None","None"
"1446","Field","signFile","None","None"
"1447","Field","keypass","None","None"
"1448","Field","storealias","None","None"
"1449","Field","storepass","None","None"
"1450","Field","metaName","None","None"
"1451","Field","fixedResName","None","None"
"1452","Field","zipAlignPath","None","None"
"1453","Field","sevenZipPath","None","None"
"1454","Field","signatureType","None","None"
"1455","Field","finalApkBackupPath","None","None"
"1456","Field","digestAlg","None","None"
"1457","Field","minSDKVersion","None","None"
"1458","Field","targetSDKVersion","None","None"
"1459","Field","mappingFile","None","None"
"1460","Field","use7zip","None","None"
"1461","Field","useSign","None","None"
"1462","Field","keepRoot","None","None"
"1463","Field","mergeDuplicatedRes","None","None"
"1464","Field","whiteList","None","None"
"1465","Field","compressFilePattern","None","None"
"1466","Field","apkPath","None","None"
"1467","Field","outFolder","None","None"
"1468","Field","signFile","None","None"
"1469","Field","keypass","None","None"
"1470","Field","storealias","None","None"
"1471","Field","storepass","None","None"
"1472","Field","metaName","None","None"
"1473","Field","fixedResName","None","None"
"1474","Field","zipAlignPath","None","None"
"1475","Field","sevenZipPath","None","None"
"1476","Field","signatureType","None","None"
"1477","Field","finalApkBackupPath","None","None"
"1478","Field","digestAlg","None","None"
"1479","Field","minSDKVersion","None","None"
"1480","Field","targetSDKVersion","None","None"
"1481","Class","SignatureType","SignatureType","None"
"1482","Class","Builder","Builder","None"
"1483","Field","mappingFile","None","None"
"1484","Field","use7zip","None","None"
"1485","Field","useSign","None","None"
"1486","Field","keepRoot","None","None"
"1487","Field","mergeDuplicatedRes","None","None"
"1488","Field","whiteList","None","None"
"1489","Field","compressFilePattern","None","None"
"1490","Field","apkPath","None","None"
"1491","Field","outFolder","None","None"
"1492","Field","signFile","None","None"
"1493","Field","keypass","None","None"
"1494","Field","storealias","None","None"
"1495","Field","storepass","None","None"
"1496","Field","metaName","None","None"
"1497","Field","fixedResName","None","None"
"1498","Field","zipAlignPath","None","None"
"1499","Field","sevenZipPath","None","None"
"1500","Field","signatureType","None","None"
"1501","Field","finalApkBackupPath","None","None"
"1502","Field","digestAlg","None","None"
"1503","Field","minSDKVersion","None","None"
"1504","Field","targetSDKVersion","None","None"
"1505","Field","mappingFile","None","None"
"1506","Field","use7zip","None","None"
"1507","Field","useSign","None","None"
"1508","Field","keepRoot","None","None"
"1509","Field","mergeDuplicatedRes","None","None"
"1510","Field","whiteList","None","None"
"1511","Field","compressFilePattern","None","None"
"1512","Field","apkPath","None","None"
"1513","Field","outFolder","None","None"
"1514","Field","signFile","None","None"
"1515","Field","keypass","None","None"
"1516","Field","storealias","None","None"
"1517","Field","storepass","None","None"
"1518","Field","metaName","None","None"
"1519","Field","fixedResName","None","None"
"1520","Field","zipAlignPath","None","None"
"1521","Field","sevenZipPath","None","None"
"1522","Field","signatureType","None","None"
"1523","Field","finalApkBackupPath","None","None"
"1524","Field","digestAlg","None","None"
"1525","Field","minSDKVersion","None","None"
"1526","Field","targetSDKVersion","None","None"
"1527","Method","setMappingFile","public Builder setMappingFile(File mappingFile) {
      this.mappingFile = mappingFile;
      return this;
    }","None"
"1528","Field","mappingFile","None","None"
"1529","Method","setUse7zip","public Builder setUse7zip(boolean use7zip) {
      this.use7zip = use7zip;
      return this;
    }","None"
"1530","Field","use7zip","None","None"
"1531","Method","setUseSign","public Builder setUseSign(boolean useSign) {
      this.useSign = useSign;
      return this;
    }","None"
"1532","Field","useSign","None","None"
"1533","Method","setKeepRoot","public Builder setKeepRoot(boolean keepRoot) {
      this.keepRoot = keepRoot;
      return this;
    }","None"
"1534","Field","keepRoot","None","None"
"1535","Method","setMergeDuplicatedRes","public Builder setMergeDuplicatedRes(boolean mergeDuplicatedRes) {
      this.mergeDuplicatedRes = mergeDuplicatedRes;
      return this;
    }","None"
"1536","Field","mergeDuplicatedRes","None","None"
"1537","Method","setWhiteList","public Builder setWhiteList(ArrayList<String> whiteList) {
      this.whiteList = whiteList;
      return this;
    }","None"
"1538","Field","whiteList","None","None"
"1539","Method","setCompressFilePattern","public Builder setCompressFilePattern(ArrayList<String> compressFilePattern) {
      if (compressFilePattern.contains(Configuration.ASRC_FILE)) {
        System.out.printf(""[Warning] compress %s will prevent optimization at runtime"",
            Configuration.ASRC_FILE);
      }
      this.compressFilePattern = compressFilePattern;
      return this;
    }","None"
"1540","Field","compressFilePattern","None","None"
"1541","Method","setApkPath","public Builder setApkPath(String apkPath) {
      this.apkPath = apkPath;
      return this;
    }","None"
"1542","Field","apkPath","None","None"
"1543","Method","setOutBuilder","public Builder setOutBuilder(String outFolder) {
      this.outFolder = outFolder;
      return this;
    }","None"
"1544","Field","outFolder","None","None"
"1545","Method","setSignFile","public Builder setSignFile(File signFile) {
      this.signFile = signFile;
      return this;
    }","None"
"1546","Field","signFile","None","None"
"1547","Method","setKeypass","public Builder setKeypass(String keypass) {
      this.keypass = keypass;
      return this;
    }","None"
"1548","Field","keypass","None","None"
"1549","Method","setStorealias","public Builder setStorealias(String storealias) {
      this.storealias = storealias;
      return this;
    }","None"
"1550","Field","storealias","None","None"
"1551","Method","setStorepass","public Builder setStorepass(String storepass) {
      this.storepass = storepass;
      return this;
    }","None"
"1552","Field","storepass","None","None"
"1553","Method","setMetaName","public Builder setMetaName(String metaName) {
      this.metaName = metaName;
      return this;
    }","None"
"1554","Field","metaName","None","None"
"1555","Method","setFixedResName","public Builder setFixedResName(String fixedResName) {
      this.fixedResName = fixedResName;
      return this;
    }","None"
"1556","Field","fixedResName","None","None"
"1557","Method","setZipAlign","public Builder setZipAlign(String zipAlignPath) {
      this.zipAlignPath = zipAlignPath;
      return this;
    }","None"
"1558","Field","zipAlignPath","None","None"
"1559","Method","setSevenZipPath","public Builder setSevenZipPath(String sevenZipPath) {
      this.sevenZipPath = sevenZipPath;
      return this;
    }","None"
"1560","Field","sevenZipPath","None","None"
"1561","Method","setSignatureType","public Builder setSignatureType(SignatureType signatureType) {
      this.signatureType = signatureType;
      return this;
    }","None"
"1562","Field","signatureType","None","None"
"1563","Method","setFinalApkBackupPath","public Builder setFinalApkBackupPath(String finalApkBackupPath) {
      this.finalApkBackupPath = finalApkBackupPath;
      return this;
    }","None"
"1564","Field","finalApkBackupPath","None","None"
"1565","Method","setDigestAlg","public Builder setDigestAlg(String digestAlg) {
      if (StringUtil.isPresent(digestAlg)) {
        this.digestAlg = digestAlg;
      } else {
        this.digestAlg = Configuration.DEFAULT_DIGEST_ALG;
      }

      return this;
    }","None"
"1566","Field","digestAlg","None","None"
"1567","Method","setMinSDKVersion","public Builder setMinSDKVersion(int minSDKVersion) {
      this.minSDKVersion = minSDKVersion;
      return this;
    }","None"
"1568","Field","minSDKVersion","None","None"
"1569","Method","setTargetSDKVersion","public Builder setTargetSDKVersion(int targetSDKVersion) {
      this.targetSDKVersion = targetSDKVersion;
      return this;
    }","None"
"1570","Field","targetSDKVersion","None","None"
"1571","Method","create","public InputParam create() {
      if (targetSDKVersion >= 30) {
        // Targeting R+ (version 30 and above) requires the resources.arsc of installed APKs
        // to be stored uncompressed and aligned on a 4-byte boundary
        this.compressFilePattern.remove(Configuration.ASRC_FILE);
        System.out.printf(""[Warning] Remove resources.arsc from the compressPattern. (%s)\n"",
            this.compressFilePattern);
      }

      return new InputParam(mappingFile,
          use7zip,
          useSign,
          keepRoot,
          mergeDuplicatedRes,
          whiteList,
          compressFilePattern,
          apkPath,
          outFolder,
          signFile,
          keypass,
          storealias,
          storepass,
          metaName,
          fixedResName,
          zipAlignPath,
          sevenZipPath,
          signatureType,
          finalApkBackupPath,
          digestAlg,
          minSDKVersion,
          targetSDKVersion
      );
    }","None"
"1572","Class","Configuration","Configuration","None"
"1573","Field","DEFAULT_DIGEST_ALG","None","None"
"1574","Field","ASRC_FILE","None","None"
"1575","Field","TAG_ISSUE","None","None"
"1576","Field","ATTR_VALUE","None","None"
"1577","Field","ATTR_ID","None","None"
"1578","Field","ATTR_ACTIVE","None","None"
"1579","Field","PROPERTY_ISSUE","None","None"
"1580","Field","WHITELIST_ISSUE","None","None"
"1581","Field","COMPRESS_ISSUE","None","None"
"1582","Field","MAPPING_ISSUE","None","None"
"1583","Field","SIGN_ISSUE","None","None"
"1584","Field","ATTR_7ZIP","None","None"
"1585","Field","ATTR_KEEPROOT","None","None"
"1586","Field","ATTR_SIGNFILE","None","None"
"1587","Field","MERGE_DUPLICATED_RES","None","None"
"1588","Field","ATTR_SIGNFILE_PATH","None","None"
"1589","Field","ATTR_SIGNFILE_KEYPASS","None","None"
"1590","Field","ATTR_SIGNFILE_STOREPASS","None","None"
"1591","Field","ATTR_SIGNFILE_ALIAS","None","None"
"1592","Field","mWhiteList","None","None"
"1593","Field","mOldResMapping","None","None"
"1594","Field","mOldFileMapping","None","None"
"1595","Field","mCompressPatterns","None","None"
"1596","Field","digestAlg","None","None"
"1597","Field","MAP_PATTERN","None","None"
"1598","Field","mUse7zip","None","None"
"1599","Field","mKeepRoot","None","None"
"1600","Field","mMergeDuplicatedRes","None","None"
"1601","Field","mMetaName","None","None"
"1602","Field","mFixedResName","None","None"
"1603","Field","mUseSignAPK","None","None"
"1604","Field","mUseKeepMapping","None","None"
"1605","Field","mSignatureFile","None","None"
"1606","Field","mOldMappingFile","None","None"
"1607","Field","mUseWhiteList","None","None"
"1608","Field","mUseCompress","None","None"
"1609","Field","mKeyPass","None","None"
"1610","Field","mStorePass","None","None"
"1611","Field","mStoreAlias","None","None"
"1612","Field","m7zipPath","None","None"
"1613","Field","mZipalignPath","None","None"
"1614","Field","config","None","None"
"1615","Field","sevenzipPath","None","None"
"1616","Field","zipAlignPath","None","None"
"1617","Field","mappingFile","None","None"
"1618","Field","signatureFile","None","None"
"1619","Field","keypass","None","None"
"1620","Field","storealias","None","None"
"1621","Field","storepass","None","None"
"1622","Field","param","None","None"
"1623","Field","signatureFile","None","None"
"1624","Field","keypass","None","None"
"1625","Field","storealias","None","None"
"1626","Field","storepass","None","None"
"1627","Field","mappingFile","None","None"
"1628","Field","xmlConfigFile","None","None"
"1629","Field","input","None","None"
"1630","Field","factory","None","None"
"1631","Field","source","None","None"
"1632","Field","builder","None","None"
"1633","Field","document","None","None"
"1634","Field","issues","None","None"
"1635","Field","node","None","None"
"1636","Field","element","None","None"
"1637","Field","id","None","None"
"1638","Field","isActive","None","None"
"1639","Field","active","None","None"
"1640","Field","node","None","None"
"1641","Field","childNodes","None","None"
"1642","Field","child","None","None"
"1643","Field","check","None","None"
"1644","Field","vaule","None","None"
"1645","Field","item","None","None"
"1646","Field","packagePos","None","None"
"1647","Field","packageName","None","None"
"1648","Field","nextDot","None","None"
"1649","Field","typeName","None","None"
"1650","Field","name","None","None"
"1651","Field","typeMap","None","None"
"1652","Field","patterns","None","None"
"1653","Field","pattern","None","None"
"1654","Field","node","None","None"
"1655","Field","xmlConfigFileParentFile","None","None"
"1656","Field","childNodes","None","None"
"1657","Field","child","None","None"
"1658","Field","check","None","None"
"1659","Field","tagName","None","None"
"1660","Field","vaule","None","None"
"1661","Field","ch","None","None"
"1662","Field","node","None","None"
"1663","Field","childNodes","None","None"
"1664","Field","child","None","None"
"1665","Field","check","None","None"
"1666","Field","value","None","None"
"1667","Field","value","None","None"
"1668","Field","pattern","None","None"
"1669","Field","node","None","None"
"1670","Field","childNodes","None","None"
"1671","Field","child","None","None"
"1672","Field","check","None","None"
"1673","Field","filePath","None","None"
"1674","Field","node","None","None"
"1675","Field","childNodes","None","None"
"1676","Field","child","None","None"
"1677","Field","check","None","None"
"1678","Field","tagName","None","None"
"1679","Field","vaule","None","None"
"1680","Field","filePath","None","None"
"1681","Field","fr","None","None"
"1682","Field","br","None","None"
"1683","Field","line","None","None"
"1684","Field","mat","None","None"
"1685","Field","nameAfter","None","None"
"1686","Field","nameBefore","None","None"
"1687","Field","packagePos","None","None"
"1688","Field","packageName","None","None"
"1689","Field","nextDot","None","None"
"1690","Field","typeName","None","None"
"1691","Field","beforename","None","None"
"1692","Field","aftername","None","None"
"1693","Field","typeMap","None","None"
"1694","Field","namesMap","None","None"
"1695","Method","setSignData","private void setSignData(
      File signatureFile, String keypass, String storealias, String storepass) throws IOException {
    mUseSignAPK = true;
    mSignatureFile = signatureFile;
    if (!mSignatureFile.exists()) {
      throw new IOException(String.format(""the signature file do not exit, raw path= %s\n"",
          mSignatureFile.getAbsolutePath()
      ));
    }
    mKeyPass = keypass;
    mStoreAlias = storealias;
    mStorePass = storepass;
  }","None"
"1696","Field","signatureFile","None","None"
"1697","Field","keypass","None","None"
"1698","Field","storealias","None","None"
"1699","Field","storepass","None","None"
"1700","Method","setKeepMappingData","private void setKeepMappingData(File mappingFile) throws IOException {
    if (mUseKeepMapping) {
      mOldMappingFile = mappingFile;

      if (!mOldMappingFile.exists()) {
        throw new IOException(String.format(""the old mapping file do not exit, raw path= %s"",
            mOldMappingFile.getAbsolutePath()
        ));
      }
      processOldMappingFile();
    }
  }","None"
"1701","Field","mappingFile","None","None"
"1702","Method","readXmlConfig","private void readXmlConfig(File xmlConfigFile) throws IOException, ParserConfigurationException, SAXException {
    if (!xmlConfigFile.exists()) {
      return;
    }

    System.out.printf(""reading config file, %s\n"", xmlConfigFile.getAbsolutePath());
    BufferedInputStream input = null;
    try {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      input = new BufferedInputStream(new FileInputStream(xmlConfigFile));
      InputSource source = new InputSource(input);
      factory.setNamespaceAware(false);
      factory.setValidating(false);
      DocumentBuilder builder = factory.newDocumentBuilder();
      Document document = builder.parse(source);
      NodeList issues = document.getElementsByTagName(TAG_ISSUE);
      for (int i = 0, count = issues.getLength(); i < count; i++) {
        Node node = issues.item(i);

        Element element = (Element) node;
        String id = element.getAttribute(ATTR_ID);
        String isActive = element.getAttribute(ATTR_ACTIVE);
        if (id.length() == 0) {
          System.err.println(""Invalid config file: Missing required issue id attribute"");
          continue;
        }
        boolean active = isActive != null && isActive.equals(""true"");

        switch (id) {
          case PROPERTY_ISSUE:
            readPropertyFromXml(node);
            break;
          case WHITELIST_ISSUE:
            mUseWhiteList = active;
            if (mUseWhiteList) {
              readWhiteListFromXml(node);
            }
            break;
          case COMPRESS_ISSUE:
            mUseCompress = active;
            if (mUseCompress) {
              readCompressFromXml(node);
            }
            break;
          case SIGN_ISSUE:
            mUseSignAPK |= active;
            if (mUseSignAPK) {
              readSignFromXml(node, xmlConfigFile.getParentFile());
            }
            break;
          case MAPPING_ISSUE:
            mUseKeepMapping = active;
            if (mUseKeepMapping) {
              loadMappingFilesFromXml(node);
            }
            break;
          default:
            System.err.println(""unknown issue "" + id);
            break;
        }
      }
    } finally {
      if (input != null) {
        try {
          input.close();
        } catch (IOException e) {
          System.exit(-1);
        }
      }
    }
  }","None"
"1703","Field","xmlConfigFile","None","None"
"1704","Field","input","None","None"
"1705","Field","factory","None","None"
"1706","Field","source","None","None"
"1707","Field","builder","None","None"
"1708","Field","document","None","None"
"1709","Field","issues","None","None"
"1710","Field","node","None","None"
"1711","Field","element","None","None"
"1712","Field","id","None","None"
"1713","Field","isActive","None","None"
"1714","Field","active","None","None"
"1715","Method","readWhiteListFromXml","private void readWhiteListFromXml(Node node) throws IOException {
    NodeList childNodes = node.getChildNodes();
    if (childNodes.getLength() > 0) {
      for (int j = 0, n = childNodes.getLength(); j < n; j++) {
        Node child = childNodes.item(j);
        if (child.getNodeType() == Node.ELEMENT_NODE) {
          Element check = (Element) child;
          String vaule = check.getAttribute(ATTR_VALUE);
          addWhiteList(vaule);
        }
      }
    }
  }","None"
"1716","Field","node","None","None"
"1717","Field","childNodes","None","None"
"1718","Field","child","None","None"
"1719","Field","check","None","None"
"1720","Field","vaule","None","None"
"1721","Method","addWhiteList","private void addWhiteList(String item) throws IOException {
    if (item.length() == 0) {
      throw new IOException(""Invalid config file: Missing required attribute "" + ATTR_VALUE);
    }

    int packagePos = item.indexOf("".R."");
    if (packagePos == -1) {

      throw new IOException(String.format(""please write the full package name,eg com.tencent.mm.R.drawable.dfdf, but yours %s\n"",
          item
      ));
    }
    //先去掉空格
    item = item.trim();
    String packageName = item.substring(0, packagePos);
    //不能通过lastDot
    int nextDot = item.indexOf(""."", packagePos + 3);
    String typeName = item.substring(packagePos + 3, nextDot);
    String name = item.substring(nextDot + 1);
    HashMap<String, HashSet<Pattern>> typeMap;

    if (mWhiteList.containsKey(packageName)) {
      typeMap = mWhiteList.get(packageName);
    } else {
      typeMap = new HashMap<>();
    }

    HashSet<Pattern> patterns;
    if (typeMap.containsKey(typeName)) {
      patterns = typeMap.get(typeName);
    } else {
      patterns = new HashSet<>();
    }

    name = Utils.convertToPatternString(name);
    Pattern pattern = Pattern.compile(name);
    patterns.add(pattern);
    typeMap.put(typeName, patterns);
    System.out.println(String.format(""convertToPatternString typeName %s format %s"", typeName, name));
    mWhiteList.put(packageName, typeMap);
  }","None"
"1722","Field","item","None","None"
"1723","Field","packagePos","None","None"
"1724","Field","packageName","None","None"
"1725","Field","nextDot","None","None"
"1726","Field","typeName","None","None"
"1727","Field","name","None","None"
"1728","Field","typeMap","None","None"
"1729","Field","patterns","None","None"
"1730","Field","pattern","None","None"
"1731","Method","readSignFromXml","private void readSignFromXml(Node node, File xmlConfigFileParentFile) throws IOException {
    if (mSignatureFile != null) {
      System.err.println(""already set the sign info from command line, ignore this"");
      return;
    }

    NodeList childNodes = node.getChildNodes();

    if (childNodes.getLength() > 0) {
      for (int j = 0, n = childNodes.getLength(); j < n; j++) {
        Node child = childNodes.item(j);
        if (child.getNodeType() == Node.ELEMENT_NODE) {
          Element check = (Element) child;
          String tagName = check.getTagName();
          String vaule = check.getAttribute(ATTR_VALUE);
          if (vaule.length() == 0) {
            throw new IOException(String.format(""Invalid config file: Missing required attribute %s\n"", ATTR_VALUE));
          }

          switch (tagName) {
            case ATTR_SIGNFILE_PATH:
              char ch = vaule.charAt(0);
              switch (ch) {
                // supports the writting style like ~/.android/debug.keystore. the symbol ~ represent the home directory of the current user.
                case '~':
                  mSignatureFile = new File(String.format(""%s%s"", System.getProperty(""user.home""), vaule.substring(1)));
                  break;
                // relative to the directory of the xml config file.
                case '.':
                  mSignatureFile = new File(xmlConfigFileParentFile, vaule);
                  break;
                // keep the origin logical.
                default:
                  mSignatureFile = new File(vaule);
              }
              if (!mSignatureFile.isFile()) {
                throw new IOException(String.format(""the signature file do not exit. raw path= %s\n"",
                    mSignatureFile.getAbsolutePath()
                ));
              }
              break;
            case ATTR_SIGNFILE_STOREPASS:
              mStorePass = vaule;
              mStorePass = mStorePass.trim();
              break;
            case ATTR_SIGNFILE_KEYPASS:
              mKeyPass = vaule;
              mKeyPass = mKeyPass.trim();
              break;
            case ATTR_SIGNFILE_ALIAS:
              mStoreAlias = vaule;
              mStoreAlias = mStoreAlias.trim();
              break;
            default:
              System.err.println(""unknown tag "" + tagName);
              break;
          }
        }
      }
    }
  }","None"
"1732","Field","node","None","None"
"1733","Field","xmlConfigFileParentFile","None","None"
"1734","Field","childNodes","None","None"
"1735","Field","child","None","None"
"1736","Field","check","None","None"
"1737","Field","tagName","None","None"
"1738","Field","vaule","None","None"
"1739","Field","ch","None","None"
"1740","Method","readCompressFromXml","private void readCompressFromXml(Node node) throws IOException {
    NodeList childNodes = node.getChildNodes();
    if (childNodes.getLength() > 0) {
      for (int j = 0, n = childNodes.getLength(); j < n; j++) {
        Node child = childNodes.item(j);
        if (child.getNodeType() == Node.ELEMENT_NODE) {
          Element check = (Element) child;
          String value = check.getAttribute(ATTR_VALUE);
          addToCompressPatterns(value);
        }
      }
    }
  }","None"
"1741","Field","node","None","None"
"1742","Field","childNodes","None","None"
"1743","Field","child","None","None"
"1744","Field","check","None","None"
"1745","Field","value","None","None"
"1746","Method","addToCompressPatterns","private void addToCompressPatterns(String value) throws IOException {
    if (value.length() == 0) {
      throw new IOException(String.format(""Invalid config file: Missing required attribute %s\n"", ATTR_VALUE));
    }
    value = Utils.convertToPatternString(value);
    Pattern pattern = Pattern.compile(value);
    mCompressPatterns.add(pattern);
  }","None"
"1747","Field","value","None","None"
"1748","Field","pattern","None","None"
"1749","Method","loadMappingFilesFromXml","private void loadMappingFilesFromXml(Node node) throws IOException {
    if (mOldMappingFile != null) {
      System.err.println(""Mapping file already load from command line, ignore this config"");
      return;
    }
    NodeList childNodes = node.getChildNodes();
    if (childNodes.getLength() > 0) {
      for (int j = 0, n = childNodes.getLength(); j < n; j++) {
        Node child = childNodes.item(j);
        if (child.getNodeType() == Node.ELEMENT_NODE) {
          Element check = (Element) child;
          String filePath = check.getAttribute(ATTR_VALUE);
          if (filePath.length() == 0) {
            throw new IOException(String.format(""Invalid config file: Missing required attribute %s\n"", ATTR_VALUE));
          }
          readOldMapping(filePath);
        }
      }
    }
  }","None"
"1750","Field","node","None","None"
"1751","Field","childNodes","None","None"
"1752","Field","child","None","None"
"1753","Field","check","None","None"
"1754","Field","filePath","None","None"
"1755","Method","readPropertyFromXml","private void readPropertyFromXml(Node node) throws IOException {
    NodeList childNodes = node.getChildNodes();
    if (childNodes.getLength() > 0) {
      for (int j = 0, n = childNodes.getLength(); j < n; j++) {
        Node child = childNodes.item(j);
        if (child.getNodeType() == Node.ELEMENT_NODE) {
          Element check = (Element) child;
          String tagName = check.getTagName();
          String vaule = check.getAttribute(ATTR_VALUE);
          if (vaule.length() == 0) {
            throw new IOException(String.format(""Invalid config file: Missing required attribute %s\n"", ATTR_VALUE));
          }

          switch (tagName) {
            case ATTR_7ZIP:
              mUse7zip = vaule.equals(""true"");
              break;
            case ATTR_KEEPROOT:
              mKeepRoot = vaule.equals(""true"");
              System.out.println(""mKeepRoot "" + mKeepRoot);
              break;
            case MERGE_DUPLICATED_RES:
              mMergeDuplicatedRes = vaule.equals(""true"");
              System.out.println(""mMergeDuplicatedRes "" + mMergeDuplicatedRes);
              break;
            case ATTR_SIGNFILE:
              mMetaName = vaule.trim();
              break;
            default:
              System.err.println(""unknown tag "" + tagName);
              break;
          }
        }
      }
    }
  }","None"
"1756","Field","node","None","None"
"1757","Field","childNodes","None","None"
"1758","Field","child","None","None"
"1759","Field","check","None","None"
"1760","Field","tagName","None","None"
"1761","Field","vaule","None","None"
"1762","Method","readOldMapping","private void readOldMapping(String filePath) throws IOException {
    mOldMappingFile = new File(filePath);
    if (!mOldMappingFile.exists()) {
      throw new IOException(String.format(""the old mapping file do not exit, raw path= %s\n"",
          mOldMappingFile.getAbsolutePath()
      ));
    }
    processOldMappingFile();
    System.out.printf(""you are using the keepmapping mode to proguard resouces: old mapping path:%s\n"",
        mOldMappingFile.getAbsolutePath()
    );
  }","None"
"1763","Field","filePath","None","None"
"1764","Method","processOldMappingFile","private void processOldMappingFile() throws IOException {
    mOldResMapping.clear();
    mOldFileMapping.clear();

    FileReader fr;
    try {
      fr = new FileReader(mOldMappingFile);
    } catch (FileNotFoundException ex) {
      throw new IOException(String.format(""Could not find old mapping file %s"", mOldMappingFile.getAbsolutePath()));
    }
    BufferedReader br = new BufferedReader(fr);
    try {
      String line = br.readLine();

      while (line != null) {
        if (line.length() > 0) {
          Matcher mat = MAP_PATTERN.matcher(line);

          if (mat.find()) {
            String nameAfter = mat.group(2);
            String nameBefore = mat.group(1);
            nameAfter = nameAfter.trim();
            nameBefore = nameBefore.trim();

            //如果有这个的话，那就是mOldFileMapping
            if (line.contains(""/"")) {
              mOldFileMapping.put(nameBefore, nameAfter);
            } else {
              //这里是resid的mapping
              int packagePos = nameBefore.indexOf("".R."");
              if (packagePos == -1) {
                throw new IOException(String.format(""the old mapping file packagename is malformed, ""
                                                    + ""it should be like com.tencent.mm.R.attr.test, yours %s\n"",
                    nameBefore
                ));
              }
              String packageName = nameBefore.substring(0, packagePos);
              int nextDot = nameBefore.indexOf(""."", packagePos + 3);
              String typeName = nameBefore.substring(packagePos + 3, nextDot);

              String beforename = nameBefore.substring(nextDot + 1);
              String aftername = nameAfter.substring(nameAfter.indexOf(""."", packagePos + 3) + 1);

              HashMap<String, HashMap<String, String>> typeMap;

              if (mOldResMapping.containsKey(packageName)) {
                typeMap = mOldResMapping.get(packageName);
              } else {
                typeMap = new HashMap<>();
              }

              HashMap<String, String> namesMap;
              if (typeMap.containsKey(typeName)) {
                namesMap = typeMap.get(typeName);
              } else {
                namesMap = new HashMap<>();
              }
              namesMap.put(beforename, aftername);

              typeMap.put(typeName, namesMap);
              mOldResMapping.put(packageName, typeMap);
            }
          }
        }
        line = br.readLine();
      }
    } catch (IOException ex) {
      throw new RuntimeException(""Error while mapping file"");
    } finally {
      try {
        br.close();
        fr.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }","None"
"1765","Field","fr","None","None"
"1766","Field","br","None","None"
"1767","Field","line","None","None"
"1768","Field","mat","None","None"
"1769","Field","nameAfter","None","None"
"1770","Field","nameBefore","None","None"
"1771","Field","packagePos","None","None"
"1772","Field","packageName","None","None"
"1773","Field","nextDot","None","None"
"1774","Field","typeName","None","None"
"1775","Field","beforename","None","None"
"1776","Field","aftername","None","None"
"1777","Field","typeMap","None","None"
"1778","Field","namesMap","None","None"
"1779","Class","Main","Main","None"
"1780","Field","ERRNO_ERRORS","None","None"
"1781","Field","ERRNO_USAGE","None","None"
"1782","Field","mRawApkSize","None","None"
"1783","Field","mRunningLocation","None","None"
"1784","Field","mBeginTime","None","None"
"1785","Field","mSetSignThroughCmd","None","None"
"1786","Field","mSetMappingThroughCmd","None","None"
"1787","Field","m7zipPath","None","None"
"1788","Field","mZipalignPath","None","None"
"1789","Field","mFinalApkBackPath","None","None"
"1790","Field","config","None","None"
"1791","Field","mOutDir","None","None"
"1792","Field","inputParam","None","None"
"1793","Field","m","None","None"
"1794","Field","inputParam","None","None"
"1795","Field","currentThread","None","None"
"1796","Field","finalApkFile","None","None"
"1797","Field","inputParam","None","None"
"1798","Field","outputDir","None","None"
"1799","Field","outputFile","None","None"
"1800","Field","apkFilePath","None","None"
"1801","Field","signatureType","None","None"
"1802","Field","outputDir","None","None"
"1803","Field","outputFile","None","None"
"1804","Field","apkFilePath","None","None"
"1805","Field","signatureType","None","None"
"1806","Field","minSDKVersoin","None","None"
"1807","Field","apkFile","None","None"
"1808","Field","decoder","None","None"
"1809","Field","outputFile","None","None"
"1810","Field","decoder","None","None"
"1811","Field","apkFile","None","None"
"1812","Field","decoder","None","None"
"1813","Field","apkFile","None","None"
"1814","Field","outputFile","None","None"
"1815","Field","signatureType","None","None"
"1816","Field","minSDKVersion","None","None"
"1817","Field","builder","None","None"
"1818","Field","apkBasename","None","None"
"1819","Method","gradleRun","public static void gradleRun(InputParam inputParam) {
    Main m = new Main();
    m.run(inputParam);
  }","None"
"1820","Field","inputParam","None","None"
"1821","Field","m","None","None"
"1822","Method","run","private void run(InputParam inputParam) {
    synchronized (Main.class) {
      loadConfigFromGradle(inputParam);
      this.mFinalApkBackPath = inputParam.finalApkBackupPath;
      Thread currentThread = Thread.currentThread();
      System.out.printf(
          ""\n-->AndResGuard starting! Current thread# id: %d, name: %s\n"",
          currentThread.getId(),
          currentThread.getName()
      );
      File finalApkFile = StringUtil.isPresent(inputParam.finalApkBackupPath) ?
          new File(inputParam.finalApkBackupPath)
          : null;

      resourceProguard(
          new File(inputParam.outFolder),
          finalApkFile,
          inputParam.apkPath,
          inputParam.signatureType,
          inputParam.minSDKVersion
      );
      System.out.printf(""<--AndResGuard Done! You can find the output in %s\n"", mOutDir.getAbsolutePath());
      clean();
    }
  }","None"
"1823","Field","inputParam","None","None"
"1824","Field","currentThread","None","None"
"1825","Field","finalApkFile","None","None"
"1826","Method","clean","protected void clean() {
    config = null;
    ARSCDecoder.mTableStringsResguard.clear();
    ARSCDecoder.mMergeDuplicatedResCount = 0;
  }","None"
"1827","Method","loadConfigFromGradle","private void loadConfigFromGradle(InputParam inputParam) {
    try {
      config = new Configuration(inputParam);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }","None"
"1828","Field","inputParam","None","None"
"1829","Method","resourceProguard","protected void resourceProguard(
      File outputDir, File outputFile, String apkFilePath, InputParam.SignatureType signatureType) {
    resourceProguard(outputDir, outputFile, apkFilePath, signatureType, 14 /*default min sdk*/);
  }","None"
"1830","Field","outputDir","None","None"
"1831","Field","outputFile","None","None"
"1832","Field","apkFilePath","None","None"
"1833","Field","signatureType","None","None"
"1834","Method","resourceProguard","protected void resourceProguard(
      File outputDir, File outputFile, String apkFilePath, InputParam.SignatureType signatureType, int minSDKVersoin) {
    File apkFile = new File(apkFilePath);
    if (!apkFile.exists()) {
      System.err.printf(""The input apk %s does not exist"", apkFile.getAbsolutePath());
      goToError();
    }
    mRawApkSize = FileOperation.getFileSizes(apkFile);
    try {
      ApkDecoder decoder = new ApkDecoder(config, apkFile);
      /* 默认使用V1签名 */
      decodeResource(outputDir, decoder, apkFile);
      buildApk(decoder, apkFile, outputFile, signatureType, minSDKVersoin);
    } catch (Exception e) {
      e.printStackTrace();
      goToError();
    }
  }","None"
"1835","Field","outputDir","None","None"
"1836","Field","outputFile","None","None"
"1837","Field","apkFilePath","None","None"
"1838","Field","signatureType","None","None"
"1839","Field","minSDKVersoin","None","None"
"1840","Field","apkFile","None","None"
"1841","Field","decoder","None","None"
"1842","Method","decodeResource","private void decodeResource(File outputFile, ApkDecoder decoder, File apkFile)
      throws AndrolibException, IOException, DirectoryException {
    if (outputFile == null) {
      mOutDir = new File(mRunningLocation, apkFile.getName().substring(0, apkFile.getName().indexOf("".apk"")));
    } else {
      mOutDir = outputFile;
    }
    decoder.setOutDir(mOutDir.getAbsoluteFile());
    decoder.decode();
  }","None"
"1843","Field","outputFile","None","None"
"1844","Field","decoder","None","None"
"1845","Field","apkFile","None","None"
"1846","Method","buildApk","private void buildApk(
      ApkDecoder decoder, File apkFile, File outputFile, InputParam.SignatureType signatureType, int minSDKVersion)
      throws Exception {
    ResourceApkBuilder builder = new ResourceApkBuilder(config);
    String apkBasename = apkFile.getName();
    apkBasename = apkBasename.substring(0, apkBasename.indexOf("".apk""));
    builder.setOutDir(mOutDir, apkBasename, outputFile);
    System.out.printf(""[AndResGuard] buildApk signatureType: %s\n"", signatureType);
    switch (signatureType) {
      case SchemaV1:
        builder.buildApkWithV1sign(decoder.getCompressData());
        break;
      case SchemaV2:
      case SchemaV3:
        builder.buildApkWithV2V3Sign(decoder.getCompressData(), minSDKVersion, signatureType);
        break;
    }
  }","None"
"1847","Field","decoder","None","None"
"1848","Field","apkFile","None","None"
"1849","Field","outputFile","None","None"
"1850","Field","signatureType","None","None"
"1851","Field","minSDKVersion","None","None"
"1852","Field","builder","None","None"
"1853","Field","apkBasename","None","None"
"1854","Method","goToError","protected void goToError() {
    System.exit(ERRNO_USAGE);
  }","None"
"1855","Package","com.tencent.mm.androlib","com.tencent.mm.androlib","None"
"1856","Class","ApkDecoder","ApkDecoder","None"
"1857","Field","mRawResourceFiles","None","None"
"1858","Field","config","None","None"
"1859","Field","apkFile","None","None"
"1860","Field","mOutDir","None","None"
"1861","Field","mOutTempARSCFile","None","None"
"1862","Field","mOutARSCFile","None","None"
"1863","Field","mOutResFile","None","None"
"1864","Field","mRawResFile","None","None"
"1865","Field","mOutTempDir","None","None"
"1866","Field","mResMappingFile","None","None"
"1867","Field","mMergeDuplicatedResMappingFile","None","None"
"1868","Field","mCompressData","None","None"
"1869","Field","config","None","None"
"1870","Field","apkFile","None","None"
"1871","Field","resPath","None","None"
"1872","Field","destPath","None","None"
"1873","Field","relativePath","None","None"
"1874","Field","dest","None","None"
"1875","Field","key","None","None"
"1876","Field","unZipDest","None","None"
"1877","Field","basename","None","None"
"1878","Field","patterns","None","None"
"1879","Field","name","None","None"
"1880","Field","p","None","None"
"1881","Field","outDir","None","None"
"1882","Field","pkgs","None","None"
"1883","Field","file","None","None"
"1884","Field","attrs","None","None"
"1885","Method","copyOtherResFiles","private void copyOtherResFiles() throws IOException {
    if (mRawResourceFiles.isEmpty()) {
      return;
    }
    Path resPath = mRawResFile.toPath();
    Path destPath = mOutResFile.toPath();

    for (Path path : mRawResourceFiles) {
      Path relativePath = resPath.relativize(path);
      Path dest = destPath.resolve(relativePath);

      System.out.printf(""copy res file not in resources.arsc file:%s\n"", relativePath.toString());
      FileOperation.copyFileUsingStream(path.toFile(), dest.toFile());
    }
  }","None"
"1886","Field","resPath","None","None"
"1887","Field","destPath","None","None"
"1888","Field","relativePath","None","None"
"1889","Field","dest","None","None"
"1890","Method","removeCopiedResFile","public void removeCopiedResFile(Path key) {
    mRawResourceFiles.remove(key);
  }","None"
"1891","Field","key","None","None"
"1892","Method","getConfig","public Configuration getConfig() {
    return config;
  }","None"
"1893","Method","hasResources","public boolean hasResources() throws AndrolibException {
    try {
      return apkFile.getDirectory().containsFile(""resources.arsc"");
    } catch (DirectoryException ex) {
      throw new AndrolibException(ex);
    }
  }","None"
"1894","Method","ensureFilePath","private void ensureFilePath() throws IOException {
    Utils.cleanDir(mOutDir);

    String unZipDest = new File(mOutDir, TypedValue.UNZIP_FILE_PATH).getAbsolutePath();
    System.out.printf(""unziping apk to %s\n"", unZipDest);
    mCompressData = FileOperation.unZipAPk(apkFile.getAbsoluteFile().getAbsolutePath(), unZipDest);
    dealWithCompressConfig();
    //将res混淆成r
    if (!config.mKeepRoot) {
      mOutResFile = new File(mOutDir.getAbsolutePath() + File.separator + TypedValue.RES_FILE_PATH);
    } else {
      mOutResFile = new File(mOutDir.getAbsolutePath() + File.separator + ""res"");
    }

    //这个需要混淆各个文件夹
    mRawResFile = new File(mOutDir.getAbsoluteFile().getAbsolutePath()
                           + File.separator
                           + TypedValue.UNZIP_FILE_PATH
                           + File.separator
                           + ""res"");
    mOutTempDir = new File(mOutDir.getAbsoluteFile().getAbsolutePath() + File.separator + TypedValue.UNZIP_FILE_PATH);

    //这里纪录原始res目录的文件
    Files.walkFileTree(mRawResFile.toPath(), new ResourceFilesVisitor());

    if (!mRawResFile.exists() || !mRawResFile.isDirectory()) {
      throw new IOException(""can not found res dir in the apk or it is not a dir"");
    }

    mOutTempARSCFile = new File(mOutDir.getAbsoluteFile().getAbsolutePath() + File.separator + ""resources_temp.arsc"");
    mOutARSCFile = new File(mOutDir.getAbsoluteFile().getAbsolutePath() + File.separator + ""resources.arsc"");

    String basename = apkFile.getName().substring(0, apkFile.getName().indexOf("".apk""));
    mResMappingFile = new File(mOutDir.getAbsoluteFile().getAbsolutePath()
                               + File.separator
                               + TypedValue.RES_MAPPING_FILE
                               + basename
                               + TypedValue.TXT_FILE);
    mMergeDuplicatedResMappingFile = new File(mOutDir.getAbsoluteFile().getAbsolutePath()
                             + File.separator
                             + TypedValue.MERGE_DUPLICATED_RES_MAPPING_FILE
                             + basename
                             + TypedValue.TXT_FILE);
  }","None"
"1895","Field","unZipDest","None","None"
"1896","Field","basename","None","None"
"1897","Method","dealWithCompressConfig","private void dealWithCompressConfig() {
    if (config.mUseCompress) {
      HashSet<Pattern> patterns = config.mCompressPatterns;
      if (!patterns.isEmpty()) {
        for (Entry<String, Integer> entry : mCompressData.entrySet()) {
          String name = entry.getKey();
          for (Iterator<Pattern> it = patterns.iterator(); it.hasNext(); ) {
            Pattern p = it.next();
            if (p.matcher(name).matches()) {
              mCompressData.put(name, TypedValue.ZIP_DEFLATED);
            }
          }
        }
      }
    }
  }","config"
"1898","Field","patterns","None","None"
"1899","Field","name","None","None"
"1900","Field","p","None","None"
"1901","Method","getCompressData","public HashMap<String, Integer> getCompressData() {
    return mCompressData;
  }","None"
"1902","Method","getOutDir","public File getOutDir() {
    return mOutDir;
  }","None"
"1903","Method","setOutDir","public void setOutDir(File outDir) throws AndrolibException {
    mOutDir = outDir;
  }","None"
"1904","Field","outDir","None","None"
"1905","Method","getOutResFile","public File getOutResFile() {
    return mOutResFile;
  }","None"
"1906","Method","getRawResFile","public File getRawResFile() {
    return mRawResFile;
  }","None"
"1907","Method","getOutTempARSCFile","public File getOutTempARSCFile() {
    return mOutTempARSCFile;
  }","None"
"1908","Method","getOutARSCFile","public File getOutARSCFile() {
    return mOutARSCFile;
  }","None"
"1909","Method","getOutTempDir","public File getOutTempDir() {
    return mOutTempDir;
  }","None"
"1910","Method","getResMappingFile","public File getResMappingFile() {
    return mResMappingFile;
  }","None"
"1911","Method","getMergeDuplicatedResMappingFile","public File getMergeDuplicatedResMappingFile() {
    return mMergeDuplicatedResMappingFile;
  }","None"
"1912","Method","decode","public void decode() throws AndrolibException, IOException, DirectoryException {
    if (hasResources()) {
      ensureFilePath();
      // read the resources.arsc checking for STORED vs DEFLATE compression
      // this will determine whether we compress on rebuild or not.
      System.out.printf(""decoding resources.arsc\n"");
      RawARSCDecoder.decode(apkFile.getDirectory().getFileInput(""resources.arsc""));
      ResPackage[] pkgs = ARSCDecoder.decode(apkFile.getDirectory().getFileInput(""resources.arsc""), this);

      //把没有纪录在resources.arsc的资源文件也拷进dest目录
      copyOtherResFiles();

      ARSCDecoder.write(apkFile.getDirectory().getFileInput(""resources.arsc""), this, pkgs);
    }
  }","None"
"1913","Field","pkgs","None","None"
"1914","Class","ResourceFilesVisitor","ResourceFilesVisitor","None"
"1915","Field","file","None","None"
"1916","Field","attrs","None","None"
"1917","Method","visitFile","public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
      mRawResourceFiles.add(file);
      return FileVisitResult.CONTINUE;
    }","None"
"1918","Field","file","None","None"
"1919","Field","attrs","None","None"
"1920","Class","ResourceRepackage","ResourceRepackage","None"
"1921","Field","zipalignPath","None","None"
"1922","Field","sevenZipPath","None","None"
"1923","Field","mSignedApk","None","None"
"1924","Field","mSignedWith7ZipApk","None","None"
"1925","Field","mAlignedWith7ZipApk","None","None"
"1926","Field","m7zipOutPutDir","None","None"
"1927","Field","mStoredOutPutDir","None","None"
"1928","Field","mApkName","None","None"
"1929","Field","mOutDir","None","None"
"1930","Field","zipalignPath","None","None"
"1931","Field","zipPath","None","None"
"1932","Field","signedFile","None","None"
"1933","Field","outDir","None","None"
"1934","Field","apkBasename","None","None"
"1935","Field","compressData","None","None"
"1936","Field","storedFiles","None","None"
"1937","Field","file","None","None"
"1938","Field","method","None","None"
"1939","Field","outPath","None","None"
"1940","Field","path","None","None"
"1941","Field","cmd","None","None"
"1942","Field","pb","None","None"
"1943","Field","pro","None","None"
"1944","Field","ir","None","None"
"1945","Field","input","None","None"
"1946","Field","storedFiles","None","None"
"1947","Field","storedParentName","None","None"
"1948","Field","outputName","None","None"
"1949","Field","cmd","None","None"
"1950","Field","pb","None","None"
"1951","Field","pro","None","None"
"1952","Field","ir","None","None"
"1953","Field","input","None","None"
"1954","Field","before","None","None"
"1955","Field","after","None","None"
"1956","Field","cmd","None","None"
"1957","Field","pb","None","None"
"1958","Field","pro","None","None"
"1959","Method","setOutDir","public void setOutDir(File outDir) {
    mOutDir = outDir;
  }","None"
"1960","Field","outDir","None","None"
"1961","Method","repackageApk","public void repackageApk() throws IOException, InterruptedException {
    insureFileName();

    repackageWith7z();
    alignApk();
    deleteUnusedFiles();
  }","None"
"1962","Method","deleteUnusedFiles","private void deleteUnusedFiles() {
    //删除目录
    FileOperation.deleteDir(m7zipOutPutDir);
    FileOperation.deleteDir(mStoredOutPutDir);
    if (mSignedWith7ZipApk.exists()) {
      mSignedWith7ZipApk.delete();
    }
  }","None"
"1963","Method","insureFileName","private void insureFileName() throws IOException {
    if (!mSignedApk.exists()) {
      throw new IOException(String.format(""can not found the signed apk file to repackage"" + "", path=%s"",
          mSignedApk.getAbsolutePath()
      ));
    }
    //需要自己安装7zip
    String apkBasename = mSignedApk.getName();
    mApkName = apkBasename.substring(0, apkBasename.indexOf("".apk""));
    //如果外面设过，就不用设了
    if (mOutDir == null) {
      mOutDir = new File(mSignedApk.getAbsoluteFile().getParent(), mApkName);
    }

    mSignedWith7ZipApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_channel_7zip.apk"");
    mAlignedWith7ZipApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_channel_7zip_aligned.apk"");

    m7zipOutPutDir = new File(mOutDir.getAbsolutePath(), TypedValue.OUT_7ZIP_FILE_PATH);
    mStoredOutPutDir = new File(mOutDir.getAbsolutePath(), ""storefiles"");
    //删除目录,因为之前的方法是把整个输出目录都删除，所以不会有问题，现在不会，所以要单独删
    FileOperation.deleteDir(m7zipOutPutDir);
    FileOperation.deleteDir(mStoredOutPutDir);
    FileOperation.deleteDir(mSignedWith7ZipApk);
    FileOperation.deleteDir(mAlignedWith7ZipApk);
  }","，"
"1964","Field","apkBasename","None","None"
"1965","Method","repackageWith7z","private void repackageWith7z() throws IOException, InterruptedException {
    System.out.printf(""use 7zip to repackage: %s, will cost much more time\n"", mSignedWith7ZipApk.getName());
    HashMap<String, Integer> compressData = FileOperation.unZipAPk(mSignedApk.getAbsolutePath(),
        m7zipOutPutDir.getAbsolutePath()
    );
    //首先一次性生成一个全部都是压缩的安装包
    generalRaw7zip();
    ArrayList<String> storedFiles = new ArrayList<>();
    //对于不压缩的要update回去
    for (String name : compressData.keySet()) {
      File file = new File(m7zipOutPutDir.getAbsolutePath(), name);
      if (!file.exists()) {
        continue;
      }
      int method = compressData.get(name);
      if (method == TypedValue.ZIP_STORED) {
        storedFiles.add(name);
      }
    }

    addStoredFileIn7Zip(storedFiles);
    if (!mSignedWith7ZipApk.exists()) {
      throw new IOException(String.format(
          ""[repackageWith7z]7z repackage signed apk fail,you must install 7z command line version first, linux: p7zip, window: 7za, path=%s"",
          mSignedWith7ZipApk.getAbsolutePath()
      ));
    }
  }","None"
"1966","Field","compressData","None","None"
"1967","Field","storedFiles","None","None"
"1968","Field","file","None","None"
"1969","Field","method","None","None"
"1970","Method","generalRaw7zip","private void generalRaw7zip() throws IOException, InterruptedException {
    System.out.printf(""general the raw 7zip file\n"");
    String outPath = m7zipOutPutDir.getAbsoluteFile().getAbsolutePath();
    String path = outPath + File.separator + ""*"";

    String cmd = Utils.isPresent(sevenZipPath) ? sevenZipPath : TypedValue.COMMAND_7ZIP;
    ProcessBuilder pb = new ProcessBuilder(cmd, ""a"", ""-tzip"", mSignedWith7ZipApk.getAbsolutePath(), path, ""-mx9"");
    Process pro = pb.start();

    InputStreamReader ir = new InputStreamReader(pro.getInputStream());
    LineNumberReader input = new LineNumberReader(ir);
    //如果不读会有问题，被阻塞
    while (input.readLine() != null) {
    }
    //destroy the stream
    pro.waitFor();
    pro.destroy();
  }","None"
"1971","Field","outPath","None","None"
"1972","Field","path","None","None"
"1973","Field","cmd","None","None"
"1974","Field","pb","None","None"
"1975","Field","pro","None","None"
"1976","Field","ir","None","None"
"1977","Field","input","None","None"
"1978","Method","addStoredFileIn7Zip","private void addStoredFileIn7Zip(ArrayList<String> storedFiles) throws IOException, InterruptedException {
    System.out.printf(""[addStoredFileIn7Zip]rewrite the stored file into the 7zip, file count:%d\n"",
        storedFiles.size()
    );
    String storedParentName = mStoredOutPutDir.getAbsolutePath() + File.separator;
    String outputName = m7zipOutPutDir.getAbsolutePath() + File.separator;
    for (String name : storedFiles) {
      FileOperation.copyFileUsingStream(new File(outputName + name), new File(storedParentName + name));
    }
    storedParentName = storedParentName + File.separator + ""*"";
    //极限压缩
    String cmd = Utils.isPresent(sevenZipPath) ? sevenZipPath : TypedValue.COMMAND_7ZIP;
    ProcessBuilder pb = new ProcessBuilder(cmd,
        ""a"",
        ""-tzip"",
        mSignedWith7ZipApk.getAbsolutePath(),
        storedParentName,
        ""-mx0""
    );
    Process pro = pb.start();

    InputStreamReader ir = new InputStreamReader(pro.getInputStream());
    LineNumberReader input = new LineNumberReader(ir);
    //如果不读会有问题，被阻塞
    while (input.readLine() != null) {
    }
    //destroy the stream
    pro.waitFor();
    pro.destroy();
  }","None"
"1979","Field","storedFiles","None","None"
"1980","Field","storedParentName","None","None"
"1981","Field","outputName","None","None"
"1982","Field","cmd","None","None"
"1983","Field","pb","None","None"
"1984","Field","pro","None","None"
"1985","Field","ir","None","None"
"1986","Field","input","None","None"
"1987","Method","alignApk","private void alignApk() throws IOException, InterruptedException {
    if (mSignedWith7ZipApk.exists()) {
      alignApk(mSignedWith7ZipApk, mAlignedWith7ZipApk);
    }
  }","None"
"1988","Method","alignApk","private void alignApk(File before, File after) throws IOException, InterruptedException {
    System.out.printf(""zipaligning apk: %s\n"", before.getName());
    if (!before.exists()) {
      throw new IOException(String.format(""can not found the raw apk file to zipalign, path=%s"",
          before.getAbsolutePath()
      ));
    }
    String cmd = Utils.isPresent(zipalignPath) ? zipalignPath : TypedValue.COMMAND_ZIPALIGIN;
    ProcessBuilder pb = new ProcessBuilder(cmd, ""4"", before.getAbsolutePath(), after.getAbsolutePath());
    Process pro = pb.start();
    //destroy the stream
    pro.waitFor();
    pro.destroy();
  }","None"
"1989","Field","before","None","None"
"1990","Field","after","None","None"
"1991","Field","cmd","None","None"
"1992","Field","pb","None","None"
"1993","Field","pro","None","None"
"1994","Class","AndrolibException","AndrolibException","None"
"1995","Field","message","None","None"
"1996","Field","message","None","None"
"1997","Field","cause","None","None"
"1998","Field","cause","None","None"
"1999","Class","ResourceApkBuilder","ResourceApkBuilder","None"
"2000","Field","config","None","None"
"2001","Field","mOutDir","None","None"
"2002","Field","m7zipOutPutDir","None","None"
"2003","Field","mUnSignedApk","None","None"
"2004","Field","mSignedApk","None","None"
"2005","Field","mSignedWith7ZipApk","None","None"
"2006","Field","m7ZipApk","None","None"
"2007","Field","mAlignedApk","None","None"
"2008","Field","mAlignedWith7ZipApk","None","None"
"2009","Field","mApkName","None","None"
"2010","Field","finalApkFile","None","None"
"2011","Field","config","None","None"
"2012","Field","outDir","None","None"
"2013","Field","apkName","None","None"
"2014","Field","finalApkFile","None","None"
"2015","Field","compressData","None","None"
"2016","Field","compressData","None","None"
"2017","Field","minSDKVersion","None","None"
"2018","Field","signatureType","None","None"
"2019","Field","compressData","None","None"
"2020","Field","originalAPK","None","None"
"2021","Field","outputAPK","None","None"
"2022","Field","storedFiles","None","None"
"2023","Field","file","None","None"
"2024","Field","method","None","None"
"2025","Field","hash","None","None"
"2026","Field","signatureAlgorithm","None","None"
"2027","Field","keyStore","None","None"
"2028","Field","fileIn","None","None"
"2029","Field","key","None","None"
"2030","Field","keyAlgorithm","None","None"
"2031","Field","hash","None","None"
"2032","Field","unSignedApk","None","None"
"2033","Field","signedApk","None","None"
"2034","Field","unSignedApk","None","None"
"2035","Field","signedApk","None","None"
"2036","Field","minSDKVersion","None","None"
"2037","Field","signatureType","None","None"
"2038","Field","unSignedApk","None","None"
"2039","Field","signedApk","None","None"
"2040","Field","minSDKVersion","None","None"
"2041","Field","signatureType","None","None"
"2042","Field","params","None","None"
"2043","Field","unSignedApk","None","None"
"2044","Field","signedApk","None","None"
"2045","Field","signatureAlgorithm","None","None"
"2046","Field","argv","None","None"
"2047","Field","before","None","None"
"2048","Field","after","None","None"
"2049","Field","cmd","None","None"
"2050","Field","compressData","None","None"
"2051","Field","tempOutDir","None","None"
"2052","Field","unzipFiles","None","None"
"2053","Field","collectFiles","None","None"
"2054","Field","name","None","None"
"2055","Field","destResDir","None","None"
"2056","Field","rawResDir","None","None"
"2057","Field","rawARSCFile","None","None"
"2058","Field","collectFiles","None","None"
"2059","Field","metaFolder","None","None"
"2060","Field","metaFiles","None","None"
"2061","Field","metaFileName","None","None"
"2062","Field","storedFiles","None","None"
"2063","Field","outSevenZipAPK","None","None"
"2064","Field","storedParentName","None","None"
"2065","Field","outputName","None","None"
"2066","Field","cmd","None","None"
"2067","Field","outSevenZipApk","None","None"
"2068","Field","outPath","None","None"
"2069","Field","path","None","None"
"2070","Field","cmd","None","None"
"2071","Method","setOutDir","public void setOutDir(File outDir, String apkName, File finalApkFile) throws AndrolibException {
    this.mOutDir = outDir;
    this.mApkName = apkName;
    this.finalApkFile = finalApkFile;
  }","None"
"2072","Field","outDir","None","None"
"2073","Field","apkName","None","None"
"2074","Field","finalApkFile","None","None"
"2075","Method","buildApkWithV1sign","public void buildApkWithV1sign(HashMap<String, Integer> compressData) throws IOException, InterruptedException {
    insureFileNameV1();
    generalUnsignApk(compressData);
    signApkV1(mUnSignedApk, mSignedApk);
    use7zApk(compressData, mSignedApk, mSignedWith7ZipApk);
    alignApks();
    copyFinalApkV1();
  }","None"
"2076","Field","compressData","None","None"
"2077","Method","copyFinalApkV1","private void copyFinalApkV1() throws IOException {
    if (finalApkFile != null) {
      System.out.println(String.format(""Backup Final APk(V1) to %s"", finalApkFile));
      if (mSignedWith7ZipApk.exists()) {
        FileOperation.copyFileUsingStream(mAlignedWith7ZipApk, finalApkFile);
      } else if (mSignedApk.exists()) {
        FileOperation.copyFileUsingStream(mAlignedApk, finalApkFile);
      }
    }
  }","None"
"2078","Method","buildApkWithV2V3Sign","public void buildApkWithV2V3Sign(HashMap<String, Integer> compressData, int minSDKVersion, InputParam.SignatureType signatureType) throws Exception {
    insureFileNameV2();
    generalUnsignApk(compressData);
    if (use7zApk(compressData, mUnSignedApk, m7ZipApk)) {
      alignApk(m7ZipApk, mAlignedApk);
    } else {
      alignApk(mUnSignedApk, mAlignedApk);
    }

    /*
     * Caution: If you sign your app using APK Signature Scheme v2 and make further changes to the app,
     * the app's signature is invalidated.
     * For this reason, use tools such as zipalign before signing your app using APK Signature Scheme v2, not after.
     **/
    signApkV2V3(mAlignedApk, mSignedApk, minSDKVersion, signatureType);
    copyFinalApkV2();
  }","None"
"2079","Field","compressData","None","None"
"2080","Field","minSDKVersion","None","None"
"2081","Field","signatureType","None","None"
"2082","Method","copyFinalApkV2","private void copyFinalApkV2() throws IOException {
    if (mSignedApk.exists() && finalApkFile != null) {
      System.out.println(String.format(""Backup Final APk(V2) to %s"", finalApkFile));
      FileOperation.copyFileUsingStream(mSignedApk, finalApkFile);
    }
  }","None"
"2083","Method","insureFileNameV1","private void insureFileNameV1() {
    mUnSignedApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_unsigned.apk"");
    mSignedWith7ZipApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_signed_7zip.apk"");
    mSignedApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_signed.apk"");
    mAlignedApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_signed_aligned.apk"");
    mAlignedWith7ZipApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_signed_7zip_aligned.apk"");
    m7zipOutPutDir = new File(mOutDir.getAbsolutePath(), TypedValue.OUT_7ZIP_FILE_PATH);
  }","None"
"2084","Method","insureFileNameV2","private void insureFileNameV2() {
    mUnSignedApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_unsigned.apk"");
    m7ZipApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_7zip_unsigned.apk"");
    if (config.mUse7zip) {
      mAlignedApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_7zip_aligned_unsigned.apk"");
      mSignedApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_7zip_aligned_signed.apk"");
    } else {
      mAlignedApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_aligned_unsigned.apk"");
      mSignedApk = new File(mOutDir.getAbsolutePath(), mApkName + ""_aligned_signed.apk"");
    }
    m7zipOutPutDir = new File(mOutDir.getAbsolutePath(), TypedValue.OUT_7ZIP_FILE_PATH);
  }","None"
"2085","Method","use7zApk","private boolean use7zApk(HashMap<String, Integer> compressData, File originalAPK, File outputAPK)
      throws IOException, InterruptedException {
    if (!config.mUse7zip) {
      return false;
    }
    if (!config.mUseSignAPK) {
      throw new IOException(""if you want to use 7z, you must enable useSign in the config file first"");
    }
    if (!originalAPK.exists()) {
      throw new IOException(String.format(""can not found the signed apk file to 7z, if you want to use 7z, ""
                                          + ""you must fill the sign data in the config file path=%s"",
          originalAPK.getAbsolutePath()
      ));
    }
    System.out.printf(""use 7zip to repackage: %s, will cost much more time\n"", outputAPK.getName());
    FileOperation.unZipAPk(originalAPK.getAbsolutePath(), m7zipOutPutDir.getAbsolutePath());
    //首先一次性生成一个全部都是压缩的安装包
    generalRaw7zip(outputAPK);

    ArrayList<String> storedFiles = new ArrayList<>();
    //对于不压缩的要update回去
    for (String name : compressData.keySet()) {
      File file = new File(m7zipOutPutDir.getAbsolutePath(), name);
      if (!file.exists()) {
        continue;
      }
      int method = compressData.get(name);
      if (method == TypedValue.ZIP_STORED) {
        storedFiles.add(name);
      }
    }

    addStoredFileIn7Zip(storedFiles, outputAPK);
    if (!outputAPK.exists()) {
      throw new IOException(String.format(
          ""[use7zApk]7z repackage signed apk fail,you must install 7z command line version first, linux: p7zip, window: 7za, path=%s"",
          mSignedWith7ZipApk.getAbsolutePath()
      ));
    }
    return true;
  }","None"
"2086","Field","compressData","None","None"
"2087","Field","originalAPK","None","None"
"2088","Field","outputAPK","None","None"
"2089","Field","storedFiles","None","None"
"2090","Field","file","None","None"
"2091","Field","method","None","None"
"2092","Method","getSignatureAlgorithm","private String getSignatureAlgorithm(String hash) throws Exception {
    String signatureAlgorithm;
    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
    FileInputStream fileIn = new FileInputStream(config.mSignatureFile);
    keyStore.load(fileIn, config.mStorePass.toCharArray());
    Key key = keyStore.getKey(config.mStoreAlias, config.mKeyPass.toCharArray());
    if (key == null) {
      throw new RuntimeException(""Can't get private key, please check if storepass storealias and keypass are correct"");
    }
    String keyAlgorithm = key.getAlgorithm();
    hash = formatHashAlgorithName(hash);
    if (keyAlgorithm.equalsIgnoreCase(""DSA"")) {
      keyAlgorithm = ""DSA"";
    } else if (keyAlgorithm.equalsIgnoreCase(""RSA"")) {
      keyAlgorithm = ""RSA"";
    } else if (keyAlgorithm.equalsIgnoreCase(""EC"")) {
      keyAlgorithm = ""ECDSA"";
    } else {
      throw new RuntimeException(""private key is not a DSA or RSA key"");
    }
    signatureAlgorithm = String.format(""%swith%s"", hash, keyAlgorithm);
    return signatureAlgorithm;
  }","None"
"2093","Field","hash","None","None"
"2094","Field","signatureAlgorithm","None","None"
"2095","Field","keyStore","None","None"
"2096","Field","fileIn","None","None"
"2097","Field","key","None","None"
"2098","Field","keyAlgorithm","None","None"
"2099","Method","formatHashAlgorithName","private String formatHashAlgorithName(String hash) {
    return hash.replace(""-"", """");
  }","None"
"2100","Field","hash","None","None"
"2101","Method","signApkV1","private void signApkV1(File unSignedApk, File signedApk) throws IOException, InterruptedException {
    if (config.mUseSignAPK) {
      System.out.printf(""signing apk: %s\n"", signedApk.getName());
      if (signedApk.exists()) {
        signedApk.delete();
      }
      signWithV1sign(unSignedApk, signedApk);
      if (!signedApk.exists()) {
        throw new IOException(""Can't Generate signed APK. Plz check your v1sign info is correct."");
      }
    }
  }","None"
"2102","Field","unSignedApk","None","None"
"2103","Field","signedApk","None","None"
"2104","Method","signApkV2V3","private void signApkV2V3(File unSignedApk, File signedApk, int minSDKVersion, InputParam.SignatureType signatureType) throws Exception {
    if (config.mUseSignAPK) {
      System.out.printf(""signing apk: %s\n"", signedApk.getName());
      signWithV2V3Sign(unSignedApk, signedApk, minSDKVersion, signatureType);
      if (!signedApk.exists()) {
        throw new IOException(""Can't Generate signed APK v2. Plz check your v2sign info is correct."");
      }
    }
  }","None"
"2105","Field","unSignedApk","None","None"
"2106","Field","signedApk","None","None"
"2107","Field","minSDKVersion","None","None"
"2108","Field","signatureType","None","None"
"2109","Method","signWithV2V3Sign","private void signWithV2V3Sign(File unSignedApk, File signedApk, int minSDKVersion, InputParam.SignatureType signatureType) throws Exception {
    String[] params = new String[] {
        ""sign"",
        ""--ks"",
        config.mSignatureFile.getAbsolutePath(),
        ""--ks-pass"",
        ""pass:"" + config.mStorePass,
        ""--min-sdk-version"",
        String.valueOf(minSDKVersion),
        ""--ks-key-alias"",
        config.mStoreAlias,
        ""--key-pass"",
        ""pass:"" + config.mKeyPass,
        ""--v3-signing-enabled"",
        String.valueOf(signatureType == SchemaV3),
        ""--out"",
        signedApk.getAbsolutePath(),
        unSignedApk.getAbsolutePath()
    };
    ApkSignerTool.main(params);
  }","None"
"2110","Field","unSignedApk","None","None"
"2111","Field","signedApk","None","None"
"2112","Field","minSDKVersion","None","None"
"2113","Field","signatureType","None","None"
"2114","Field","params","None","None"
"2115","Method","signWithV1sign","private void signWithV1sign(File unSignedApk, File signedApk) throws IOException, InterruptedException {
    String signatureAlgorithm = ""MD5withRSA"";
    try {
      signatureAlgorithm = getSignatureAlgorithm(config.digestAlg);
    } catch (Exception e) {
      e.printStackTrace();
    }
    String[] argv = {
        ""jarsigner"",
        ""-sigalg"",
        signatureAlgorithm,
        ""-digestalg"",
        config.digestAlg,
        ""-keystore"",
        config.mSignatureFile.getAbsolutePath(),
        ""-storepass"",
        config.mStorePass,
        ""-keypass"",
        config.mKeyPass,
        ""-signedjar"",
        signedApk.getAbsolutePath(),
        unSignedApk.getAbsolutePath(),
        config.mStoreAlias
    };
    Utils.runExec(argv);
  }","None"
"2116","Field","unSignedApk","None","None"
"2117","Field","signedApk","None","None"
"2118","Field","signatureAlgorithm","None","None"
"2119","Field","argv","None","None"
"2120","Method","alignApks","private void alignApks() throws IOException, InterruptedException {
    //如果不签名就肯定不需要对齐了
    if (!config.mUseSignAPK) {
      return;
    }
    if (!mSignedApk.exists() && !mSignedWith7ZipApk.exists()) {
      throw new IOException(""Can not found any signed apk file"");
    }
    if (mSignedApk.exists()) {
      alignApk(mSignedApk, mAlignedApk);
    }
    if (mSignedWith7ZipApk.exists()) {
      alignApk(mSignedWith7ZipApk, mAlignedWith7ZipApk);
    }
  }","None"
"2121","Method","alignApk","private void alignApk(File before, File after) throws IOException, InterruptedException {
    System.out.printf(""zipaligning apk: %s, exists:%b\n"", before.getAbsolutePath(), before.exists());
    if (!before.exists()) {
      throw new IOException(String.format(""can not found the raw apk file to zipalign, path=%s"",
          before.getAbsolutePath()
      ));
    }
    String cmd = Utils.isPresent(config.mZipalignPath) ? config.mZipalignPath : TypedValue.COMMAND_ZIPALIGIN;
    Utils.runCmd(cmd, ""4"", before.getAbsolutePath(), after.getAbsolutePath());
    if (!after.exists()) {
      throw new IOException(String.format(""can not found the aligned apk file, the ZipAlign path is correct? path=%s"",
          mAlignedApk.getAbsolutePath()
      ));
    }
  }","None"
"2122","Field","before","None","None"
"2123","Field","after","None","None"
"2124","Field","cmd","None","None"
"2125","Method","generalUnsignApk","private void generalUnsignApk(HashMap<String, Integer> compressData) throws IOException, InterruptedException {
    System.out.printf(""General unsigned apk: %s\n"", mUnSignedApk.getName());
    File tempOutDir = new File(mOutDir.getAbsolutePath(), TypedValue.UNZIP_FILE_PATH);
    if (!tempOutDir.exists()) {
      System.err.printf(""Missing apk unzip files, path=%s\n"", tempOutDir.getAbsolutePath());
      System.exit(-1);
    }

    File[] unzipFiles = tempOutDir.listFiles();
    assert unzipFiles != null;
    List<File> collectFiles = new ArrayList<>();
    for (File f : unzipFiles) {
      String name = f.getName();
      if (name.equals(""res"") || name.equals(""resources.arsc"")) {
        continue;
      } else if (name.equals(config.mMetaName)) {
        addNonSignatureFiles(collectFiles, f);
        continue;
      }
      collectFiles.add(f);
    }

    File destResDir = new File(mOutDir.getAbsolutePath(), ""res"");
    //添加修改后的res文件
    if (!config.mKeepRoot && FileOperation.getlist(destResDir) == 0) {
      destResDir = new File(mOutDir.getAbsolutePath(), TypedValue.RES_FILE_PATH);
    }

    /*
     * NOTE:文件数量应该是一样的，如果不一样肯定有问题
     */
    File rawResDir = new File(tempOutDir.getAbsolutePath() + File.separator + ""res"");
    System.out.printf(""DestResDir %d rawResDir %d\n"",
        FileOperation.getlist(destResDir),
        FileOperation.getlist(rawResDir)
    );
    if (FileOperation.getlist(destResDir) != (FileOperation.getlist(rawResDir) - ARSCDecoder.mMergeDuplicatedResCount)) {
      throw new IOException(String.format(
          ""the file count of %s, and the file count of %s is not equal, there must be some problem\n"",
          rawResDir.getAbsolutePath(),
          destResDir.getAbsolutePath()
      ));
    }
    if (!destResDir.exists()) {
      System.err.printf(""Missing res files, path=%s\n"", destResDir.getAbsolutePath());
      System.exit(-1);
    }
    //这个需要检查混淆前混淆后，两个res的文件数量是否相等
    collectFiles.add(destResDir);
    File rawARSCFile = new File(mOutDir.getAbsolutePath() + File.separator + ""resources.arsc"");
    if (!rawARSCFile.exists()) {
      System.err.printf(""Missing resources.arsc files, path=%s\n"", rawARSCFile.getAbsolutePath());
      System.exit(-1);
    }
    collectFiles.add(rawARSCFile);
    FileOperation.zipFiles(collectFiles, tempOutDir, mUnSignedApk, compressData);

    if (!mUnSignedApk.exists()) {
      throw new IOException(String.format(""can not found the unsign apk file path=%s"", mUnSignedApk.getAbsolutePath()));
    }
  }","None"
"2126","Field","compressData","None","None"
"2127","Field","tempOutDir","None","None"
"2128","Field","unzipFiles","None","None"
"2129","Field","collectFiles","None","None"
"2130","Field","name","None","None"
"2131","Field","destResDir","None","None"
"2132","Field","rawResDir","None","None"
"2133","Field","rawARSCFile","None","None"
"2134","Method","addNonSignatureFiles","private void addNonSignatureFiles(List<File> collectFiles, File metaFolder) {
    File[] metaFiles = metaFolder.listFiles();
    if (metaFiles != null) {
      for (File metaFile : metaFiles) {
        String metaFileName = metaFile.getName();
        // Ignore signature files
        if (!metaFileName.endsWith("".MF"") && !metaFileName.endsWith("".RSA"") && !metaFileName.endsWith("".SF"")) {
          System.out.println(String.format(""add meta file %s"", metaFile.getAbsolutePath()));
          collectFiles.add(metaFile);
        }
      }
    }
  }","None"
"2135","Field","collectFiles","None","None"
"2136","Field","metaFolder","None","None"
"2137","Field","metaFiles","None","None"
"2138","Field","metaFileName","None","None"
"2139","Method","addStoredFileIn7Zip","private void addStoredFileIn7Zip(ArrayList<String> storedFiles, File outSevenZipAPK)
      throws IOException, InterruptedException {
    System.out.printf(""[addStoredFileIn7Zip]rewrite the stored file into the 7zip, file count: %d\n"",
        storedFiles.size()
    );
    if (storedFiles.size() == 0) return;
    String storedParentName = mOutDir.getAbsolutePath() + File.separator + ""storefiles"" + File.separator;
    String outputName = m7zipOutPutDir.getAbsolutePath() + File.separator;
    for (String name : storedFiles) {
      FileOperation.copyFileUsingStream(new File(outputName + name), new File(storedParentName + name));
    }
    storedParentName = storedParentName + File.separator + ""*"";
    String cmd = Utils.isPresent(config.m7zipPath) ? config.m7zipPath : TypedValue.COMMAND_7ZIP;
    Utils.runCmd(cmd, ""a"", ""-tzip"", outSevenZipAPK.getAbsolutePath(), storedParentName, ""-mx0"");
  }","None"
"2140","Field","storedFiles","None","None"
"2141","Field","outSevenZipAPK","None","None"
"2142","Field","storedParentName","None","None"
"2143","Field","outputName","None","None"
"2144","Field","cmd","None","None"
"2145","Method","generalRaw7zip","private void generalRaw7zip(File outSevenZipApk) throws IOException, InterruptedException {
    String outPath = m7zipOutPutDir.getAbsoluteFile().getAbsolutePath();
    String path = outPath + File.separator + ""*"";
    String cmd = Utils.isPresent(config.m7zipPath) ? config.m7zipPath : TypedValue.COMMAND_7ZIP;
    Utils.runCmd(cmd, ""a"", ""-tzip"", outSevenZipApk.getAbsolutePath(), path, ""-mx9"");
  }","None"
"2146","Field","outSevenZipApk","None","None"
"2147","Field","outPath","None","None"
"2148","Field","path","None","None"
"2149","Field","cmd","None","None"
"2150","Package","com.tencent.mm.androlib.res.util","com.tencent.mm.androlib.res.util","None"
"2151","Class","StringUtil","StringUtil","None"
"2152","Field","string","None","None"
"2153","Field","string","None","None"
"2154","Field","inputStream","None","None"
"2155","Field","result","None","None"
"2156","Field","buffer","None","None"
"2157","Field","length","None","None"
"2158","Method","isPresent","public static boolean isPresent(final String string) {
    return string != null && string.length() > 0;
  }","None"
"2159","Field","string","None","None"
"2160","Method","isBlank","public static boolean isBlank(final String string) {
    return !isPresent(string);
  }","None"
"2161","Field","string","None","None"
"2162","Method","readInputStream","public static String readInputStream(InputStream inputStream) throws IOException {
    ByteArrayOutputStream result = new ByteArrayOutputStream();
    byte[] buffer = new byte[4096];
    int length;
    while ((length = inputStream.read(buffer)) != -1) {
      result.write(buffer, 0, length);
    }
    return result.toString(""UTF-8"");
  }","None"
"2163","Field","inputStream","None","None"
"2164","Field","result","None","None"
"2165","Field","buffer","None","None"
"2166","Field","length","None","None"
"2167","Class","ExtFile","ExtFile","None"
"2168","Field","mDirectory","None","None"
"2169","Field","file","None","None"
"2170","Field","uri","None","None"
"2171","Field","parent","None","None"
"2172","Field","child","None","None"
"2173","Field","parent","None","None"
"2174","Field","child","None","None"
"2175","Field","pathname","None","None"
"2176","Method","getDirectory","public Directory getDirectory() throws DirectoryException {
    if (mDirectory == null) {
      if (isDirectory()) {
        mDirectory = new FileDirectory(this);
      } else {
        mDirectory = new ZipRODirectory(this);
      }
    }
    return mDirectory;
  }","None"
"2177","Package","com.tencent.mm.androlib.res.decoder","com.tencent.mm.androlib.res.decoder","None"
"2178","Class","ARSCDecoder","ARSCDecoder","None"
"2179","Field","DEBUG","None","None"
"2180","Field","ENTRY_FLAG_COMPLEX","None","None"
"2181","Field","LOGGER","None","None"
"2182","Field","KNOWN_CONFIG_BYTES","None","None"
"2183","Field","mTableStringsResguard","None","None"
"2184","Field","mMergeDuplicatedResCount","None","None"
"2185","Field","mOldFileName","None","None"
"2186","Field","mCurSpecNameToPos","None","None"
"2187","Field","mShouldResguardTypeSet","None","None"
"2188","Field","mApkDecoder","None","None"
"2189","Field","mIn","None","None"
"2190","Field","mOut","None","None"
"2191","Field","mHeader","None","None"
"2192","Field","mTableStrings","None","None"
"2193","Field","mTypeNames","None","None"
"2194","Field","mSpecNames","None","None"
"2195","Field","mPkg","None","None"
"2196","Field","mType","None","None"
"2197","Field","mPkgs","None","None"
"2198","Field","mPkgsLenghtChange","None","None"
"2199","Field","mTableLenghtChange","None","None"
"2200","Field","mResId","None","None"
"2201","Field","mCurrTypeID","None","None"
"2202","Field","mCurEntryID","None","None"
"2203","Field","mCurPackageID","None","None"
"2204","Field","mMergeDuplicatedResTotalSize","None","None"
"2205","Field","mResguardBuilder","None","None"
"2206","Field","mShouldResguardForType","None","None"
"2207","Field","mMappingWriter","None","None"
"2208","Field","mMergeDuplicatedResMappingWriter","None","None"
"2209","Field","mMergeDuplicatedResInfoData","None","None"
"2210","Field","arscStream","None","None"
"2211","Field","decoder","None","None"
"2212","Field","arscStream","None","None"
"2213","Field","decoder","None","None"
"2214","Field","pkgs","None","None"
"2215","Field","arscStream","None","None"
"2216","Field","apkDecoder","None","None"
"2217","Field","decoder","None","None"
"2218","Field","pkgs","None","None"
"2219","Field","arscStream","None","None"
"2220","Field","decoder","None","None"
"2221","Field","pkgs","None","None"
"2222","Field","writer","None","None"
"2223","Field","config","None","None"
"2224","Field","rawResFile","None","None"
"2225","Field","resFiles","None","None"
"2226","Field","raw","None","None"
"2227","Field","fileMapping","None","None"
"2228","Field","keepFileNames","None","None"
"2229","Field","resRoot","None","None"
"2230","Field","dot","None","None"
"2231","Field","raw","None","None"
"2232","Field","packageCount","None","None"
"2233","Field","packages","None","None"
"2234","Field","packageCount","None","None"
"2235","Field","packageName","None","None"
"2236","Field","typename","None","None"
"2237","Field","specName","None","None"
"2238","Field","replace","None","None"
"2239","Field","originalFile","None","None"
"2240","Field","original","None","None"
"2241","Field","replaceFile","None","None"
"2242","Field","replace","None","None"
"2243","Field","fileLen","None","None"
"2244","Field","count","None","None"
"2245","Field","totalSize","None","None"
"2246","Field","size","None","None"
"2247","Field","bytes","None","None"
"2248","Field","format","None","None"
"2249","Field","i","None","None"
"2250","Field","i","None","None"
"2251","Field","i","None","None"
"2252","Field","packageCount","None","None"
"2253","Field","id","None","None"
"2254","Field","name","None","None"
"2255","Field","id","None","None"
"2256","Field","specSizeChange","None","None"
"2257","Field","resMapping","None","None"
"2258","Field","packName","None","None"
"2259","Field","typeMaps","None","None"
"2260","Field","typeName","None","None"
"2261","Field","proguard","None","None"
"2262","Field","resType","None","None"
"2263","Field","packName","None","None"
"2264","Field","typeMaps","None","None"
"2265","Field","libraryCount","None","None"
"2266","Field","packageId","None","None"
"2267","Field","packageName","None","None"
"2268","Field","id","None","None"
"2269","Field","entryCount","None","None"
"2270","Field","resTypeId","None","None"
"2271","Field","whiteListPatterns","None","None"
"2272","Field","libraryCount","None","None"
"2273","Field","id","None","None"
"2274","Field","entryCount","None","None"
"2275","Field","entryOffsets","None","None"
"2276","Field","entryCount","None","None"
"2277","Field","entriesStart","None","None"
"2278","Field","entryOffsets","None","None"
"2279","Field","entryCount","None","None"
"2280","Field","entryOffsets","None","None"
"2281","Field","flags","None","None"
"2282","Field","specNamesId","None","None"
"2283","Field","config","None","None"
"2284","Field","isWhiteList","None","None"
"2285","Field","specNamesId","None","None"
"2286","Field","config","None","None"
"2287","Field","packName","None","None"
"2288","Field","typeMaps","None","None"
"2289","Field","typeName","None","None"
"2290","Field","specName","None","None"
"2291","Field","patterns","None","None"
"2292","Field","p","None","None"
"2293","Field","specNamesId","None","None"
"2294","Field","config","None","None"
"2295","Field","replaceString","None","None"
"2296","Field","keepMapping","None","None"
"2297","Field","packName","None","None"
"2298","Field","typeMaps","None","None"
"2299","Field","typeName","None","None"
"2300","Field","nameMap","None","None"
"2301","Field","specName","None","None"
"2302","Field","useFixedName","None","None"
"2303","Field","fixedName","None","None"
"2304","Field","flags","None","None"
"2305","Field","specNamesId","None","None"
"2306","Field","pkg","None","None"
"2307","Field","flags","None","None"
"2308","Field","specNamesId","None","None"
"2309","Field","parent","None","None"
"2310","Field","count","None","None"
"2311","Field","count","None","None"
"2312","Field","flags","None","None"
"2313","Field","specNamesId","None","None"
"2314","Field","type","None","None"
"2315","Field","data","None","None"
"2316","Field","raw","None","None"
"2317","Field","proguard","None","None"
"2318","Field","secondSlash","None","None"
"2319","Field","newFilePath","None","None"
"2320","Field","result","None","None"
"2321","Field","firstDot","None","None"
"2322","Field","compatibaleraw","None","None"
"2323","Field","compatibaleresult","None","None"
"2324","Field","resRawFile","None","None"
"2325","Field","resDestFile","None","None"
"2326","Field","filterInfo","None","None"
"2327","Field","mergeDuplicatedRes","None","None"
"2328","Field","compressData","None","None"
"2329","Field","resRawFile","None","None"
"2330","Field","resDestFile","None","None"
"2331","Field","compatibaleraw","None","None"
"2332","Field","result","None","None"
"2333","Field","filterInfo","None","None"
"2334","Field","mergeDuplicatedResInfoList","None","None"
"2335","Field","resRawFileMd5","None","None"
"2336","Field","info","None","None"
"2337","Field","type","None","None"
"2338","Field","data","None","None"
"2339","Field","size","None","None"
"2340","Field","read","None","None"
"2341","Field","isInvalid","None","None"
"2342","Field","mcc","None","None"
"2343","Field","mnc","None","None"
"2344","Field","language","None","None"
"2345","Field","country","None","None"
"2346","Field","orientation","None","None"
"2347","Field","touchscreen","None","None"
"2348","Field","density","None","None"
"2349","Field","keyboard","None","None"
"2350","Field","navigation","None","None"
"2351","Field","inputFlags","None","None"
"2352","Field","screenWidth","None","None"
"2353","Field","screenHeight","None","None"
"2354","Field","sdkVersion","None","None"
"2355","Field","screenLayout","None","None"
"2356","Field","uiMode","None","None"
"2357","Field","smallestScreenWidthDp","None","None"
"2358","Field","screenWidthDp","None","None"
"2359","Field","screenHeightDp","None","None"
"2360","Field","localeScript","None","None"
"2361","Field","localeVariant","None","None"
"2362","Field","screenLayout2","None","None"
"2363","Field","exceedingSize","None","None"
"2364","Field","buf","None","None"
"2365","Field","exceedingBI","None","None"
"2366","Field","length","None","None"
"2367","Field","string","None","None"
"2368","Field","ch","None","None"
"2369","Field","size","None","None"
"2370","Field","expectedType","None","None"
"2371","Field","expectedType","None","None"
"2372","Field","diffSize","None","None"
"2373","Field","expectedType","None","None"
"2374","Field","diffSize","None","None"
"2375","Field","name","None","None"
"2376","Field","TYPE_NONE","None","None"
"2377","Field","type","None","None"
"2378","Field","chunkSize","None","None"
"2379","Field","type","None","None"
"2380","Field","size","None","None"
"2381","Field","in","None","None"
"2382","Field","type","None","None"
"2383","Field","count","None","None"
"2384","Field","size","None","None"
"2385","Field","in","None","None"
"2386","Field","out","None","None"
"2387","Field","diffSize","None","None"
"2388","Field","type","None","None"
"2389","Field","size","None","None"
"2390","Field","count","None","None"
"2391","Field","offset","None","None"
"2392","Field","count","None","None"
"2393","Field","offset","None","None"
"2394","Field","count","None","None"
"2395","Field","fileName","None","None"
"2396","Field","filePath","None","None"
"2397","Field","originalName","None","None"
"2398","Field","md5","None","None"
"2399","Field","fileName","None","None"
"2400","Field","filePath","None","None"
"2401","Field","originalName","None","None"
"2402","Field","md5","None","None"
"2403","Field","fileName","None","None"
"2404","Field","filePath","None","None"
"2405","Field","originalName","None","None"
"2406","Field","md5","None","None"
"2407","Field","fileName","None","None"
"2408","Field","filePath","None","None"
"2409","Field","md5","None","None"
"2410","Field","originalName","None","None"
"2411","Field","mReplaceStringBuffer","None","None"
"2412","Field","mIsReplaced","None","None"
"2413","Field","mIsWhiteList","None","None"
"2414","Field","mAToZ","None","None"
"2415","Field","mAToAll","None","None"
"2416","Field","mFileNameBlackList","None","window CON, PRN, AUX, CLOCK$, NUL COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9 LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9"
"2417","Field","blacklistPatterns","None","None"
"2418","Field","str","None","None"
"2419","Field","first","None","None"
"2420","Field","str","None","None"
"2421","Field","first","None","None"
"2422","Field","second","None","None"
"2423","Field","third","None","None"
"2424","Field","str","None","None"
"2425","Field","collection","None","None"
"2426","Field","id","None","None"
"2427","Field","id","None","None"
"2428","Field","id","None","None"
"2429","Field","id","None","None"
"2430","Method","decode","public static ResPackage[] decode(InputStream arscStream, ApkDecoder apkDecoder) throws AndrolibException {
    try {
      ARSCDecoder decoder = new ARSCDecoder(arscStream, apkDecoder);
      ResPackage[] pkgs = decoder.readTable();
      return pkgs;
    } catch (IOException ex) {
      throw new AndrolibException(""Could not decode arsc file"", ex);
    }
  }","None"
"2431","Field","arscStream","None","None"
"2432","Field","apkDecoder","None","None"
"2433","Field","decoder","None","None"
"2434","Field","pkgs","None","None"
"2435","Method","write","public static void write(InputStream arscStream, ApkDecoder decoder, ResPackage[] pkgs) throws AndrolibException {
    try {
      ARSCDecoder writer = new ARSCDecoder(arscStream, decoder, pkgs);
      writer.writeTable();
    } catch (IOException ex) {
      throw new AndrolibException(""Could not decode arsc file"", ex);
    }
  }","None"
"2436","Field","arscStream","None","None"
"2437","Field","decoder","None","None"
"2438","Field","pkgs","None","None"
"2439","Field","writer","None","None"
"2440","Method","proguardFileName","private void proguardFileName() throws IOException, AndrolibException {
    mMappingWriter = new BufferedWriter(new FileWriter(mApkDecoder.getResMappingFile(), false));
    mMergeDuplicatedResMappingWriter = new BufferedWriter(new FileWriter(mApkDecoder.getMergeDuplicatedResMappingFile(), false));
    mMergeDuplicatedResMappingWriter.write(""res filter path mapping:\n"");
    mMergeDuplicatedResMappingWriter.flush();

    mResguardBuilder = new ResguardStringBuilder();
    mResguardBuilder.reset(null);

    final Configuration config = mApkDecoder.getConfig();

    File rawResFile = mApkDecoder.getRawResFile();

    File[] resFiles = rawResFile.listFiles();

    // 需要看看哪些类型是要混淆文件路径的
    for (File resFile : resFiles) {
      String raw = resFile.getName();
      if (raw.contains(""-"")) {
        raw = raw.substring(0, raw.indexOf(""-""));
      }
      mShouldResguardTypeSet.add(raw);
    }

    if (!config.mKeepRoot) {
      // 需要保持之前的命名方式
      if (config.mUseKeepMapping) {
        HashMap<String, String> fileMapping = config.mOldFileMapping;
        List<String> keepFileNames = new ArrayList<>();
        // 这里面为了兼容以前，也需要用以前的文件名前缀，即res混淆成什么
        String resRoot = TypedValue.RES_FILE_PATH;
        for (String name : fileMapping.values()) {
          int dot = name.indexOf(""/"");
          if (dot == -1) {
            throw new IOException(String.format(""the old mapping res file path should be like r/a, yours %s\n"", name));
          }
          resRoot = name.substring(0, dot);
          keepFileNames.add(name.substring(dot + 1));
        }
        // 去掉所有之前保留的命名，为了简单操作，mapping里面有的都去掉
        mResguardBuilder.removeStrings(keepFileNames);

        for (File resFile : resFiles) {
          String raw = ""res"" + ""/"" + resFile.getName();
          if (fileMapping.containsKey(raw)) {
            mOldFileName.put(raw, fileMapping.get(raw));
          } else {
            mOldFileName.put(raw, resRoot + ""/"" + mResguardBuilder.getReplaceString());
          }
        }
      } else {
        for (int i = 0; i < resFiles.length; i++) {
          // 这里也要用linux的分隔符,如果普通的话，就是r
          mOldFileName.put(""res"" + ""/"" + resFiles[i].getName(),
             TypedValue.RES_FILE_PATH + ""/"" + mResguardBuilder.getReplaceString()
          );
        }
      }
      generalFileResMapping();
    }

    Utils.cleanDir(mApkDecoder.getOutResFile());
  }","None"
"2441","Field","config","None","None"
"2442","Field","rawResFile","None","None"
"2443","Field","resFiles","None","None"
"2444","Field","raw","None","None"
"2445","Field","fileMapping","None","None"
"2446","Field","keepFileNames","None","None"
"2447","Field","resRoot","None","None"
"2448","Field","dot","None","None"
"2449","Field","raw","None","None"
"2450","Method","readTable","private ResPackage[] readTable() throws IOException, AndrolibException {
    nextChunkCheckType(Header.TYPE_TABLE);
    int packageCount = mIn.readInt();
    mTableStrings = StringBlock.read(mIn);
    ResPackage[] packages = new ResPackage[packageCount];
    nextChunk();
    for (int i = 0; i < packageCount; i++) {
      packages[i] = readPackage();
    }
    mMappingWriter.close();
    System.out.printf(""resources mapping file %s done\n"", mApkDecoder.getResMappingFile().getAbsolutePath());
    generalFilterEnd(mMergeDuplicatedResCount, mMergeDuplicatedResTotalSize);
    mMergeDuplicatedResMappingWriter.close();
    System.out.printf(""resources filter mapping file %s done\n"", mApkDecoder.getMergeDuplicatedResMappingFile().getAbsolutePath());
    return packages;
  }","None"
"2451","Field","packageCount","None","None"
"2452","Field","packages","None","None"
"2453","Method","writeTable","private void writeTable() throws IOException, AndrolibException {
    System.out.printf(""writing new resources.arsc \n"");
    mTableLenghtChange = 0;
    writeNextChunkCheck(Header.TYPE_TABLE, 0);
    int packageCount = mIn.readInt();
    mOut.writeInt(packageCount);

    mTableLenghtChange += StringBlock.writeTableNameStringBlock(mIn, mOut, mTableStringsResguard);
    writeNextChunk(0);
    if (packageCount != mPkgs.length) {
      throw new AndrolibException(String.format(""writeTable package count is different before %d, now %d"",
         mPkgs.length,
         packageCount
      ));
    }
    for (int i = 0; i < packageCount; i++) {
      mCurPackageID = i;
      writePackage();
    }
    // 最后需要把整个的size重写回去
    reWriteTable();
  }","None"
"2454","Field","packageCount","None","None"
"2455","Method","generalFileResMapping","private void generalFileResMapping() throws IOException {
    mMappingWriter.write(""res path mapping:\n"");
    for (String raw : mOldFileName.keySet()) {
      mMappingWriter.write(""    "" + raw + "" -> "" + mOldFileName.get(raw));
      mMappingWriter.write(""\n"");
    }
    mMappingWriter.write(""\n\n"");
    mMappingWriter.write(""res id mapping:\n"");
    mMappingWriter.flush();
  }","None"
"2456","Method","generalResIDMapping","private void generalResIDMapping(
     String packageName, String typename, String specName, String replace) throws IOException {
    mMappingWriter.write(""    ""
       + packageName
       + "".R.""
       + typename
       + "".""
       + specName
       + "" -> ""
       + packageName
       + "".R.""
       + typename
       + "".""
       + replace);
    mMappingWriter.write(""\n"");
    mMappingWriter.flush();
  }","None"
"2457","Field","packageName","None","None"
"2458","Field","typename","None","None"
"2459","Field","specName","None","None"
"2460","Field","replace","None","None"
"2461","Method","generalFilterResIDMapping","private void generalFilterResIDMapping(
     String originalFile, String original, String replaceFile, String replace, long fileLen) throws IOException {
    mMergeDuplicatedResMappingWriter.write(""    ""
       + originalFile
       + "" : ""
       + original
       + "" -> ""
       + replaceFile
       + "" : ""
       + replace
       + "" (size:""
       + getNetFileSizeDescription(fileLen)
       + "")"");
    mMergeDuplicatedResMappingWriter.write(""\n"");
    mMergeDuplicatedResMappingWriter.flush();
  }","None"
"2462","Field","originalFile","None","None"
"2463","Field","original","None","None"
"2464","Field","replaceFile","None","None"
"2465","Field","replace","None","None"
"2466","Field","fileLen","None","None"
"2467","Method","generalFilterEnd","private void generalFilterEnd(int count, long totalSize) throws IOException {
    mMergeDuplicatedResMappingWriter.write(
       ""removed: count("" + count
          + ""), totalSize("" + getNetFileSizeDescription(totalSize) + "")"");
    mMergeDuplicatedResMappingWriter.flush();
  }","None"
"2468","Field","count","None","None"
"2469","Field","totalSize","None","None"
"2470","Method","getNetFileSizeDescription","private static String getNetFileSizeDescription(long size) {
    StringBuilder bytes = new StringBuilder();
    DecimalFormat format = new DecimalFormat(""###.0"");
    if (size >= 1024 * 1024 * 1024) {
      double i = (size / (1024.0 * 1024.0 * 1024.0));
      bytes.append(format.format(i)).append(""GB"");
    } else if (size >= 1024 * 1024) {
      double i = (size / (1024.0 * 1024.0));
      bytes.append(format.format(i)).append(""MB"");
    } else if (size >= 1024) {
      double i = (size / (1024.0));
      bytes.append(format.format(i)).append(""KB"");
    } else {
      if (size <= 0) {
        bytes.append(""0B"");
      } else {
        bytes.append((int) size).append(""B"");
      }
    }
    return bytes.toString();
  }","None"
"2471","Field","size","None","None"
"2472","Field","bytes","None","None"
"2473","Field","format","None","None"
"2474","Field","i","None","None"
"2475","Field","i","None","None"
"2476","Field","i","None","None"
"2477","Method","reWriteTable","private void reWriteTable() throws AndrolibException, IOException {

    mIn = new ExtDataInput(new LEDataInputStream(new FileInputStream(mApkDecoder.getOutTempARSCFile())));
    mOut = new ExtDataOutput(new LEDataOutputStream(new FileOutputStream(mApkDecoder.getOutARSCFile(), false)));
    writeNextChunkCheck(Header.TYPE_TABLE, mTableLenghtChange);
    int packageCount = mIn.readInt();
    mOut.writeInt(packageCount);
    StringBlock.writeAll(mIn, mOut);

    for (int i = 0; i < packageCount; i++) {
      mCurPackageID = i;
      writeNextChunk(mPkgsLenghtChange[mCurPackageID]);
      mOut.writeBytes(mIn, mHeader.chunkSize - 8);
    }
    mApkDecoder.getOutTempARSCFile().delete();
  }","None"
"2478","Field","packageCount","None","None"
"2479","Method","readPackage","private ResPackage readPackage() throws IOException, AndrolibException {
    checkChunkType(Header.TYPE_PACKAGE);
    int id = (byte) mIn.readInt();
    String name = mIn.readNullEndedString(128, true);
    System.out.printf(""reading packagename %s\n"", name);

    /* typeNameStrings */
    mIn.skipInt();
    /* typeNameCount */
    mIn.skipInt();
    /* specNameStrings */
    mIn.skipInt();
    /* specNameCount */
    mIn.skipInt();
    mCurrTypeID = -1;
    mTypeNames = StringBlock.read(mIn);
    mSpecNames = StringBlock.read(mIn);
    mResId = id << 24;

    mPkg = new ResPackage(id, name);
    // 系统包名不混淆
    if (mPkg.getName().equals(""android"")) {
      mPkg.setCanResguard(false);
    } else {
      mPkg.setCanResguard(true);
    }
    nextChunk();
    while (mHeader.type == Header.TYPE_LIBRARY) {
      readLibraryType();
    }
    while (mHeader.type == Header.TYPE_SPEC_TYPE) {
      readTableTypeSpec();
    }
    return mPkg;
  }","None"
"2480","Field","id","None","None"
"2481","Field","name","None","None"
"2482","Method","writePackage","private void writePackage() throws IOException, AndrolibException {
    checkChunkType(Header.TYPE_PACKAGE);
    int id = (byte) mIn.readInt();
    mOut.writeInt(id);
    mResId = id << 24;
    //char_16的，一共256byte
    mOut.writeBytes(mIn, 256);
    /* typeNameStrings */
    mOut.writeInt(mIn.readInt());
    /* typeNameCount */
    mOut.writeInt(mIn.readInt());
    /* specNameStrings */
    mOut.writeInt(mIn.readInt());
    /* specNameCount */
    mOut.writeInt(mIn.readInt());
    StringBlock.writeAll(mIn, mOut);

    if (mPkgs[mCurPackageID].isCanResguard()) {
      int specSizeChange = StringBlock.writeSpecNameStringBlock(mIn,
         mOut,
         mPkgs[mCurPackageID].getSpecNamesBlock(),
         mCurSpecNameToPos
      );
      mPkgsLenghtChange[mCurPackageID] += specSizeChange;
      mTableLenghtChange += specSizeChange;
    } else {
      StringBlock.writeAll(mIn, mOut);
    }
    writeNextChunk(0);
    while (mHeader.type == Header.TYPE_LIBRARY) {
      writeLibraryType();
    }
    while (mHeader.type == Header.TYPE_SPEC_TYPE) {
      writeTableTypeSpec();
    }
  }","None"
"2483","Field","id","None","None"
"2484","Field","specSizeChange","None","None"
"2485","Method","reduceFromOldMappingFile","private void reduceFromOldMappingFile() {
    if (mPkg.isCanResguard()) {
      if (mApkDecoder.getConfig().mUseKeepMapping) {
        // 判断是否走keepmapping
        HashMap<String, HashMap<String, HashMap<String, String>>> resMapping = mApkDecoder.getConfig().mOldResMapping;
        String packName = mPkg.getName();
        if (resMapping.containsKey(packName)) {
          HashMap<String, HashMap<String, String>> typeMaps = resMapping.get(packName);
          String typeName = mType.getName();

          if (typeMaps.containsKey(typeName)) {
            HashMap<String, String> proguard = typeMaps.get(typeName);
            // 去掉所有之前保留的命名，为了简单操作，mapping里面有的都去掉
            mResguardBuilder.removeStrings(proguard.values());
          }
        }
      }
    }
  }","mapping，mapping"
"2486","Field","resMapping","None","None"
"2487","Field","packName","None","None"
"2488","Field","typeMaps","None","None"
"2489","Field","typeName","None","None"
"2490","Field","proguard","None","None"
"2491","Method","getWhiteList","private HashSet<Pattern> getWhiteList(String resType) {
    final String packName = mPkg.getName();
    if (mApkDecoder.getConfig().mWhiteList.containsKey(packName)) {
      if (mApkDecoder.getConfig().mUseWhiteList) {
        HashMap<String, HashSet<Pattern>> typeMaps = mApkDecoder.getConfig().mWhiteList.get(packName);
        return typeMaps.get(resType);
      }
    }
    return null;
  }","None"
"2492","Field","resType","None","None"
"2493","Field","packName","None","None"
"2494","Field","typeMaps","None","None"
"2495","Method","readLibraryType","private void readLibraryType() throws AndrolibException, IOException {
    checkChunkType(Header.TYPE_LIBRARY);
    int libraryCount = mIn.readInt();

    int packageId;
    String packageName;

    for (int i = 0; i < libraryCount; i++) {
      packageId = mIn.readInt();
      packageName = mIn.readNullEndedString(128, true);
      System.out.printf(""Decoding Shared Library (%s), pkgId: %d\n"", packageName, packageId);
    }

    while (nextChunk().type == Header.TYPE_TYPE) {
      readTableTypeSpec();
    }
  }","None"
"2496","Field","libraryCount","None","None"
"2497","Field","packageId","None","None"
"2498","Field","packageName","None","None"
"2499","Method","readTableTypeSpec","private void readTableTypeSpec() throws AndrolibException, IOException {
    checkChunkType(Header.TYPE_SPEC_TYPE);
    byte id = mIn.readByte();
    mIn.skipBytes(3);
    int entryCount = mIn.readInt();
    mType = new ResType(mTypeNames.getString(id - 1), mPkg);
    if (DEBUG) {
      System.out.printf(""[ReadTableType] type (%s) id: (%d) curr (%d)\n"", mType, id, mCurrTypeID);
    }
    // first meet a type of resource
    if (mCurrTypeID != id) {
      mCurrTypeID = id;
      initResGuardBuild(mCurrTypeID);
    }
    // 是否混淆文件路径
    mShouldResguardForType = isToResguardFile(mTypeNames.getString(id - 1));

    // 对，这里是用来描述差异性的！！！
    mIn.skipBytes(entryCount * 4);
    mResId = (0xff000000 & mResId) | id << 16;

    while (nextChunk().type == Header.TYPE_TYPE) {
      readConfig();
    }
  }","None"
"2500","Field","id","None","None"
"2501","Field","entryCount","None","None"
"2502","Method","initResGuardBuild","private void initResGuardBuild(int resTypeId) {
    // we need remove string from resguard candidate list if it exists in white list
    HashSet<Pattern> whiteListPatterns = getWhiteList(mType.getName());
    // init resguard builder
    mResguardBuilder.reset(whiteListPatterns);
    mResguardBuilder.removeStrings(RawARSCDecoder.getExistTypeSpecNameStrings(resTypeId));
    // 如果是保持mapping的话，需要去掉某部分已经用过的mapping
    reduceFromOldMappingFile();
  }","None"
"2503","Field","resTypeId","None","None"
"2504","Field","whiteListPatterns","None","None"
"2505","Method","writeLibraryType","private void writeLibraryType() throws AndrolibException, IOException {
    checkChunkType(Header.TYPE_LIBRARY);
    int libraryCount = mIn.readInt();
    mOut.writeInt(libraryCount);
    for (int i = 0; i < libraryCount; i++) {
      mOut.writeInt(mIn.readInt());/*packageId*/
      mOut.writeBytes(mIn, 256); /*packageName*/
    }
    writeNextChunk(0);
    while (mHeader.type == Header.TYPE_TYPE) {
      writeTableTypeSpec();
    }
  }","None"
"2506","Field","libraryCount","None","None"
"2507","Method","writeTableTypeSpec","private void writeTableTypeSpec() throws AndrolibException, IOException {
    checkChunkType(Header.TYPE_SPEC_TYPE);
    byte id = mIn.readByte();
    mOut.writeByte(id);
    mResId = (0xff000000 & mResId) | id << 16;
    mOut.writeBytes(mIn, 3);
    int entryCount = mIn.readInt();
    mOut.writeInt(entryCount);
    // 对，这里是用来描述差异性的！！！
    ///* flags */mIn.skipBytes(entryCount * 4);
    int[] entryOffsets = mIn.readIntArray(entryCount);
    mOut.writeIntArray(entryOffsets);

    while (writeNextChunk(0).type == Header.TYPE_TYPE) {
      writeConfig();
    }
  }","None"
"2508","Field","id","None","None"
"2509","Field","entryCount","None","None"
"2510","Field","entryOffsets","None","None"
"2511","Method","readConfig","private void readConfig() throws IOException, AndrolibException {
    checkChunkType(Header.TYPE_TYPE);
    /* typeId */
    mIn.skipInt();
    int entryCount = mIn.readInt();
    int entriesStart = mIn.readInt();
    readConfigFlags();
    int[] entryOffsets = mIn.readIntArray(entryCount);
    for (int i = 0; i < entryOffsets.length; i++) {
      mCurEntryID = i;
      if (entryOffsets[i] != -1) {
        mResId = (mResId & 0xffff0000) | i;
        readEntry();
      }
    }
  }","None"
"2512","Field","entryCount","None","None"
"2513","Field","entriesStart","None","None"
"2514","Field","entryOffsets","None","None"
"2515","Method","writeConfig","private void writeConfig() throws IOException, AndrolibException {
    checkChunkType(Header.TYPE_TYPE);
    /* typeId */
    mOut.writeInt(mIn.readInt());
    /* entryCount */
    int entryCount = mIn.readInt();
    mOut.writeInt(entryCount);
    /* entriesStart */
    mOut.writeInt(mIn.readInt());

    writeConfigFlags();
    int[] entryOffsets = mIn.readIntArray(entryCount);
    mOut.writeIntArray(entryOffsets);

    for (int i = 0; i < entryOffsets.length; i++) {
      if (entryOffsets[i] != -1) {
        mResId = (mResId & 0xffff0000) | i;
        writeEntry();
      }
    }
  }","None"
"2516","Field","entryCount","None","None"
"2517","Field","entryOffsets","None","None"
"2518","Method","readEntry","private void readEntry() throws IOException, AndrolibException {
    mIn.skipBytes(2);
    short flags = mIn.readShort();
    int specNamesId = mIn.readInt();

    if (mPkg.isCanResguard()) {
      // 混淆过或者已经添加到白名单的都不需要再处理了
      if (!mResguardBuilder.isReplaced(mCurEntryID) && !mResguardBuilder.isInWhiteList(mCurEntryID)) {
        Configuration config = mApkDecoder.getConfig();
        boolean isWhiteList = false;
        if (config.mUseWhiteList) {
          isWhiteList = dealWithWhiteList(specNamesId, config);
        }

        if (!isWhiteList) {
          dealWithNonWhiteList(specNamesId, config);
        }
      }
    }

    if ((flags & ENTRY_FLAG_COMPLEX) == 0) {
      readValue(true, specNamesId);
    } else {
      readComplexEntry(false, specNamesId);
    }
  }","None"
"2519","Field","flags","None","None"
"2520","Field","specNamesId","None","None"
"2521","Field","config","None","None"
"2522","Field","isWhiteList","None","None"
"2523","Method","dealWithWhiteList","private boolean dealWithWhiteList(int specNamesId, Configuration config) throws AndrolibException {
    String packName = mPkg.getName();
    if (config.mWhiteList.containsKey(packName)) {
      HashMap<String, HashSet<Pattern>> typeMaps = config.mWhiteList.get(packName);
      String typeName = mType.getName();
      if (typeMaps.containsKey(typeName)) {
        String specName = mSpecNames.get(specNamesId).toString();
        HashSet<Pattern> patterns = typeMaps.get(typeName);
        for (Iterator<Pattern> it = patterns.iterator(); it.hasNext(); ) {
          Pattern p = it.next();
          if (p.matcher(specName).matches()) {
            if (DEBUG) {
              System.out.printf(""[match] matcher %s ,typeName %s, specName :%s\n"", p.pattern(), typeName, specName);
            }
            mPkg.putSpecNamesReplace(mResId, specName);
            mPkg.putSpecNamesblock(specName, specName);
            mResguardBuilder.setInWhiteList(mCurEntryID);

            mType.putSpecResguardName(specName);
            return true;
          }
        }
      }
    }
    return false;
  }","deal with whitelist"
"2524","Field","specNamesId","None","None"
"2525","Field","config","None","None"
"2526","Field","packName","None","None"
"2527","Field","typeMaps","None","None"
"2528","Field","typeName","None","None"
"2529","Field","specName","None","None"
"2530","Field","patterns","None","None"
"2531","Field","p","None","None"
"2532","Method","dealWithNonWhiteList","private void dealWithNonWhiteList(int specNamesId, Configuration config) throws AndrolibException, IOException {
    String replaceString = null;
    boolean keepMapping = false;
    if (config.mUseKeepMapping) {
      String packName = mPkg.getName();
      if (config.mOldResMapping.containsKey(packName)) {
        HashMap<String, HashMap<String, String>> typeMaps = config.mOldResMapping.get(packName);
        String typeName = mType.getName();
        if (typeMaps.containsKey(typeName)) {
          HashMap<String, String> nameMap = typeMaps.get(typeName);
          String specName = mSpecNames.get(specNamesId).toString();
          if (nameMap.containsKey(specName)) {
            keepMapping = true;
            replaceString = nameMap.get(specName);
          }
        }
      }
    }

    if (!keepMapping) {
      replaceString = mResguardBuilder.getReplaceString();
    }

    mResguardBuilder.setInReplaceList(mCurEntryID);
    if (replaceString == null) {
      throw new AndrolibException(""readEntry replaceString == null"");
    }
    generalResIDMapping(mPkg.getName(), mType.getName(), mSpecNames.get(specNamesId).toString(), replaceString);
    mPkg.putSpecNamesReplace(mResId, replaceString);
    // arsc name列混淆成固定名字, 减少string pool大小
    boolean useFixedName = config.mFixedResName != null && config.mFixedResName.length() > 0;
    String fixedName = useFixedName ? config.mFixedResName : replaceString;
    mPkg.putSpecNamesblock(fixedName, replaceString);
    mType.putSpecResguardName(replaceString);
  }","None"
"2533","Field","specNamesId","None","None"
"2534","Field","config","None","None"
"2535","Field","replaceString","None","None"
"2536","Field","keepMapping","None","None"
"2537","Field","packName","None","None"
"2538","Field","typeMaps","None","None"
"2539","Field","typeName","None","None"
"2540","Field","nameMap","None","None"
"2541","Field","specName","None","None"
"2542","Field","useFixedName","None","None"
"2543","Field","fixedName","None","None"
"2544","Method","writeEntry","private void writeEntry() throws IOException, AndrolibException {
    /* size */
    mOut.writeBytes(mIn, 2);
    short flags = mIn.readShort();
    mOut.writeShort(flags);
    int specNamesId = mIn.readInt();
    ResPackage pkg = mPkgs[mCurPackageID];
    if (pkg.isCanResguard()) {
      specNamesId = mCurSpecNameToPos.get(pkg.getSpecRepplace(mResId));
      if (specNamesId < 0) {
        throw new AndrolibException(String.format(""writeEntry new specNamesId < 0 %d"", specNamesId));
      }
    }
    mOut.writeInt(specNamesId);

    if ((flags & ENTRY_FLAG_COMPLEX) == 0) {
      writeValue();
    } else {
      writeComplexEntry();
    }
  }","None"
"2545","Field","flags","None","None"
"2546","Field","specNamesId","None","None"
"2547","Field","pkg","None","None"
"2548","Method","readComplexEntry","private void readComplexEntry(boolean flags, int specNamesId) throws IOException, AndrolibException {
    int parent = mIn.readInt();
    int count = mIn.readInt();
    for (int i = 0; i < count; i++) {
      mIn.readInt();
      readValue(flags, specNamesId);
    }
  }","None"
"2549","Field","flags","None","None"
"2550","Field","specNamesId","None","None"
"2551","Field","parent","None","None"
"2552","Field","count","None","None"
"2553","Method","writeComplexEntry","private void writeComplexEntry() throws IOException, AndrolibException {
    mOut.writeInt(mIn.readInt());
    int count = mIn.readInt();
    mOut.writeInt(count);
    for (int i = 0; i < count; i++) {
      mOut.writeInt(mIn.readInt());
      writeValue();
    }
  }","None"
"2554","Field","count","None","None"
"2555","Method","readValue","private void readValue(boolean flags, int specNamesId) throws IOException, AndrolibException {
    /* size */
    mIn.skipCheckShort((short) 8);
    /* zero */
    mIn.skipCheckByte((byte) 0);
    byte type = mIn.readByte();
    int data = mIn.readInt();

    //这里面有几个限制，一对于string ,id, array我们是知道肯定不用改的，第二看要那个type是否对应有文件路径
    if (mPkg.isCanResguard()
       && flags
       && type == TypedValue.TYPE_STRING
       && mShouldResguardForType
       && mShouldResguardTypeSet.contains(mType.getName())) {
      if (mTableStringsResguard.get(data) == null) {
        String raw = mTableStrings.get(data).toString();
        if (StringUtil.isBlank(raw) || raw.equalsIgnoreCase(""null"")) return;

        String proguard = mPkg.getSpecRepplace(mResId);
        //这个要写死这个，因为resources.arsc里面就是用这个
        int secondSlash = raw.lastIndexOf(""/"");
        if (secondSlash == -1) {
          throw new AndrolibException(String.format(""can not find \\ or raw string in res path = %s"", raw));
        }

        String newFilePath = raw.substring(0, secondSlash);

        if (!mApkDecoder.getConfig().mKeepRoot) {
          newFilePath = mOldFileName.get(raw.substring(0, secondSlash));
        }
        if (newFilePath == null) {
          System.err.printf(""can not found new res path, raw=%s\n"", raw);
          return;
        }
        //同理这里不能用File.separator，因为resources.arsc里面就是用这个
        String result = newFilePath + ""/"" + proguard;
        int firstDot = raw.indexOf(""."");
        if (firstDot != -1) {
          result += raw.substring(firstDot);
        }
        String compatibaleraw = new String(raw);
        String compatibaleresult = new String(result);

        //为了适配window要做一次转换
        if (!File.separator.contains(""/"")) {
          compatibaleresult = compatibaleresult.replace(""/"", File.separator);
          compatibaleraw = compatibaleraw.replace(""/"", File.separator);
        }

        File resRawFile = new File(mApkDecoder.getOutTempDir().getAbsolutePath() + File.separator + compatibaleraw);
        File resDestFile = new File(mApkDecoder.getOutDir().getAbsolutePath() + File.separator + compatibaleresult);

        MergeDuplicatedResInfo filterInfo = null;
        boolean mergeDuplicatedRes = mApkDecoder.getConfig().mMergeDuplicatedRes;
        if (mergeDuplicatedRes) {
          filterInfo = mergeDuplicated(resRawFile, resDestFile, compatibaleraw, result);
          if (filterInfo != null) {
            resDestFile = new File(filterInfo.filePath);
            result = filterInfo.fileName;
          }
        }

        //这里用的是linux的分隔符
        HashMap<String, Integer> compressData = mApkDecoder.getCompressData();
        if (compressData.containsKey(raw)) {
          compressData.put(result, compressData.get(raw));
        } else {
          System.err.printf(""can not find the compress dataresFile=%s\n"", raw);
        }

        if (!resRawFile.exists()) {
          System.err.printf(""can not find res file, you delete it? path: resFile=%s\n"", resRawFile.getAbsolutePath());
        } else {
          if (!mergeDuplicatedRes && resDestFile.exists()) {
            throw new AndrolibException(String.format(""res dest file is already  found: destFile=%s"",
               resDestFile.getAbsolutePath()
            ));
          }
          if (filterInfo == null) {
            FileOperation.copyFileUsingStream(resRawFile, resDestFile);
          }
          //already copied
          mApkDecoder.removeCopiedResFile(resRawFile.toPath());
          mTableStringsResguard.put(data, result);
        }
      }
    }
  }","None"
"2556","Field","flags","None","None"
"2557","Field","specNamesId","None","None"
"2558","Field","type","None","None"
"2559","Field","data","None","None"
"2560","Field","raw","None","None"
"2561","Field","proguard","None","None"
"2562","Field","secondSlash","None","None"
"2563","Field","newFilePath","None","None"
"2564","Field","result","None","None"
"2565","Field","firstDot","None","None"
"2566","Field","compatibaleraw","None","None"
"2567","Field","compatibaleresult","None","None"
"2568","Field","resRawFile","None","None"
"2569","Field","resDestFile","None","None"
"2570","Field","filterInfo","None","None"
"2571","Field","mergeDuplicatedRes","None","None"
"2572","Field","compressData","None","None"
"2573","Method","mergeDuplicated","private MergeDuplicatedResInfo mergeDuplicated(File resRawFile, File resDestFile, String compatibaleraw, String result) throws IOException {
    MergeDuplicatedResInfo filterInfo = null;
    List<MergeDuplicatedResInfo> mergeDuplicatedResInfoList = mMergeDuplicatedResInfoData.get(resRawFile.length());
    if (mergeDuplicatedResInfoList != null) {
      for (MergeDuplicatedResInfo mergeDuplicatedResInfo : mergeDuplicatedResInfoList) {
        if (mergeDuplicatedResInfo.md5 == null) {
          mergeDuplicatedResInfo.md5 = Md5Util.getMD5Str(new File(mergeDuplicatedResInfo.filePath));
        }
        String resRawFileMd5 = Md5Util.getMD5Str(resRawFile);
        if (!resRawFileMd5.isEmpty() && resRawFileMd5.equals(mergeDuplicatedResInfo.md5)) {
          filterInfo = mergeDuplicatedResInfo;
          filterInfo.md5 = resRawFileMd5;
          break;
        }
      }
    }
    if (filterInfo != null) {
      generalFilterResIDMapping(compatibaleraw, result, filterInfo.originalName, filterInfo.fileName, resRawFile.length());
      mMergeDuplicatedResCount++;
      mMergeDuplicatedResTotalSize += resRawFile.length();
    } else {
      MergeDuplicatedResInfo info = new MergeDuplicatedResInfo.Builder()
              .setFileName(result)
              .setFilePath(resDestFile.getAbsolutePath())
              .setOriginalName(compatibaleraw)
              .create();
      info.fileName = result;
      info.filePath = resDestFile.getAbsolutePath();
      info.originalName = compatibaleraw;

      if (mergeDuplicatedResInfoList == null) {
        mergeDuplicatedResInfoList = new ArrayList<>();
        mMergeDuplicatedResInfoData.put(resRawFile.length(), mergeDuplicatedResInfoList);
      }
      mergeDuplicatedResInfoList.add(info);
    }
    return filterInfo;
  }","resource filtering, filtering duplicate resources, reducing the volume of apk"
"2574","Field","resRawFile","None","None"
"2575","Field","resDestFile","None","None"
"2576","Field","compatibaleraw","None","None"
"2577","Field","result","None","None"
"2578","Field","filterInfo","None","None"
"2579","Field","mergeDuplicatedResInfoList","None","None"
"2580","Field","resRawFileMd5","None","None"
"2581","Field","info","None","None"
"2582","Method","writeValue","private void writeValue() throws IOException, AndrolibException {
    /* size */
    mOut.writeCheckShort(mIn.readShort(), (short) 8);
    /* zero */
    mOut.writeCheckByte(mIn.readByte(), (byte) 0);
    byte type = mIn.readByte();
    mOut.writeByte(type);
    int data = mIn.readInt();
    mOut.writeInt(data);
  }","None"
"2583","Field","type","None","None"
"2584","Field","data","None","None"
"2585","Method","readConfigFlags","private void readConfigFlags() throws IOException, AndrolibException {
    int size = mIn.readInt();
    int read = 28;
    if (size < 28) {
      throw new AndrolibException(""Config size < 28"");
    }

    boolean isInvalid = false;

    short mcc = mIn.readShort();
    short mnc = mIn.readShort();

    char[] language = new char[] { (char) mIn.readByte(), (char) mIn.readByte() };
    char[] country = new char[] { (char) mIn.readByte(), (char) mIn.readByte() };

    byte orientation = mIn.readByte();
    byte touchscreen = mIn.readByte();

    int density = mIn.readUnsignedShort();

    byte keyboard = mIn.readByte();
    byte navigation = mIn.readByte();
    byte inputFlags = mIn.readByte();
    /* inputPad0 */
    mIn.skipBytes(1);

    short screenWidth = mIn.readShort();
    short screenHeight = mIn.readShort();

    short sdkVersion = mIn.readShort();
    /* minorVersion, now must always be 0 */
    mIn.skipBytes(2);

    byte screenLayout = 0;
    byte uiMode = 0;
    short smallestScreenWidthDp = 0;

    if (size >= 32) {
      screenLayout = mIn.readByte();
      uiMode = mIn.readByte();
      smallestScreenWidthDp = mIn.readShort();
      read = 32;
    }

    short screenWidthDp = 0;
    short screenHeightDp = 0;
    if (size >= 36) {
      screenWidthDp = mIn.readShort();
      screenHeightDp = mIn.readShort();
      read = 36;
    }

    char[] localeScript = null;
    char[] localeVariant = null;
    if (size >= 48) {
      localeScript = readScriptOrVariantChar(4).toCharArray();
      localeVariant = readScriptOrVariantChar(8).toCharArray();
      read = 48;
    }

    byte screenLayout2 = 0;
    if (size >= 52) {
      screenLayout2 = mIn.readByte();
      mIn.skipBytes(3); // reserved padding
      read = 52;
    }

    if (size >= 56) {
      mIn.skipBytes(4);
      read = 56;
    }

    int exceedingSize = size - KNOWN_CONFIG_BYTES;
    if (exceedingSize > 0) {
      byte[] buf = new byte[exceedingSize];
      read += exceedingSize;
      mIn.readFully(buf);
      BigInteger exceedingBI = new BigInteger(1, buf);

      if (exceedingBI.equals(BigInteger.ZERO)) {
        LOGGER.fine(String.format(""Config flags size > %d, but exceeding bytes are all zero, so it should be ok."",
           KNOWN_CONFIG_BYTES
        ));
      } else {
        LOGGER.warning(String.format(""Config flags size > %d. Exceeding bytes: 0x%X."",
           KNOWN_CONFIG_BYTES,
           exceedingBI
        ));
        isInvalid = true;
      }
    }
  }","None"
"2586","Field","size","None","None"
"2587","Field","read","None","None"
"2588","Field","isInvalid","None","None"
"2589","Field","mcc","None","None"
"2590","Field","mnc","None","None"
"2591","Field","language","None","None"
"2592","Field","country","None","None"
"2593","Field","orientation","None","None"
"2594","Field","touchscreen","None","None"
"2595","Field","density","None","None"
"2596","Field","keyboard","None","None"
"2597","Field","navigation","None","None"
"2598","Field","inputFlags","None","None"
"2599","Field","screenWidth","None","None"
"2600","Field","screenHeight","None","None"
"2601","Field","sdkVersion","None","None"
"2602","Field","screenLayout","None","None"
"2603","Field","uiMode","None","None"
"2604","Field","smallestScreenWidthDp","None","None"
"2605","Field","screenWidthDp","None","None"
"2606","Field","screenHeightDp","None","None"
"2607","Field","localeScript","None","None"
"2608","Field","localeVariant","None","None"
"2609","Field","screenLayout2","None","None"
"2610","Field","exceedingSize","None","None"
"2611","Field","buf","None","None"
"2612","Field","exceedingBI","None","None"
"2613","Method","readScriptOrVariantChar","private String readScriptOrVariantChar(int length) throws AndrolibException, IOException {
    StringBuilder string = new StringBuilder(16);

    while (length-- != 0) {
      short ch = mIn.readByte();
      if (ch == 0) {
        break;
      }
      string.append((char) ch);
    }
    mIn.skipBytes(length);

    return string.toString();
  }","None"
"2614","Field","length","None","None"
"2615","Field","string","None","None"
"2616","Field","ch","None","None"
"2617","Method","writeConfigFlags","private void writeConfigFlags() throws IOException, AndrolibException {
    //总的有多大
    int size = mIn.readInt();
    if (size < 28) {
      throw new AndrolibException(""Config size < 28"");
    }
    mOut.writeInt(size);

    mOut.writeBytes(mIn, size - 4);
  }","None"
"2618","Field","size","None","None"
"2619","Method","nextChunk","private Header nextChunk() throws IOException {
    return mHeader = Header.read(mIn);
  }","None"
"2620","Method","checkChunkType","private void checkChunkType(int expectedType) throws AndrolibException {
    if (mHeader.type != expectedType) {
      throw new AndrolibException(String.format(""Invalid chunk type: expected=0x%08x, got=0x%08x"",
         expectedType,
         mHeader.type
      ));
    }
  }","None"
"2621","Field","expectedType","None","None"
"2622","Method","nextChunkCheckType","private void nextChunkCheckType(int expectedType) throws IOException, AndrolibException {
    nextChunk();
    checkChunkType(expectedType);
  }","None"
"2623","Field","expectedType","None","None"
"2624","Method","writeNextChunk","private Header writeNextChunk(int diffSize) throws IOException, AndrolibException {
    mHeader = Header.readAndWriteHeader(mIn, mOut, diffSize);
    return mHeader;
  }","None"
"2625","Field","diffSize","None","None"
"2626","Method","writeNextChunkCheck","private Header writeNextChunkCheck(int expectedType, int diffSize) throws IOException, AndrolibException {
    mHeader = Header.readAndWriteHeader(mIn, mOut, diffSize);
    if (mHeader.type != expectedType) {
      throw new AndrolibException(String.format(""Invalid chunk type: expected=%d, got=%d"", expectedType, mHeader.type));
    }
    return mHeader;
  }","None"
"2627","Field","expectedType","None","None"
"2628","Field","diffSize","None","None"
"2629","Method","isToResguardFile","private boolean isToResguardFile(String name) {
    return (!name.equals(""string"") && !name.equals(""id"") && !name.equals(""array""));
  }","，string,id,array，"
"2630","Field","name","None","None"
"2631","Class","Header","Header","None"
"2632","Field","TYPE_NONE","None","None"
"2633","Field","type","None","None"
"2634","Field","chunkSize","None","None"
"2635","Field","type","None","None"
"2636","Field","size","None","None"
"2637","Field","in","None","None"
"2638","Field","type","None","None"
"2639","Field","count","None","None"
"2640","Field","size","None","None"
"2641","Field","in","None","None"
"2642","Field","out","None","None"
"2643","Field","diffSize","None","None"
"2644","Field","type","None","None"
"2645","Field","size","None","None"
"2646","Field","count","None","None"
"2647","Method","read","public static Header read(ExtDataInput in) throws IOException {
      short type;
      try {
        type = in.readShort();
        short count = in.readShort();
        int size = in.readInt();
        return new Header(type, size);
      } catch (EOFException ex) {
        return new Header(TYPE_NONE, 0);
      }
    }","None"
"2648","Field","in","None","None"
"2649","Field","type","None","None"
"2650","Field","count","None","None"
"2651","Field","size","None","None"
"2652","Method","readAndWriteHeader","public static Header readAndWriteHeader(ExtDataInput in, ExtDataOutput out, int diffSize)
       throws IOException, AndrolibException {
      short type;
      int size;
      try {
        type = in.readShort();
        out.writeShort(type);
        short count = in.readShort();
        out.writeShort(count);
        size = in.readInt();
        size -= diffSize;
        if (size <= 0) {
          throw new AndrolibException(String.format(""readAndWriteHeader size < 0: size=%d"", size));
        }
        out.writeInt(size);
      } catch (EOFException ex) {
        return new Header(TYPE_NONE, 0);
      }
      return new Header(type, size);
    }","None"
"2653","Field","in","None","None"
"2654","Field","out","None","None"
"2655","Field","diffSize","None","None"
"2656","Field","type","None","None"
"2657","Field","size","None","None"
"2658","Field","count","None","None"
"2659","Class","FlagsOffset","FlagsOffset","None"
"2660","Field","offset","None","None"
"2661","Field","count","None","None"
"2662","Field","offset","None","None"
"2663","Field","count","None","None"
"2664","Class","MergeDuplicatedResInfo","MergeDuplicatedResInfo","None"
"2665","Field","fileName","None","None"
"2666","Field","filePath","None","None"
"2667","Field","originalName","None","None"
"2668","Field","md5","None","None"
"2669","Field","fileName","None","None"
"2670","Field","filePath","None","None"
"2671","Field","originalName","None","None"
"2672","Field","md5","None","None"
"2673","Field","fileName","None","None"
"2674","Field","filePath","None","None"
"2675","Field","originalName","None","None"
"2676","Field","md5","None","None"
"2677","Field","fileName","None","None"
"2678","Field","filePath","None","None"
"2679","Field","md5","None","None"
"2680","Field","originalName","None","None"
"2681","Class","Builder","Builder","None"
"2682","Field","fileName","None","None"
"2683","Field","filePath","None","None"
"2684","Field","originalName","None","None"
"2685","Field","md5","None","None"
"2686","Field","fileName","None","None"
"2687","Field","filePath","None","None"
"2688","Field","md5","None","None"
"2689","Field","originalName","None","None"
"2690","Method","setFileName","Builder setFileName(String fileName) {
        this.fileName = fileName;
        return this;
      }","None"
"2691","Field","fileName","None","None"
"2692","Method","setFilePath","Builder setFilePath(String filePath) {
        this.filePath = filePath;
        return this;
      }","None"
"2693","Field","filePath","None","None"
"2694","Method","setMd5","public Builder setMd5(String md5) {
        this.md5 = md5;
        return this;
      }","None"
"2695","Field","md5","None","None"
"2696","Method","setOriginalName","Builder setOriginalName(String originalName) {
        this.originalName = originalName;
        return this;
      }","None"
"2697","Field","originalName","None","None"
"2698","Method","create","MergeDuplicatedResInfo create() {
        return new MergeDuplicatedResInfo(fileName, filePath, originalName, md5);
      }","None"
"2699","Class","ResguardStringBuilder","ResguardStringBuilder","None"
"2700","Field","mReplaceStringBuffer","None","None"
"2701","Field","mIsReplaced","None","None"
"2702","Field","mIsWhiteList","None","None"
"2703","Field","mAToZ","None","None"
"2704","Field","mAToAll","None","None"
"2705","Field","mFileNameBlackList","None","window CON, PRN, AUX, CLOCK$, NUL COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9 LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9"
"2706","Field","blacklistPatterns","None","None"
"2707","Field","str","None","None"
"2708","Field","first","None","None"
"2709","Field","str","None","None"
"2710","Field","first","None","None"
"2711","Field","second","None","None"
"2712","Field","third","None","None"
"2713","Field","str","None","None"
"2714","Field","collection","None","None"
"2715","Field","id","None","None"
"2716","Field","id","None","None"
"2717","Field","id","None","None"
"2718","Field","id","None","None"
"2719","Method","reset","public void reset(HashSet<Pattern> blacklistPatterns) {
      mReplaceStringBuffer.clear();
      mIsReplaced.clear();
      mIsWhiteList.clear();

      for (int i = 0; i < mAToZ.length; i++) {
        String str = mAToZ[i];
        if (!Utils.match(str, blacklistPatterns)) {
          mReplaceStringBuffer.add(str);
        }
      }

      for (int i = 0; i < mAToZ.length; i++) {
        String first = mAToZ[i];
        for (int j = 0; j < mAToAll.length; j++) {
          String str = first + mAToAll[j];
          if (!Utils.match(str, blacklistPatterns)) {
            mReplaceStringBuffer.add(str);
          }
        }
      }

      for (int i = 0; i < mAToZ.length; i++) {
        String first = mAToZ[i];
        for (int j = 0; j < mAToAll.length; j++) {
          String second = mAToAll[j];
          for (int k = 0; k < mAToAll.length; k++) {
            String third = mAToAll[k];
            String str = first + second + third;
            if (!mFileNameBlackList.contains(str) && !Utils.match(str, blacklistPatterns)) {
              mReplaceStringBuffer.add(str);
            }
          }
        }
      }
    }","None"
"2720","Field","blacklistPatterns","None","None"
"2721","Field","str","None","None"
"2722","Field","first","None","None"
"2723","Field","str","None","None"
"2724","Field","first","None","None"
"2725","Field","second","None","None"
"2726","Field","third","None","None"
"2727","Field","str","None","None"
"2728","Method","removeStrings","public void removeStrings(Collection<String> collection) {
      if (collection == null) return;
      mReplaceStringBuffer.removeAll(collection);
    }","None"
"2729","Field","collection","None","None"
"2730","Method","isReplaced","public boolean isReplaced(int id) {
      return mIsReplaced.contains(id);
    }","None"
"2731","Field","id","None","None"
"2732","Method","isInWhiteList","public boolean isInWhiteList(int id) {
      return mIsWhiteList.contains(id);
    }","None"
"2733","Field","id","None","None"
"2734","Method","setInWhiteList","public void setInWhiteList(int id) {
      mIsWhiteList.add(id);
    }","None"
"2735","Field","id","None","None"
"2736","Method","setInReplaceList","public void setInReplaceList(int id) {
      mIsReplaced.add(id);
    }","None"
"2737","Field","id","None","None"
"2738","Method","getReplaceString","public String getReplaceString() throws AndrolibException {
      if (mReplaceStringBuffer.isEmpty()) {
        throw new AndrolibException(String.format(""now can only proguard less than 35594 in a single type\n""));
      }
      return mReplaceStringBuffer.remove(0);
    }","None"
"2739","Class","StringBlock","StringBlock","None"
"2740","Field","UTF16LE_DECODER","None","None"
"2741","Field","UTF8_DECODER","None","None"
"2742","Field","LOGGER","None","None"
"2743","Field","CHUNK_STRINGPOOL_TYPE","None","None"
"2744","Field","UTF8_FLAG","None","None"
"2745","Field","CHUNK_NULL_TYPE","None","None"
"2746","Field","NULL","None","None"
"2747","Field","m_stringOffsets","None","None"
"2748","Field","m_strings","None","None"
"2749","Field","m_styleOffsets","None","None"
"2750","Field","m_styles","None","None"
"2751","Field","m_isUTF8","None","None"
"2752","Field","m_stringOwns","None","None"
"2753","Field","reader","None","None"
"2754","Field","chunkSize","None","None"
"2755","Field","stringCount","None","None"
"2756","Field","styleCount","None","None"
"2757","Field","flags","None","None"
"2758","Field","stringsOffset","None","None"
"2759","Field","stylesOffset","None","None"
"2760","Field","block","None","None"
"2761","Field","size","None","None"
"2762","Field","size","None","None"
"2763","Field","reader","None","None"
"2764","Field","out","None","None"
"2765","Field","specNames","None","None"
"2766","Field","curSpecNameToPos","None","None"
"2767","Field","type","None","None"
"2768","Field","chunkSize","None","None"
"2769","Field","stringCount","None","None"
"2770","Field","styleOffsetCount","None","None"
"2771","Field","flags","None","None"
"2772","Field","isUTF8","None","None"
"2773","Field","stringsOffset","None","None"
"2774","Field","stylesOffset","None","None"
"2775","Field","size","None","None"
"2776","Field","temp_strings","None","None"
"2777","Field","totalSize","None","None"
"2778","Field","stringOffsets","None","None"
"2779","Field","stringBytes","None","None"
"2780","Field","offset","None","None"
"2781","Field","i","None","None"
"2782","Field","name","None","None"
"2783","Field","tempByte","None","None"
"2784","Field","tempByte","None","None"
"2785","Field","add","None","None"
"2786","Field","reader","None","None"
"2787","Field","out","None","None"
"2788","Field","tableProguardMap","None","None"
"2789","Field","type","None","None"
"2790","Field","chunkSize","None","None"
"2791","Field","stringCount","None","None"
"2792","Field","styleOffsetCount","None","None"
"2793","Field","flags","None","None"
"2794","Field","stringsOffset","None","None"
"2795","Field","stylesOffset","None","None"
"2796","Field","block","None","None"
"2797","Field","size","None","None"
"2798","Field","size","None","None"
"2799","Field","totalSize","None","None"
"2800","Field","strings","None","None"
"2801","Field","stringOffsets","None","None"
"2802","Field","offset","None","None"
"2803","Field","i","None","None"
"2804","Field","copyLen","None","None"
"2805","Field","name","None","None"
"2806","Field","tempByte","None","None"
"2807","Field","tempByte","None","None"
"2808","Field","size","None","None"
"2809","Field","add","None","None"
"2810","Field","reader","None","None"
"2811","Field","out","None","None"
"2812","Field","chunkSize","None","None"
"2813","Field","array","None","None"
"2814","Field","offset","None","None"
"2815","Field","val","None","None"
"2816","Field","length","None","None"
"2817","Field","low","None","None"
"2818","Field","array","None","None"
"2819","Field","offset","None","None"
"2820","Field","val","None","None"
"2821","Field","high","None","None"
"2822","Field","low","None","None"
"2823","Field","len_value","None","None"
"2824","Field","array","None","None"
"2825","Field","offset","None","None"
"2826","Field","array","None","None"
"2827","Field","offset","None","None"
"2828","Field","value","None","None"
"2829","Field","array","None","None"
"2830","Field","offset","None","None"
"2831","Field","value","None","None"
"2832","Field","index","None","None"
"2833","Field","offset","None","None"
"2834","Field","length","None","None"
"2835","Field","val","None","None"
"2836","Field","val","None","None"
"2837","Field","index","None","None"
"2838","Field","string","None","None"
"2839","Field","offset","None","None"
"2840","Field","length","None","None"
"2841","Field","j","None","None"
"2842","Field","offset","None","None"
"2843","Field","length","None","None"
"2844","Method","read","public static StringBlock read(ExtDataInput reader) throws IOException {
    reader.skipCheckChunkTypeInt(CHUNK_STRINGPOOL_TYPE, CHUNK_NULL_TYPE);
    int chunkSize = reader.readInt();
    int stringCount = reader.readInt();
    int styleCount = reader.readInt();
    int flags = reader.readInt();
    int stringsOffset = reader.readInt();
    int stylesOffset = reader.readInt();

    StringBlock block = new StringBlock();
    block.m_isUTF8 = (flags & UTF8_FLAG) != 0;
    block.m_stringOffsets = reader.readIntArray(stringCount);
    block.m_stringOwns = new int[stringCount];
    Arrays.fill(block.m_stringOwns, -1);

    if (styleCount != 0) {
      block.m_styleOffsets = reader.readIntArray(styleCount);
    }
    {
      int size = ((stylesOffset == 0) ? chunkSize : stylesOffset) - stringsOffset;

      if ((size % 4) != 0) {
        throw new IOException(""String data size is not multiple of 4 ("" + size + "")."");
      }
      block.m_strings = new byte[size];

      reader.readFully(block.m_strings);
    }
    if (stylesOffset != 0) {
      int size = (chunkSize - stylesOffset);
      if ((size % 4) != 0) {
        throw new IOException(""Style data size is not multiple of 4 ("" + size + "")."");
      }
      block.m_styles = reader.readIntArray(size / 4);
    }
    return block;
  }","Reads whole (including chunk type) string block from stream. Stream must be at the chunk type"
"2845","Field","reader","None","None"
"2846","Field","chunkSize","None","None"
"2847","Field","stringCount","None","None"
"2848","Field","styleCount","None","None"
"2849","Field","flags","None","None"
"2850","Field","stringsOffset","None","None"
"2851","Field","stylesOffset","None","None"
"2852","Field","block","None","None"
"2853","Field","size","None","None"
"2854","Field","size","None","None"
"2855","Method","writeSpecNameStringBlock","public static int writeSpecNameStringBlock(
          ExtDataInput reader, ExtDataOutput out, Map<String, Set<String>> specNames, Map<String, Integer> curSpecNameToPos)
      throws IOException, AndrolibException {
    int type = reader.readInt();
    int chunkSize = reader.readInt();
    int stringCount = reader.readInt();
    int styleOffsetCount = reader.readInt();

    if (styleOffsetCount != 0) {
      throw new AndrolibException(String.format(""writeSpecNameStringBlock styleOffsetCount != 0  styleOffsetCount %d"",
          styleOffsetCount
      ));
    }

    int flags = reader.readInt();
    boolean isUTF8 = (flags & UTF8_FLAG) != 0;
    int stringsOffset = reader.readInt();
    int stylesOffset = reader.readInt();
    reader.readIntArray(stringCount);
    int size = ((stylesOffset == 0) ? chunkSize : stylesOffset) - stringsOffset;

    if ((size % 4) != 0) {
      throw new IOException(""String data size is not multiple of 4 ("" + size + "")."");
    }
    byte[] temp_strings = new byte[size];
    reader.readFully(temp_strings);
    int totalSize = 0;
    out.writeCheckInt(type, CHUNK_STRINGPOOL_TYPE);
    totalSize += 4;
    stringCount = specNames.keySet().size();
    System.out.println(""String pool size: "" + stringCount);

    totalSize += 6 * 4 + 4 * stringCount;
    stringsOffset = totalSize;

    int[] stringOffsets = new int[stringCount];
    // make twice size buffer for avoiding out of bounds error
    byte[] stringBytes = new byte[size * 2];
    int offset = 0;
    int i = 0;
    curSpecNameToPos.clear();

    for (Iterator<String> it = specNames.keySet().iterator(); it.hasNext(); ) {
      stringOffsets[i] = offset;
      String name = it.next();
      for (String specName : specNames.get(name)) {
        // N res entry item point to one string constant
        curSpecNameToPos.put(specName, i);
      }
      if (isUTF8) {
        stringBytes[offset++] = (byte) name.length();
        stringBytes[offset++] = (byte) name.length();
        totalSize += 2;
        byte[] tempByte = name.getBytes(Charset.forName(""UTF-8""));
        if (name.length() != tempByte.length) {
          throw new AndrolibException(String.format(
              ""writeSpecNameStringBlock %s UTF-8 length is different name %d, tempByte %d\n"",
              name,
              name.length(),
              tempByte.length
          ));
        }
        System.arraycopy(tempByte, 0, stringBytes, offset, tempByte.length);
        offset += name.length();
        stringBytes[offset++] = NULL;
        totalSize += name.length() + 1;
      } else {
        writeShort(stringBytes, offset, (short) name.length());
        offset += 2;
        totalSize += 2;
        byte[] tempByte = name.getBytes(Charset.forName(""UTF-16LE""));
        if ((name.length() * 2) != tempByte.length) {
          throw new AndrolibException(String.format(
              ""writeSpecNameStringBlock %s UTF-16LE length is different name %d, tempByte %d\n"",
              name,
              name.length(),
              tempByte.length
          ));
        }
        System.arraycopy(tempByte, 0, stringBytes, offset, tempByte.length);
        offset += tempByte.length;
        stringBytes[offset++] = NULL;
        stringBytes[offset++] = NULL;
        totalSize += tempByte.length + 2;
      }
      i++;
    }
    //要保证string size 是4的倍数,要补零
    size = totalSize - stringsOffset;
    if ((size % 4) != 0) {
      int add = 4 - (size % 4);
      for (i = 0; i < add; i++) {
        stringBytes[offset++] = NULL;
        totalSize++;
      }
    }

    out.writeInt(totalSize);
    out.writeInt(stringCount);
    out.writeInt(styleOffsetCount);
    out.writeInt(flags);
    out.writeInt(stringsOffset);
    out.writeInt(stylesOffset);
    out.writeIntArray(stringOffsets);
    out.write(stringBytes, 0, offset);
    return (chunkSize - totalSize);
  }","None"
"2856","Field","reader","None","None"
"2857","Field","out","None","None"
"2858","Field","specNames","None","None"
"2859","Field","curSpecNameToPos","None","None"
"2860","Field","type","None","None"
"2861","Field","chunkSize","None","None"
"2862","Field","stringCount","None","None"
"2863","Field","styleOffsetCount","None","None"
"2864","Field","flags","None","None"
"2865","Field","isUTF8","None","None"
"2866","Field","stringsOffset","None","None"
"2867","Field","stylesOffset","None","None"
"2868","Field","size","None","None"
"2869","Field","temp_strings","None","None"
"2870","Field","totalSize","None","None"
"2871","Field","stringOffsets","None","None"
"2872","Field","stringBytes","None","None"
"2873","Field","offset","None","None"
"2874","Field","i","None","None"
"2875","Field","name","None","None"
"2876","Field","tempByte","None","None"
"2877","Field","tempByte","None","None"
"2878","Field","add","None","None"
"2879","Method","writeTableNameStringBlock","public static int writeTableNameStringBlock(
      ExtDataInput reader, ExtDataOutput out, Map<Integer, String> tableProguardMap)
      throws IOException, AndrolibException {
    int type = reader.readInt();
    int chunkSize = reader.readInt();
    int stringCount = reader.readInt();
    int styleOffsetCount = reader.readInt();
    int flags = reader.readInt();
    int stringsOffset = reader.readInt();
    int stylesOffset = reader.readInt();

    StringBlock block = new StringBlock();
    block.m_isUTF8 = (flags & UTF8_FLAG) != 0;
    if (block.m_isUTF8) {
      System.out.printf(""resources.arsc Character Encoding: utf-8\n"");
    } else {
      System.out.printf(""resources.arsc Character Encoding: utf-16\n"");
    }

    block.m_stringOffsets = reader.readIntArray(stringCount);
    block.m_stringOwns = new int[stringCount];
    for (int i = 0; i < stringCount; i++) {
      block.m_stringOwns[i] = -1;
    }
    if (styleOffsetCount != 0) {
      block.m_styleOffsets = reader.readIntArray(styleOffsetCount);
    }
    {
      int size = ((stylesOffset == 0) ? chunkSize : stylesOffset) - stringsOffset;
      if ((size % 4) != 0) {
        throw new IOException(""String data size is not multiple of 4 ("" + size + "")."");
      }
      block.m_strings = new byte[size];
      reader.readFully(block.m_strings);
    }
    if (stylesOffset != 0) {
      int size = (chunkSize - stylesOffset);
      if ((size % 4) != 0) {
        throw new IOException(""Style data size is not multiple of 4 ("" + size + "")."");
      }
      block.m_styles = reader.readIntArray(size / 4);
    }

    int totalSize = 0;
    out.writeCheckInt(type, CHUNK_STRINGPOOL_TYPE);
    totalSize += 4;

    totalSize += 6 * 4 + 4 * stringCount + 4 * styleOffsetCount;
    stringsOffset = totalSize;

    byte[] strings = new byte[block.m_strings.length];
    int[] stringOffsets = new int[stringCount];
    System.arraycopy(block.m_stringOffsets, 0, stringOffsets, 0, stringOffsets.length);

    int offset = 0;
    int i;
    for (i = 0; i < stringCount; i++) {
      stringOffsets[i] = offset;
      //如果找不到即没混淆这一项,直接拷贝
      if (tableProguardMap.get(i) == null) {
        //需要区分是否是最后一项
        int copyLen = (i == (stringCount - 1)) ? (block.m_strings.length - block.m_stringOffsets[i])
            : (block.m_stringOffsets[i + 1] - block.m_stringOffsets[i]);
        System.arraycopy(block.m_strings, block.m_stringOffsets[i], strings, offset, copyLen);
        offset += copyLen;
        totalSize += copyLen;
      } else {
        String name = tableProguardMap.get(i);
        if (block.m_isUTF8) {
          strings[offset++] = (byte) name.length();
          strings[offset++] = (byte) name.length();
          totalSize += 2;
          byte[] tempByte = name.getBytes(Charset.forName(""UTF-8""));
          if (name.length() != tempByte.length) {
            throw new AndrolibException(String.format(
                ""writeTableNameStringBlock UTF-8 length is different  name %d, tempByte %d\n"",
                name.length(),
                tempByte.length
            ));
          }
          System.arraycopy(tempByte, 0, strings, offset, tempByte.length);
          offset += name.length();
          strings[offset++] = NULL;
          totalSize += name.length() + 1;
        } else {
          writeShort(strings, offset, (short) name.length());
          offset += 2;
          totalSize += 2;
          byte[] tempByte = name.getBytes(Charset.forName(""UTF-16LE""));
          if ((name.length() * 2) != tempByte.length) {
            throw new AndrolibException(String.format(
                ""writeTableNameStringBlock UTF-16LE length is different  name %d, tempByte %d\n"",
                name.length(),
                tempByte.length
            ));
          }
          System.arraycopy(tempByte, 0, strings, offset, tempByte.length);
          offset += tempByte.length;
          strings[offset++] = NULL;
          strings[offset++] = NULL;
          totalSize += tempByte.length + 2;
        }
      }
    }
    //要保证string size 是4的倍数,要补零
    int size = totalSize - stringsOffset;
    if ((size % 4) != 0) {
      int add = 4 - (size % 4);
      for (i = 0; i < add; i++) {
        strings[offset++] = NULL;
        totalSize++;
      }
    }
    //因为是int的,如果之前的不为0
    if (stylesOffset != 0) {
      stylesOffset = totalSize;
      totalSize += block.m_styles.length * 4;
    }

    out.writeInt(totalSize);
    out.writeInt(stringCount);
    out.writeInt(styleOffsetCount);
    out.writeInt(flags);
    out.writeInt(stringsOffset);
    out.writeInt(stylesOffset);
    out.writeIntArray(stringOffsets);
    if (stylesOffset != 0) {
      out.writeIntArray(block.m_styleOffsets);
    }
    out.write(strings, 0, offset);
    if (stylesOffset != 0) {
      out.writeIntArray(block.m_styles);
    }
    return (chunkSize - totalSize);
  }","None"
"2880","Field","reader","None","None"
"2881","Field","out","None","None"
"2882","Field","tableProguardMap","None","None"
"2883","Field","type","None","None"
"2884","Field","chunkSize","None","None"
"2885","Field","stringCount","None","None"
"2886","Field","styleOffsetCount","None","None"
"2887","Field","flags","None","None"
"2888","Field","stringsOffset","None","None"
"2889","Field","stylesOffset","None","None"
"2890","Field","block","None","None"
"2891","Field","size","None","None"
"2892","Field","size","None","None"
"2893","Field","totalSize","None","None"
"2894","Field","strings","None","None"
"2895","Field","stringOffsets","None","None"
"2896","Field","offset","None","None"
"2897","Field","i","None","None"
"2898","Field","copyLen","None","None"
"2899","Field","name","None","None"
"2900","Field","tempByte","None","None"
"2901","Field","tempByte","None","None"
"2902","Field","size","None","None"
"2903","Field","add","None","None"
"2904","Method","writeAll","public static void writeAll(ExtDataInput reader, ExtDataOutput out) throws IOException {
    out.writeCheckChunkTypeInt(reader, CHUNK_STRINGPOOL_TYPE, CHUNK_NULL_TYPE);
    int chunkSize = reader.readInt();
    out.writeInt(chunkSize);
    out.writeBytes(reader, chunkSize - 8);
  }","Reads whole (including chunk type) string block from stream. Stream must be at the chunk type"
"2905","Field","reader","None","None"
"2906","Field","out","None","None"
"2907","Field","chunkSize","None","None"
"2908","Method","getUtf8","private static final int[] getUtf8(byte[] array, int offset) {
    int val = array[offset];
    int length;
    // We skip the utf16 length of the string
    if ((val & 0x80) != 0) {
      offset += 2;
    } else {
      offset += 1;
    }
    // And we read only the utf-8 encoded length of the string
    val = array[offset];
    offset += 1;
    if ((val & 0x80) != 0) {
      int low = (array[offset] & 0xFF);
      length = ((val & 0x7F) << 8) + low;
      offset += 1;
    } else {
      length = val;
    }
    return new int[] { offset, length };
  }","None"
"2909","Field","array","None","None"
"2910","Field","offset","None","None"
"2911","Field","val","None","None"
"2912","Field","length","None","None"
"2913","Field","low","None","None"
"2914","Method","getUtf16","private static final int[] getUtf16(byte[] array, int offset) {
    int val = ((array[offset + 1] & 0xFF) << 8 | array[offset] & 0xFF);

    if ((val & 0x8000) != 0) {
      int high = (array[offset + 3] & 0xFF) << 8;
      int low = (array[offset + 2] & 0xFF);
      int len_value = ((val & 0x7FFF) << 16) + (high + low);
      return new int[] { 4, len_value * 2 };
    }
    return new int[] { 2, val * 2 };
  }","None"
"2915","Field","array","None","None"
"2916","Field","offset","None","None"
"2917","Field","val","None","None"
"2918","Field","high","None","None"
"2919","Field","low","None","None"
"2920","Field","len_value","None","None"
"2921","Method","getShort","private static final int getShort(byte[] array, int offset) {
    return (array[offset + 1] & 0xff) << 8 | array[offset] & 0xff;
  }","None"
"2922","Field","array","None","None"
"2923","Field","offset","None","None"
"2924","Method","writeShort","private static final void writeShort(byte[] array, int offset, short value) {
    array[offset] = (byte) (0xFF & value);
    array[offset + 1] = (byte) (0xFF & (value >> 8));
  }","None"
"2925","Field","array","None","None"
"2926","Field","offset","None","None"
"2927","Field","value","None","None"
"2928","Method","getShort","private static final int getShort(int[] array, int offset) {
    int value = array[offset / 4];
    if ((offset % 4) / 2 == 0) {
      return (value & 0xFFFF);
    } else {
      return (value >>> 16);
    }
  }","None"
"2929","Field","array","None","None"
"2930","Field","offset","None","None"
"2931","Field","value","None","None"
"2932","Method","getCount","public int getCount() {
    return m_stringOffsets != null ? m_stringOffsets.length : 0;
  }","Returns number of strings in block"
"2933","Method","getString","public String getString(int index) {
    if (index < 0 || m_stringOffsets == null || index >= m_stringOffsets.length) {
      return null;
    }
    int offset = m_stringOffsets[index];
    int length;

    if (m_isUTF8) {
      int[] val = getUtf8(m_strings, offset);
      offset = val[0];
      length = val[1];
    } else {
      int[] val = getUtf16(m_strings, offset);
      offset += val[0];
      length = val[1];
    }
    return decodeString(offset, length);
  }","Returns raw string (without any styling information) at specified index"
"2934","Field","index","None","None"
"2935","Field","offset","None","None"
"2936","Field","length","None","None"
"2937","Field","val","None","None"
"2938","Field","val","None","None"
"2939","Method","get","public CharSequence get(int index) {
    return getString(index);
  }","Not yet implemented. Returns string with style information (if any)"
"2940","Field","index","None","None"
"2941","Method","find","public int find(String string) {
    if (string == null) {
      return -1;
    }
    for (int i = 0; i != m_stringOffsets.length; ++i) {
      int offset = m_stringOffsets[i];
      int length = getShort(m_strings, offset);
      if (length != string.length()) {
        continue;
      }
      int j = 0;
      for (; j != length; ++j) {
        offset += 2;
        if (string.charAt(j) != getShort(m_strings, offset)) {
          break;
        }
      }
      if (j == length) {
        return i;
      }
    }
    return -1;
  }","Finds index of the string. Returns -1 if the string was not found"
"2942","Field","string","None","None"
"2943","Field","offset","None","None"
"2944","Field","length","None","None"
"2945","Field","j","None","None"
"2946","Method","decodeString","private String decodeString(int offset, int length) {
    try {
      return (m_isUTF8 ? UTF8_DECODER : UTF16LE_DECODER).decode(ByteBuffer.wrap(m_strings, offset, length)).toString();
    } catch (CharacterCodingException ex) {
      LOGGER.log(Level.WARNING, null, ex);
      return null;
    }
  }","None"
"2947","Field","offset","None","None"
"2948","Field","length","None","None"
"2949","Class","RawARSCDecoder","RawARSCDecoder","，！"
"2950","Field","ENTRY_FLAG_COMPLEX","None","None"
"2951","Field","ENTRY_FLAG_PUBLIC","None","None"
"2952","Field","ENTRY_FLAG_WEAK","None","None"
"2953","Field","LOGGER","None","None"
"2954","Field","KNOWN_CONFIG_BYTES","None","None"
"2955","Field","mExistTypeNames","None","None"
"2956","Field","mCountIn","None","None"
"2957","Field","mIn","None","None"
"2958","Field","mHeader","None","None"
"2959","Field","mTypeNames","None","None"
"2960","Field","mSpecNames","None","None"
"2961","Field","mPkg","None","None"
"2962","Field","mType","None","None"
"2963","Field","mTypeIdOffset","None","None"
"2964","Field","mCurTypeID","None","None"
"2965","Field","mPkgs","None","None"
"2966","Field","mResId","None","None"
"2967","Field","arscStream","None","None"
"2968","Field","arscStream","None","None"
"2969","Field","decoder","None","None"
"2970","Field","type","None","None"
"2971","Field","packageCount","None","None"
"2972","Field","packages","None","None"
"2973","Field","id","None","None"
"2974","Field","name","None","None"
"2975","Field","splitHeaderSize","None","None"
"2976","Field","libraryCount","None","None"
"2977","Field","packageId","None","None"
"2978","Field","packageName","None","None"
"2979","Field","id","None","None"
"2980","Field","entryCount","None","None"
"2981","Field","typeId","None","None"
"2982","Field","typeFlags","None","None"
"2983","Field","entryCount","None","None"
"2984","Field","entriesStart","None","None"
"2985","Field","entryOffsets","None","None"
"2986","Field","flags","None","None"
"2987","Field","specNamesId","None","None"
"2988","Field","readDirect","None","None"
"2989","Field","flags","None","None"
"2990","Field","specNamesId","None","None"
"2991","Field","parent","None","None"
"2992","Field","count","None","None"
"2993","Field","flags","None","None"
"2994","Field","specNamesId","None","None"
"2995","Field","type","None","None"
"2996","Field","data","None","None"
"2997","Field","read","None","None"
"2998","Field","size","None","None"
"2999","Field","isInvalid","None","None"
"3000","Field","mcc","None","None"
"3001","Field","mnc","None","None"
"3002","Field","language","None","None"
"3003","Field","country","None","None"
"3004","Field","orientation","None","None"
"3005","Field","touchscreen","None","None"
"3006","Field","density","None","None"
"3007","Field","keyboard","None","None"
"3008","Field","navigation","None","None"
"3009","Field","inputFlags","None","None"
"3010","Field","screenWidth","None","None"
"3011","Field","screenHeight","None","None"
"3012","Field","sdkVersion","None","None"
"3013","Field","screenLayout","None","None"
"3014","Field","uiMode","None","None"
"3015","Field","smallestScreenWidthDp","None","None"
"3016","Field","screenWidthDp","None","None"
"3017","Field","screenHeightDp","None","None"
"3018","Field","localeScript","None","None"
"3019","Field","localeVariant","None","None"
"3020","Field","screenLayout2","None","None"
"3021","Field","exceedingSize","None","None"
"3022","Field","buf","None","None"
"3023","Field","exceedingBI","None","None"
"3024","Field","remainingSize","None","None"
"3025","Field","length","None","None"
"3026","Field","string","None","None"
"3027","Field","ch","None","None"
"3028","Field","expectedType","None","None"
"3029","Field","expectedType","None","None"
"3030","Field","type","None","None"
"3031","Field","name","None","None"
"3032","Field","names","None","None"
"3033","Field","TYPE_NONE","None","None"
"3034","Field","TYPE_TABLE","None","None"
"3035","Field","TYPE_PACKAGE","None","None"
"3036","Field","TYPE_TYPE","None","None"
"3037","Field","TYPE_SPEC_TYPE","None","None"
"3038","Field","TYPE_LIBRARY","None","None"
"3039","Field","type","None","None"
"3040","Field","headerSize","None","None"
"3041","Field","chunkSize","None","None"
"3042","Field","startPosition","None","None"
"3043","Field","endPosition","None","None"
"3044","Field","type","None","None"
"3045","Field","headerSize","None","None"
"3046","Field","chunkSize","None","None"
"3047","Field","headerStart","None","None"
"3048","Field","in","None","None"
"3049","Field","countIn","None","None"
"3050","Field","type","None","None"
"3051","Field","start","None","None"
"3052","Field","offset","None","None"
"3053","Field","count","None","None"
"3054","Field","offset","None","None"
"3055","Field","count","None","None"
"3056","Method","decode","public static ResPackage[] decode(InputStream arscStream) throws AndrolibException {
    try {
      RawARSCDecoder decoder = new RawARSCDecoder(arscStream);
      System.out.printf(""parse to get the exist names in the resouces.arsc first\n"");
      return decoder.readTable();
    } catch (IOException ex) {
      throw new AndrolibException(""Could not decode arsc file"", ex);
    }
  }","None"
"3057","Field","arscStream","None","None"
"3058","Field","decoder","None","None"
"3059","Method","getExistTypeSpecNameStrings","public static Set<String> getExistTypeSpecNameStrings(int type) {
    return mExistTypeNames.get(type);
  }","None"
"3060","Field","type","None","None"
"3061","Method","readTable","private ResPackage[] readTable() throws IOException, AndrolibException {
    nextChunkCheckType(Header.TYPE_TABLE);
    int packageCount = mIn.readInt();
    StringBlock.read(mIn);
    ResPackage[] packages = new ResPackage[packageCount];
    nextChunk();
    for (int i = 0; i < packageCount; i++) {
      packages[i] = readTablePackage();
    }
    return packages;
  }","None"
"3062","Field","packageCount","None","None"
"3063","Field","packages","None","None"
"3064","Method","readTablePackage","private ResPackage readTablePackage() throws IOException, AndrolibException {
    checkChunkType(Header.TYPE_PACKAGE);
    int id = mIn.readInt();
    String name = mIn.readNullEndedString(128, true);
    /* typeNameStrings */
    mIn.skipInt();
    /* typeNameCount */
    mIn.skipInt();
    /* specNameStrings */
    mIn.skipInt();
    /* specNameCount */
    mIn.skipInt();

    // TypeIdOffset was added platform_frameworks_base/@f90f2f8dc36e7243b85e0b6a7fd5a590893c827e
    // which is only in split/new applications.
    int splitHeaderSize = (2 + 2 + 4 + 4 + (2 * 128) + (4 * 5)); // short, short, int, int, char[128], int * 4
    if (mHeader.headerSize == splitHeaderSize) {
      mTypeIdOffset = mIn.readInt();
    }

    mTypeNames = StringBlock.read(mIn);
    mSpecNames = StringBlock.read(mIn);
    mResId = id << 24;
    mPkg = new ResPackage(id, name);
    nextChunk();
    while (mHeader.type == Header.TYPE_LIBRARY) {
      readLibraryType();
    }
    while (mHeader.type == Header.TYPE_SPEC_TYPE) {
      readTableTypeSpec();
    }

    return mPkg;
  }","None"
"3065","Field","id","None","None"
"3066","Field","name","None","None"
"3067","Field","splitHeaderSize","None","None"
"3068","Method","readLibraryType","private void readLibraryType() throws AndrolibException, IOException {
    checkChunkType(Header.TYPE_LIBRARY);
    int libraryCount = mIn.readInt();

    int packageId;
    String packageName;

    for (int i = 0; i < libraryCount; i++) {
      packageId = mIn.readInt();
      packageName = mIn.readNullEndedString(128, true);
      System.out.printf(""Decoding Shared Library (%s), pkgId: %d\n"", packageName, packageId);
    }

    nextChunk();
    while (mHeader.type == Header.TYPE_TYPE) {
      readTableTypeSpec();
    }
  }","None"
"3069","Field","libraryCount","None","None"
"3070","Field","packageId","None","None"
"3071","Field","packageName","None","None"
"3072","Method","readTableTypeSpec","private void readTableTypeSpec() throws AndrolibException, IOException {
    readSingleTableTypeSpec();

    nextChunk();
    while (mHeader.type == Header.TYPE_SPEC_TYPE) {
      readSingleTableTypeSpec();
      nextChunk();
    }
    while (mHeader.type == Header.TYPE_TYPE) {
      readConfig();
      nextChunk();
    }
  }","None"
"3073","Method","readSingleTableTypeSpec","private void readSingleTableTypeSpec() throws AndrolibException, IOException {
    checkChunkType(Header.TYPE_SPEC_TYPE);
    int id = mIn.readUnsignedByte();
    mIn.skipBytes(3);
    int entryCount = mIn.readInt();

    /* flags */
    mIn.skipBytes(entryCount * 4);

    mCurTypeID = id;
    mResId = (0xff000000 & mResId) | id << 16;
    mType = new ResType(mTypeNames.getString(id - 1), mPkg);
  }","None"
"3074","Field","id","None","None"
"3075","Field","entryCount","None","None"
"3076","Method","readConfig","private void readConfig() throws IOException, AndrolibException {
    checkChunkType(Header.TYPE_TYPE);
    int typeId = mIn.readUnsignedByte() - mTypeIdOffset;

    int typeFlags = mIn.readByte();
    /* reserved */
    mIn.skipBytes(2);

    int entryCount = mIn.readInt();
    int entriesStart = mIn.readInt();
    readConfigFlags();
    int[] entryOffsets = mIn.readIntArray(entryCount);
    for (int i = 0; i < entryOffsets.length; i++) {
      if (entryOffsets[i] != -1) {
        mResId = (mResId & 0xffff0000) | i;
        readEntry();
      }
    }
  }","None"
"3077","Field","typeId","None","None"
"3078","Field","typeFlags","None","None"
"3079","Field","entryCount","None","None"
"3080","Field","entriesStart","None","None"
"3081","Field","entryOffsets","None","None"
"3082","Method","readEntry","private void readEntry() throws IOException, AndrolibException {
    /* size */
    mIn.skipBytes(2);
    short flags = mIn.readShort();
    int specNamesId = mIn.readInt();
    putTypeSpecNameStrings(mCurTypeID, mSpecNames.getString(specNamesId));
    boolean readDirect = false;
    if ((flags & ENTRY_FLAG_COMPLEX) == 0) {
      readDirect = true;
      readValue(readDirect, specNamesId);
    } else {
      readDirect = false;
      readComplexEntry(readDirect, specNamesId);
    }
  }","，id"
"3083","Field","flags","None","None"
"3084","Field","specNamesId","None","None"
"3085","Field","readDirect","None","None"
"3086","Method","readComplexEntry","private void readComplexEntry(boolean flags, int specNamesId) throws IOException, AndrolibException {
    int parent = mIn.readInt();
    int count = mIn.readInt();
    for (int i = 0; i < count; i++) {
      mIn.readInt();
      readValue(flags, specNamesId);
    }
  }","None"
"3087","Field","flags","None","None"
"3088","Field","specNamesId","None","None"
"3089","Field","parent","None","None"
"3090","Field","count","None","None"
"3091","Method","readValue","private void readValue(boolean flags, int specNamesId) throws IOException, AndrolibException {
    /* size */
    mIn.skipCheckShort((short) 8);
    /* zero */
    mIn.skipCheckByte((byte) 0);
    byte type = mIn.readByte();
    int data = mIn.readInt();
  }","None"
"3092","Field","flags","None","None"
"3093","Field","specNamesId","None","None"
"3094","Field","type","None","None"
"3095","Field","data","None","None"
"3096","Method","readConfigFlags","private void readConfigFlags() throws IOException, AndrolibException {
    int read = 28;
    int size = mIn.readInt();
    if (size < 28) {
      throw new AndrolibException(""Config size < 28"");
    }

    boolean isInvalid = false;
    short mcc = mIn.readShort();
    short mnc = mIn.readShort();
    char[] language = new char[] { (char) mIn.readByte(), (char) mIn.readByte() };
    char[] country = new char[] { (char) mIn.readByte(), (char) mIn.readByte() };
    byte orientation = mIn.readByte();
    byte touchscreen = mIn.readByte();
    int density = mIn.readUnsignedShort();
    byte keyboard = mIn.readByte();
    byte navigation = mIn.readByte();
    byte inputFlags = mIn.readByte();
    /* inputPad0 */
    mIn.skipBytes(1);

    short screenWidth = mIn.readShort();
    short screenHeight = mIn.readShort();

    short sdkVersion = mIn.readShort();
    /* minorVersion, now must always be 0 */
    mIn.skipBytes(2);

    byte screenLayout = 0;
    byte uiMode = 0;
    short smallestScreenWidthDp = 0;

    if (size >= 32) {
      screenLayout = mIn.readByte();
      uiMode = mIn.readByte();
      smallestScreenWidthDp = mIn.readShort();
      read = 32;
    }

    short screenWidthDp = 0;
    short screenHeightDp = 0;
    if (size >= 36) {
      screenWidthDp = mIn.readShort();
      screenHeightDp = mIn.readShort();
      read = 36;
    }

    char[] localeScript = null;
    char[] localeVariant = null;
    if (size >= 48) {
      localeScript = readScriptOrVariantChar(4).toCharArray();
      localeVariant = readScriptOrVariantChar(8).toCharArray();
      read = 48;
    }

    byte screenLayout2 = 0;
    if (size >= 52) {
      screenLayout2 = mIn.readByte();
      mIn.skipBytes(3); // reserved padding
      read = 52;
    }

    if (size >= 56) {
      mIn.skipBytes(4);
      read = 56;
    }

    if (size >= 64) {
      mIn.skipBytes(8);
      read = 64;
    }

    int exceedingSize = size - KNOWN_CONFIG_BYTES;
    if (exceedingSize > 0) {
      byte[] buf = new byte[exceedingSize];
      mIn.readFully(buf);
      BigInteger exceedingBI = new BigInteger(1, buf);

      if (exceedingBI.equals(BigInteger.ZERO)) {
        LOGGER.fine(String.format(""Config flags size > %d, but exceeding bytes are all zero, so it should be ok."",
            KNOWN_CONFIG_BYTES
        ));
      } else {
        LOGGER.warning(String.format(""Config flags size > %d. Exceeding bytes: 0x%X."",
            KNOWN_CONFIG_BYTES,
            exceedingBI
        ));
      }
    } else {
      int remainingSize = size - read;
      if (remainingSize > 0) {
        mIn.skipBytes(remainingSize);
      }
    }
  }","None"
"3097","Field","read","None","None"
"3098","Field","size","None","None"
"3099","Field","isInvalid","None","None"
"3100","Field","mcc","None","None"
"3101","Field","mnc","None","None"
"3102","Field","language","None","None"
"3103","Field","country","None","None"
"3104","Field","orientation","None","None"
"3105","Field","touchscreen","None","None"
"3106","Field","density","None","None"
"3107","Field","keyboard","None","None"
"3108","Field","navigation","None","None"
"3109","Field","inputFlags","None","None"
"3110","Field","screenWidth","None","None"
"3111","Field","screenHeight","None","None"
"3112","Field","sdkVersion","None","None"
"3113","Field","screenLayout","None","None"
"3114","Field","uiMode","None","None"
"3115","Field","smallestScreenWidthDp","None","None"
"3116","Field","screenWidthDp","None","None"
"3117","Field","screenHeightDp","None","None"
"3118","Field","localeScript","None","None"
"3119","Field","localeVariant","None","None"
"3120","Field","screenLayout2","None","None"
"3121","Field","exceedingSize","None","None"
"3122","Field","buf","None","None"
"3123","Field","exceedingBI","None","None"
"3124","Field","remainingSize","None","None"
"3125","Method","readScriptOrVariantChar","private String readScriptOrVariantChar(int length) throws AndrolibException, IOException {
    StringBuilder string = new StringBuilder(16);

    while (length-- != 0) {
      short ch = mIn.readByte();
      if (ch == 0) {
        break;
      }
      string.append((char) ch);
    }
    mIn.skipBytes(length);

    return string.toString();
  }","None"
"3126","Field","length","None","None"
"3127","Field","string","None","None"
"3128","Field","ch","None","None"
"3129","Method","nextChunk","private Header nextChunk() throws IOException {
    return mHeader = Header.read(mIn, mCountIn);
  }","None"
"3130","Method","checkChunkType","private void checkChunkType(int expectedType) throws AndrolibException {
    if (mHeader.type != expectedType) {
      throw new AndrolibException(String.format(""Invalid chunk type: expected=0x%08x, got=0x%08x"",
          expectedType,
          mHeader.type
      ));
    }
  }","None"
"3131","Field","expectedType","None","None"
"3132","Method","nextChunkCheckType","private void nextChunkCheckType(int expectedType) throws IOException, AndrolibException {
    nextChunk();
    checkChunkType(expectedType);
  }","None"
"3133","Field","expectedType","None","None"
"3134","Method","putTypeSpecNameStrings","private void putTypeSpecNameStrings(int type, String name) {
    Set<String> names = mExistTypeNames.get(type);
    if (names == null) {
      names = new HashSet<>();
    }
    names.add(name);
    mExistTypeNames.put(type, names);
  }","None"
"3135","Field","type","None","None"
"3136","Field","name","None","None"
"3137","Field","names","None","None"
"3138","Class","Header","Header","None"
"3139","Field","TYPE_NONE","None","None"
"3140","Field","TYPE_TABLE","None","None"
"3141","Field","TYPE_PACKAGE","None","None"
"3142","Field","TYPE_TYPE","None","None"
"3143","Field","TYPE_SPEC_TYPE","None","None"
"3144","Field","TYPE_LIBRARY","None","None"
"3145","Field","type","None","None"
"3146","Field","headerSize","None","None"
"3147","Field","chunkSize","None","None"
"3148","Field","startPosition","None","None"
"3149","Field","endPosition","None","None"
"3150","Field","type","None","None"
"3151","Field","headerSize","None","None"
"3152","Field","chunkSize","None","None"
"3153","Field","headerStart","None","None"
"3154","Field","in","None","None"
"3155","Field","countIn","None","None"
"3156","Field","type","None","None"
"3157","Field","start","None","None"
"3158","Method","read","public static Header read(ExtDataInput in, CountingInputStream countIn) throws IOException {
      short type;
      int start = countIn.getCount();
      try {
        type = in.readShort();
      } catch (EOFException ex) {
        return new Header(TYPE_NONE, 0, 0, countIn.getCount());
      }
      return new Header(type, in.readShort(), in.readInt(), start);
    }","None"
"3159","Field","in","None","None"
"3160","Field","countIn","None","None"
"3161","Field","type","None","None"
"3162","Field","start","None","None"
"3163","Class","FlagsOffset","FlagsOffset","None"
"3164","Field","offset","None","None"
"3165","Field","count","None","None"
"3166","Field","offset","None","None"
"3167","Field","count","None","None"
"3168","Package","com.tencent.mm.androlib.res.data","com.tencent.mm.androlib.res.data","None"
"3169","Class","ResPackage","ResPackage","None"
"3170","Field","mName","None","None"
"3171","Field","mSpecNamesReplace","None","None"
"3172","Field","mSpecNamesBlock","None","None"
"3173","Field","mCanProguard","None","None"
"3174","Field","id","None","None"
"3175","Field","name","None","None"
"3176","Field","set","None","None"
"3177","Field","resID","None","None"
"3178","Field","resID","None","None"
"3179","Field","resID","None","None"
"3180","Field","value","None","None"
"3181","Field","specName","None","None"
"3182","Field","value","None","None"
"3183","Field","values","None","None"
"3184","Method","isCanResguard","public boolean isCanResguard() {
    return mCanProguard;
  }","None"
"3185","Method","setCanResguard","public void setCanResguard(boolean set) {
    mCanProguard = set;
  }","None"
"3186","Field","set","None","None"
"3187","Method","hasSpecRepplace","public boolean hasSpecRepplace(String resID) {
    return mSpecNamesReplace.containsKey(resID);
  }","None"
"3188","Field","resID","None","None"
"3189","Method","getSpecRepplace","public String getSpecRepplace(int resID) {
    return mSpecNamesReplace.get(resID);
  }","None"
"3190","Field","resID","None","None"
"3191","Method","putSpecNamesReplace","public void putSpecNamesReplace(int resID, String value) {
    mSpecNamesReplace.put(resID, value);
  }","None"
"3192","Field","resID","None","None"
"3193","Field","value","None","None"
"3194","Method","putSpecNamesblock","public void putSpecNamesblock(String specName, String value) {
    Set<String> values = mSpecNamesBlock.get(specName);
    if (values == null) {
      values = new HashSet<>();
      mSpecNamesBlock.put(specName, values);
    }
    values.add(value);
  }","None"
"3195","Field","specName","None","None"
"3196","Field","value","None","None"
"3197","Field","values","None","None"
"3198","Method","getSpecNamesBlock","public Map<String, Set<String>> getSpecNamesBlock() {
    return mSpecNamesBlock;
  }","None"
"3199","Method","getName","public String getName() {
    return mName;
  }","None"
"3200","Method","toString","public String toString() {
    return mName;
  }","None"
"3201","Class","ResID","ResID","None"
"3202","Field","package_","None","None"
"3203","Field","type","None","None"
"3204","Field","entry","None","None"
"3205","Field","id","None","None"
"3206","Field","package_","None","None"
"3207","Field","type","None","None"
"3208","Field","entry","None","None"
"3209","Field","id","None","None"
"3210","Field","package_","None","None"
"3211","Field","type","None","None"
"3212","Field","entry","None","None"
"3213","Field","id","None","None"
"3214","Field","hash","None","None"
"3215","Field","obj","None","None"
"3216","Field","other","None","None"
"3217","Method","toString","public String toString() {
    return String.format(""0x%08x"", id);
  }","None"
"3218","Method","hashCode","public int hashCode() {
    int hash = 17;
    hash = 31 * hash + this.id;
    return hash;
  }","None"
"3219","Field","hash","None","None"
"3220","Method","equals","public boolean equals(Object obj) {
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    final ResID other = (ResID) obj;
    if (this.id != other.id) {
      return false;
    }
    return true;
  }","None"
"3221","Field","obj","None","None"
"3222","Field","other","None","None"
"3223","Class","ResType","ResType","None"
"3224","Field","mName","None","None"
"3225","Field","mPackage","None","None"
"3226","Field","specNames","None","None"
"3227","Field","name","None","None"
"3228","Field","package_","None","None"
"3229","Field","name","None","None"
"3230","Method","getName","public String getName() {
    return mName;
  }","None"
"3231","Method","putSpecResguardName","public void putSpecResguardName(String name) throws AndrolibException {
    if (specNames.contains(name)) {
      throw new AndrolibException(String.format(
          ""spec proguard name duplicate in a singal type %s, spec name: %s\n"",
          getName(),
          name
      ));
    }
    specNames.add(name);
  }","None"
"3232","Field","name","None","None"
"3233","Method","toString","public String toString() {
    return mName;
  }","None"
"3234","Package","andresguard.tencent.com.andresguard_example","andresguard.tencent.com.andresguard_example","None"
"3235","Class","ApplicationTest","ApplicationTest","<a href=""http: d.android.com tools testing testing_android.html"">Testing Fundamentals"
"3236","Class","ExampleUnitTest","ExampleUnitTest","To work on unit tests, switch the Test Artifact in the Build Variants view"
"3237","Method","addition_isCorrect","public void addition_isCorrect() throws Exception {
    assertEquals(4, 2 + 2);
  }","None"
"3238","Class","MainActivity","MainActivity","None"
"3239","Field","savedInstanceState","None","None"
"3240","Field","toolbar","None","None"
"3241","Field","fab","None","None"
"3242","Field","view","None","None"
"3243","Field","drawer","None","None"
"3244","Field","toggle","None","None"
"3245","Field","navigationView","None","None"
"3246","Field","drawer","None","None"
"3247","Field","menu","None","None"
"3248","Field","item","None","None"
"3249","Field","id","None","None"
"3250","Field","item","None","None"
"3251","Field","id","None","None"
"3252","Field","drawer","None","None"
"3253","Method","onCreate","protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Fabric.with(this, new Crashlytics(), new CrashlyticsNdk());

    setContentView(R.layout.activity_main);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);

    FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
    fab.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View view) {
        Snackbar.make(view, ""Replace with your own action"", Snackbar.LENGTH_LONG).setAction(""Action"", null).show();
      }
    });

    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this,
        drawer,
        toolbar,
        R.string.navigation_drawer_open,
        R.string.navigation_drawer_close
    );
    drawer.setDrawerListener(toggle);
    toggle.syncState();

    NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);
    navigationView.setNavigationItemSelectedListener(this);
  }","None"
"3254","Field","savedInstanceState","None","None"
"3255","Field","toolbar","None","None"
"3256","Field","fab","None","None"
"3257","Field","view","None","None"
"3258","Field","drawer","None","None"
"3259","Field","toggle","None","None"
"3260","Field","navigationView","None","None"
"3261","Method","onClick","public void onClick(View view) {
        Snackbar.make(view, ""Replace with your own action"", Snackbar.LENGTH_LONG).setAction(""Action"", null).show();
      }","None"
"3262","Field","view","None","None"
"3263","Method","onBackPressed","public void onBackPressed() {
    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    if (drawer.isDrawerOpen(GravityCompat.START)) {
      drawer.closeDrawer(GravityCompat.START);
    } else {
      super.onBackPressed();
    }
  }","None"
"3264","Field","drawer","None","None"
"3265","Method","onCreateOptionsMenu","public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
  }","None"
"3266","Field","menu","None","None"
"3267","Method","onOptionsItemSelected","public boolean onOptionsItemSelected(MenuItem item) {
    // Handle action bar item clicks here. The action bar will
    // automatically handle clicks on the Home/Up button, so long
    // as you specify a parent activity in AndroidManifest.xml.
    int id = item.getItemId();

    if (id == R.id.action_settings) {
      return true;
    }

    return super.onOptionsItemSelected(item);
  }","None"
"3268","Field","item","None","None"
"3269","Field","id","None","None"
"3270","Method","onNavigationItemSelected","public boolean onNavigationItemSelected(MenuItem item) {
    // Handle navigation view item clicks here.
    int id = item.getItemId();

    if (id == R.id.nav_camera) {
      // Handle the camera action
    } else if (id == R.id.nav_gallery) {

    } else if (id == R.id.nav_slideshow) {

    } else if (id == R.id.nav_manage) {

    } else if (id == R.id.nav_share) {

    } else if (id == R.id.nav_send) {

    }

    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    drawer.closeDrawer(GravityCompat.START);
    return true;
  }","None"
"3271","Field","item","None","None"
"3272","Field","id","None","None"
"3273","Field","drawer","None","None"
"3274","Package","com.tinkerpatch.libres","com.tinkerpatch.libres","None"
"3275","Class","ExampleInstrumentedTest","ExampleInstrumentedTest","Instrumentation test, which will execute on an Android device"
"3276","Field","appContext","None","None"
"3277","Method","useAppContext","public void useAppContext() throws Exception {
    // Context of the app under test.
    Context appContext = InstrumentationRegistry.getTargetContext();

    assertEquals(""com.tinkerpatch.libres.test"", appContext.getPackageName());
  }","None"
"3278","Field","appContext","None","None"
"3279","Class","ExampleUnitTest","ExampleUnitTest","Example local unit test, which will execute on the development machine (host)"
"3280","Method","addition_isCorrect","public void addition_isCorrect() throws Exception {
    assertEquals(4, 2 + 2);
  }","None"
"3281","Class","ApplicationTest","ApplicationTest","<a href=""http: d.android.com tools testing testing_android.html"">Testing Fundamentals"
"3282","Class","ExampleUnitTest","ExampleUnitTest","To work on unit tests, switch the Test Artifact in the Build Variants view"
"3283","Method","addition_isCorrect","public void addition_isCorrect() throws Exception {
    assertEquals(4, 2 + 2);
  }","None"
"3284","Class","MainActivity","MainActivity","None"
"3285","Field","savedInstanceState","None","None"
"3286","Field","toolbar","None","None"
"3287","Field","fab","None","None"
"3288","Field","view","None","None"
"3289","Field","drawer","None","None"
"3290","Field","toggle","None","None"
"3291","Field","navigationView","None","None"
"3292","Field","drawer","None","None"
"3293","Field","menu","None","None"
"3294","Field","item","None","None"
"3295","Field","id","None","None"
"3296","Field","item","None","None"
"3297","Field","id","None","None"
"3298","Field","drawer","None","None"
"3299","Method","onCreate","protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Fabric.with(this, new Crashlytics(), new CrashlyticsNdk());

    setContentView(R.layout.activity_main);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);

    FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
    fab.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View view) {
        Snackbar.make(view, ""Replace with your own action"", Snackbar.LENGTH_LONG).setAction(""Action"", null).show();
      }
    });

    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this,
        drawer,
        toolbar,
        R.string.navigation_drawer_open,
        R.string.navigation_drawer_close
    );
    drawer.setDrawerListener(toggle);
    toggle.syncState();

    NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);
    navigationView.setNavigationItemSelectedListener(this);
  }","None"
"3300","Field","savedInstanceState","None","None"
"3301","Field","toolbar","None","None"
"3302","Field","fab","None","None"
"3303","Field","view","None","None"
"3304","Field","drawer","None","None"
"3305","Field","toggle","None","None"
"3306","Field","navigationView","None","None"
"3307","Method","onClick","public void onClick(View view) {
        Snackbar.make(view, ""Replace with your own action"", Snackbar.LENGTH_LONG).setAction(""Action"", null).show();
      }","None"
"3308","Field","view","None","None"
"3309","Method","onBackPressed","public void onBackPressed() {
    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    if (drawer.isDrawerOpen(GravityCompat.START)) {
      drawer.closeDrawer(GravityCompat.START);
    } else {
      super.onBackPressed();
    }
  }","None"
"3310","Field","drawer","None","None"
"3311","Method","onCreateOptionsMenu","public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
  }","None"
"3312","Field","menu","None","None"
"3313","Method","onOptionsItemSelected","public boolean onOptionsItemSelected(MenuItem item) {
    // Handle action bar item clicks here. The action bar will
    // automatically handle clicks on the Home/Up button, so long
    // as you specify a parent activity in AndroidManifest.xml.
    int id = item.getItemId();

    if (id == R.id.action_settings) {
      return true;
    }

    return super.onOptionsItemSelected(item);
  }","None"
"3314","Field","item","None","None"
"3315","Field","id","None","None"
"3316","Method","onNavigationItemSelected","public boolean onNavigationItemSelected(MenuItem item) {
    // Handle navigation view item clicks here.
    int id = item.getItemId();

    if (id == R.id.nav_camera) {
      // Handle the camera action
    } else if (id == R.id.nav_gallery) {

    } else if (id == R.id.nav_slideshow) {

    } else if (id == R.id.nav_manage) {

    } else if (id == R.id.nav_share) {

    } else if (id == R.id.nav_send) {

    }

    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    drawer.closeDrawer(GravityCompat.START);
    return true;
  }","None"
"3317","Field","item","None","None"
"3318","Field","id","None","None"
"3319","Field","drawer","None","None"
"3320","Class","ApplicationTest","ApplicationTest","<a href=""http: d.android.com tools testing testing_android.html"">Testing Fundamentals"
"3321","Class","ExampleUnitTest","ExampleUnitTest","To work on unit tests, switch the Test Artifact in the Build Variants view"
"3322","Method","addition_isCorrect","public void addition_isCorrect() throws Exception {
    assertEquals(4, 2 + 2);
  }","None"
"3323","Class","MainActivity","MainActivity","None"
"3324","Field","savedInstanceState","None","None"
"3325","Field","toolbar","None","None"
"3326","Field","fab","None","None"
"3327","Field","view","None","None"
"3328","Field","drawer","None","None"
"3329","Field","toggle","None","None"
"3330","Field","navigationView","None","None"
"3331","Field","drawer","None","None"
"3332","Field","menu","None","None"
"3333","Field","item","None","None"
"3334","Field","id","None","None"
"3335","Field","item","None","None"
"3336","Field","id","None","None"
"3337","Field","drawer","None","None"
"3338","Method","onCreate","protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Fabric.with(this, new Crashlytics(), new CrashlyticsNdk());

    setContentView(R.layout.activity_main);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);

    FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
    fab.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View view) {
        Snackbar.make(view, ""Replace with your own action"", Snackbar.LENGTH_LONG).setAction(""Action"", null).show();
      }
    });

    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this,
        drawer,
        toolbar,
        R.string.navigation_drawer_open,
        R.string.navigation_drawer_close
    );
    drawer.setDrawerListener(toggle);
    toggle.syncState();

    NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);
    navigationView.setNavigationItemSelectedListener(this);
  }","None"
"3339","Field","savedInstanceState","None","None"
"3340","Field","toolbar","None","None"
"3341","Field","fab","None","None"
"3342","Field","view","None","None"
"3343","Field","drawer","None","None"
"3344","Field","toggle","None","None"
"3345","Field","navigationView","None","None"
"3346","Method","onClick","public void onClick(View view) {
        Snackbar.make(view, ""Replace with your own action"", Snackbar.LENGTH_LONG).setAction(""Action"", null).show();
      }","None"
"3347","Field","view","None","None"
"3348","Method","onBackPressed","public void onBackPressed() {
    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    if (drawer.isDrawerOpen(GravityCompat.START)) {
      drawer.closeDrawer(GravityCompat.START);
    } else {
      super.onBackPressed();
    }
  }","None"
"3349","Field","drawer","None","None"
"3350","Method","onCreateOptionsMenu","public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
  }","None"
"3351","Field","menu","None","None"
"3352","Method","onOptionsItemSelected","public boolean onOptionsItemSelected(MenuItem item) {
    // Handle action bar item clicks here. The action bar will
    // automatically handle clicks on the Home/Up button, so long
    // as you specify a parent activity in AndroidManifest.xml.
    int id = item.getItemId();

    if (id == R.id.action_settings) {
      return true;
    }

    return super.onOptionsItemSelected(item);
  }","None"
"3353","Field","item","None","None"
"3354","Field","id","None","None"
"3355","Method","onNavigationItemSelected","public boolean onNavigationItemSelected(MenuItem item) {
    // Handle navigation view item clicks here.
    int id = item.getItemId();

    if (id == R.id.nav_camera) {
      // Handle the camera action
    } else if (id == R.id.nav_gallery) {

    } else if (id == R.id.nav_slideshow) {

    } else if (id == R.id.nav_manage) {

    } else if (id == R.id.nav_share) {

    } else if (id == R.id.nav_send) {

    }

    DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout);
    drawer.closeDrawer(GravityCompat.START);
    return true;
  }","None"
"3356","Field","item","None","None"
"3357","Field","id","None","None"
"3358","Field","drawer","None","None"
